
    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">Distributed Systems: Basics</h1>
<!----------------------------------------------------------------->
A distributed system consists of a set of agents and a set of named
channels.
A distributed system is represented by a labeled directed graph in
    which vertices represent agents and labeled directed edges
represent channels.
An edge labeled \(c\) from a vertex \(u\) to a vertex \(v\) represents
    a channel \(c\) where only agent \(u\) can send messages along
    \(c\), and only only agent \(v\) can receives messages along
\(c\).

<p>
The state of a channel is a queue of messages.
An agent sends a message along a channel by appending the 
message to the tail of the queue.
The message at the head of a non-empty queue of messages can be
delivered to the receiving agent.

    <h3 style="color:red;">Example</h3>
    The figure below shows a distributed system with agents A, B, C, and
    channels r, t, u, v, x, y, z. The figure shows that there can be
    multiple channels from one agent to another; for example, the
    channels called t and x are both from agent C to agent B.

    <figure>
    <img src="Channels_2.jpg" alt="Fig1" style="width:80%">
    <figcaption>Fig.1: Graph Representation of a Distributed Systems</figcaption>
</figure>

<p>
The state of a channel is a queue of messages.
An agent sends a message along a channel by appending the 
message to the tail of the queue.
The message at the head of a non-empty queue of messages can be
removed from the queue and delivered to the receiving agent.

<p>
Each agent has a set of variables.
An agent's variables are <i>local</i> to that agent; they can be read or
modified only by the agent.
The state of an agent is given by the values of its variables.

<p>
The state of the system is a tuple with an element of the tuple for the state of
    each agent and an element for the state of each channel.

<h4 class="w3-text-teal">State Transitions</h4>
The computational model of a distributed system is that of the
familiar, simple, nondeterministic loop described in the previous
chapter.
The guarded commands define the possible state transitions of the
system.

<p>
A distributed system changes state in only two ways:
<ol>
  <li>
  <i>Internal Action</i>: An agent executes an action in which the agent
  may changes state and append messages to its outgoing channels
  without receiving a message. 
  </li>
  <li>
  <i>Message Delivery</i>: A channel delivers a message which
  changes the state of the 
  channel by removing the message at its head, and where  and the
  state of the agent receiving the message may change,
  and the receiving agent may append messages to its outgoing channels.
  </li>
</ol>

When an agent changes its state it may also send messages on its outgoing channels.
<p>
Consider a state transition due to a channel \(u\) delivering a
    message to an agent \(c\) which causes \(c\) to send messages on
    its outgoing channels \(v\) and \(x\). This
    state transition changes the states of channels \(u\), \(v\) and
    \(x\) and may change the state of agent \(c\). The transition does not
change the state of any other channel or any other agent.

<p>
Here is an example of an internal action. Agent \(c\) executes an
internal action and sends messages on its outgoing channels. \(v\) and \(x\). This
    state transition changes the states of channels \(v\) and \(x\)
and may change the state of  \(c\).

<h3 class="w3-text-teal">Model of Computation</h3>
The model of computation we reviewed earlier is that of the <i>do - od
</i> loop: Computation progresses by executing any guarded command
whose guard evaluates to True. The model of computation for
distributed systems is similar: Computation progresses by delivering a
message from any channel that is not empty. There is one major
difference: <i>fairness.</i>

<h4 style="color:red;">Example</h4>
Consider the following example of a system with a single agent \(x\) and channels \(red\)
and \(blue\) directed from \(x\) to \(x\). Initially each channel
contains a single token. Agent \(x\) has the following states:
running and holding no tokens; stopped and holding a single token; and
stopped and holding 
two tokens.

<p>
Initially \(x\) is running and holds no tokens. If \(x\) receives a
token along the blue channel while \(x\) is running it sends the blue
token on channel \(blue\) and \(x\) remains running; this leaves the
system state unchanged.  If \(x\) receives a token from the red
channel then \(x\) stops.

<p>
The state of the system is a 3-tuple \(s\), where \(s_{0}, s_{1},
s_{2}\) are the states of agent \(x\) and channels \(red\) and
\(blue\), respectively. The state of an agent or channel is the set of
tokens in it. \(\emptyset\) represents the empty set. The state transitions are:
<ol>
  <li>
  <i>Deliver token on blue channel while \(x\) is running</i>:
  <p>
  \(
  (0, 1, 1) \; \rightarrow \; (0, 1, 1)
  \)
  </li>
  <li>
  <i>Deliver token on red channel while \(x\) is running</i>: 
  <p>
  \(
  (0, 1, 1) \; \rightarrow \; (1, 0, 1)
  \)
  </li>
  <li>
  <i>Deliver blue token while \(x\) is stopped</i>: 
  <p>
  \(
  (1, 0, 1) \; \rightarrow \; (2, 0, 0)
  \)
  </li>
</ol>

<p>
Let's see why the <i>do-od</i> model of computation isn't adequate for
this example. While \(x\) is running there are two guards that
evaluate to True: (1) channel \(red\) is non-empty and (2) channel
\(blue\) is non-empty. The computation can progress for ever by
repeatedly executing the guarded command that delivers the token in
the blue channel and never executing the command that delivers the
token in the red channel.


<h3 class="w3-text-teal">Fairness</h3>
We will define the concept of <i>fairness</i> in terms of a temporal
logic in a later module. Informally the model assumes that every message
encounters a finite positive delay, and that every agent that is ready
to make a state transition does so after a finite delay.

<h4 style="color:red;">Example</h4>
In our example, the delay encountered by a message in the red channel
is finite. Also the delay of a message in the blue channel is at least
a positive constant. An arbitrary, <i>but finite</i> number of
messages may be delivered on the blue channel before a message is
delivered on the red channel. So, the system does not remain in state
\((0, 1, 1)\) for ever. After a finite number of transitions from \((0,
1, 1)\) to \((0, 1, 1)\) the system will transit from \((0, 1, 1)\) to
\((1, 0, 1)\).

<h3 class="w3-text-teal">Proofs of Correctness</h3>

<h5 class="w3-text-teal">Safety</h5>
The rules that we gave earlier for safety apply to distributed
systems. The proofs are somewhat simpler because the only commands that
we have to deal with are the delivery of a message to an agent or an
internal action by an agent. For example,
consider the definition of <i>stable</i>.

<p>
The definition of \(P\) is <i>stable</i> is: the execution of a guarded
command in a state in which \(P\) holds causes a transition to a state
in which \(P\) continues to hold. The proof of stability for a distributed
system is simple because we have only two kinds of events. So, \(P\) is
<i>stable</i> exactly when (1) the delivery of a message or (2) an
agent makes an internal transition, in a state in which \(P\) holds
causes a transition to a state in which \(P\) continues to hold.


<h5 class="w3-text-teal">Progress</h5>

We prove that a predicate \(P\) doesn't hold forever as
follows. We show that if \(P\) holds then there is a non-empty channel
such that delivery of a message from this channel causes a transition
to a state in which \(\neg P\) holds.

From fairness, we know that the channel will
deliver a message eventually, and at that point \(P\) will no longer
hold.

<p>
We discuss fairness, progress and temporal logic in a later module.


<!------------------------------------------------------->
<footer id="myFooter">

<h5 style="color:red;">
<a href="../../index.html">Contents</a>
</h5>

    <div class="w3-container w3-theme-l1">
      <p>K. Mani Chandy,
      <br>
      Simon Ramo Professor, Emeritus,
      <br>
      California Institute of Technology</p>
    </div>


<!-- END MAIN -->
</div>
</body>
</html>
<!------------------------------------------------------->