
<!--------------------------------------------------------->
    <h2 class="w3-text-teal">Distributed Systems: Introduction</h2>
<!----------------------------------------------------------------->
A distributed system consists of a set of agents and a set of message-passing
channels. It is represented by a labeled directed graph in which vertices
  represent agents and labeled directed edges represent named
  channels.
  <p style="color:red;">Example</p>
    The figure below shows a distributed system with agents A, B, C.

    <figure>
    <img src="Channels_2.jpg" alt="Fig1" style="width:50%">
    <figcaption>Fig.1: Graph Representation of a Distributed Systems</figcaption>
  </figure>
  An edge labeled \(z\) directed from a vertex \(A\) to
    a vertex \(B\)
represents a channel \(z\) directed from agent \(A\) to agent \(B\).

A channel  \(z\) from an agent \(A\) to an agent \(B\) is called an
<i>outgoing</i> channel of \(A\) and an <i>incoming</i> channel of \(B\).

  <p class="w3-text-teal">Agent State</p>
  Each agent has a set of variables that are <i>local</i> to the agent;
other agents and channels cannot access these variables.
The state of an agent is given by the values of its variables.
<p>
Agent's may have local clocks; however, clocks are not perfectly
  synchronized. The instant at which one agent's clock reads 1200 may be
  before, after, or at the same instant at which a different clock
reads 1200.
We will discuss clock synchronization in later modules.

<p class="w3-text-teal">Channels</p>
  We will study different types of channels in this course.
  Messages may get lost, or messages may overtake
  earlier messages, in some channel types.
  The type of channel that we will study in this module and in the next several chapters
is a model of message-passing using the TCP
protocol; we describe this channel next.

<p>
An agent can send messages on its outgoing channels and receive
messages on its incoming channels.
All messages sent are delivered; messages are delivered in the order
sent; and message delays are arbitrary (but finite).

  
<p class="w3-text-teal">Channel State</p>
The state of a channel is a sequence of messages; these are
the messages in the channel.
<p>
Sending a message:
When an agent sends a message along a channel the message is
appended to the tail of the sequence of messages in the channel.

<p>
Receiving a message:
A message at the head of the sequence of messages in a nonempty
channel is removed from the sequence and delivered to the receiving
agent. 

  <h4 class="w3-text-teal">System States and Transitions</h4>
  The state of a system is given by the states of its agents and
channels. The system makes state transitions in two ways:
<ol>
  <li> <b>Message Delivery</b>:
  A message \(m\) at the head of a channel \(c\) which is directed
  towards an agent \(B\) is delivered to \(B\). 
  </li>
  <li>
  <b>Internal Transition</b>:
  An agent changes state without receiving messages.
  </li>
</ol>

When an agent changes state it may send messages on its outgoing
channels. State transitions are specified by guarded commands as
described next.

<h4 class="w3-text-teal">Guarded Command: Message Delivery</h4>

<p class="w3-text-teal">Guard for Message Delivery</p>

The guard for the delivery of a message from a channel
\(c\) is that \(c\) is nonempty.


<p class="w3-text-teal">Command for Message Delivery</p>
The command may change the state of the
agent that receives the messages and the agent may send messages on
its outgoing channels.
The next state of the agent and the messages sent by the
agent depend only on (1) the message that
the agent receives, (2) the identity of the
channel \(c\) from which the message is delivered, and (3) the agent's state
when it receives the message.

<h4 class="w3-text-teal">Guarded Command: Internal Transition</h4>
<p class="w3-text-teal">Guard for Internal Transition</p>
The guard for an internal transition of an agent \(B\) is a predicate
on the state of \(B\).
The guard is independent of the states of all channels and the states
of all agents other than \(B\).

<p class="w3-text-teal">Command for Internal Transition</p>
The command may change the state of the
\(B\) and may send messages on \(B\)'s outgoing channels.
\(B\)'s next state and the messages sent by the
agent depend only on \(B\)'s state prior to the transition.

<h4 class="w3-text-teal">Model of Computation</h4>
We begin by using the model of computation of nondeterministic
iteration: the
<a href="../../ReviewOfBasics/NondeterministicIteration/NondeterministicIteration.html ">do-od loop</a> from
sequential programming: execute any command whose guard evaluates to
True. Later we will introduce the concept of fairness.

<h4 class="w3-text-teal">Examples</h4>
An agent has incoming channels \(temperature\) and
\(pressure\). It has outgoing channels \(alarm\) and \(boiler\). The
agent has variables \(last\_temperature\) and \(last\_pressure\).

Here is an example of a command for message delivery from the
\(temperature\) channel. Let \(T\) be the message at the head of this
channel.
<pre>
if (T > last_temperature) and (T > 80):
   send message "high temperature" on alarm channel
   send message "lower heat" on boiler channel
last_temperature = T
</pre>

An example of a guarded command for an internal transition is as
follows. An agent has a Boolean variable \(active\).
<pre>
active -> send message "alert" on alarm channel
          active = False
</pre>

<h4 class="w3-text-teal">Timelines</h4>
Next we describe a graphical representation of system trajectories.

