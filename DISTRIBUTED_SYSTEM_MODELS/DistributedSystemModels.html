<title>DistributedSystemModels/DistributedSystemModels.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!--------------------------------------------------------->
    <h1 class="w3-text-teal">Models of Distributed Systems</h1>
<!----------------------------------------------------------------->
  <h5 class="w3-text-red">
  <i>Central Ideas</i></h5>
  <p class="w3-text-red">
  A model of distributed systems based on
  <a
  href="https://en.wikipedia.org/wiki/UNITY_(programming_language)">UNITY
  </a>
  which is a restricted version of
  <a
  href="https://lamport.azurewebsites.net/pubs/lamport-actions.pdf">
  action systems.
  </a>
  

  
  </p>

  <p class="w3-text-red">
  <i>
  A model is an abstraction that helps in developing algorithms.
  A model of a distributed system is defined by its components,
  states, and state transitions. The components of a distributed
  system are its agents and communication channels.
  </i>
  </p>

  <h2 class="w3-text-teal">Distributed System: Agents and Channels</h2>
  We use a simple model to develop algorithms. Later, we implement the
  algorithms using libraries such as
  <a href="https://en.wikipedia.org/wiki/Message_queue">Message Queue (MQ)</a> and
  <a href="https://aws.amazon.com/sqs/">AWS Simple Queue Service
  (SQS)</a>.

  <p>
  A distributed system consists of a set of agents and a set of
  communication channels.
  A communication channel is a queue.
  Each channel has exactly one agent that appends messages to it and
  exactly one agent that gets messages from it.
  The state of an agent is given by the agent's variables. An agent
  cannot access another agent's state.

<p>  
  Agents and channels of a system are represented by a labeled directed graph,
  called the agent-channel graph.
  In an agent-channel graph, vertices represent agents and
  edges represent channels.
  The direction and label of an edge are the direction and name of the
  channel that it represents.

  <p>
  A channel from an
  agent \(A\) to an agent \(B\) is an <i>output</i> channel of \(A\)
  and an <i>input</i> channel \(B\). An agent can append messages to its
  output channels and get messages from its input channels.  We
assume that the agent graph is given and does not change.
The model doesn't specify how the graph is created.

  
  <h4 style="color:red;">Example: Agent-Channel Graph</h4>
  The figure below shows an agent-channel graph with agents \(A, B,
C\) and channels \(u, v, w, x, y, z\).

    <figure>
    <img src="DistributedSystemModels/DistributedSystemModels.001.jpeg" alt="Fig1" style="width:30%">
    <figcaption>Fig.1: Example: An Agent Graph</figcaption>
  </figure>
 

  <h2 class="w3-text-teal">Agent Actions</h2>
The state of a system is given by the states of its agents and
  channels. The system state is a tuple with an element of the tuple
for each agent and each channel.

<p>
An agent is specified by its variables and a set of atomic actions.
An atomic action is a program that may change the agent's variables,
send messages on the agent's output channels, and receive a message on
one of the agent's input channels.

<p>
The only operations on channels are: append a message to a channel,
check if a channel is empty, and receive a message from a <i>nonempty</i>
channel.
These operations, written (using Python notation for queues) with <code>q</code> as a
channel and <code>msg</code> as a variable of an agent, are as follows:
<pre>
// Append msg to queue q
q.put(msg)

// if q is not empty, assign the message received from q into msg
// and execute following steps ...
if not q.empty():
    msg = q.get()
    ....
</pre>

<h4 style="color:red;">Example of an Action</h4>
An example action with input channel <code>x</code>, output channel
<code>y</code>, and variables <code>msg</code> and <code>sum</code> is:
<pre>
if not x.empty():
   msg = x.get()
   sum = sum + msg
   y.put(sum)
</pre>
This program takes no action if <code>x</code> is empty.
If <code>x</code> is not empty then a message is received from
<code>x</code> and assigned to  <code>msg</code>; then
<code>sum</code> is incremented; and then the resulting
<code>sum</code> is appended to  <code>y</code>.


<p>
(Note: Another way to get a message from a nonempty queue
is to use <code>get</code> without blocking, and catch the empty exception.)

<h3 class="w3-text-teal">Atomicity of Actions</h3>
We will write programs in which <i>executions of actions always
terminate, independent of channels and other agents.</i>
For example, we desing agents with actions that do not wait until a channel
becomes nonempty.
This is because execution of an action must terminate even if a
channel remains empty forever.



<h2 class="w3-text-teal">System States and Transitions</h2>
The state of a distributed system is a tuple with an element of the
tuple for each agent and each channel.
A state transition is either an execution of an action by an agent or
an execution of the <i>empty action</i>.
Execution of the empty action leaves the state unchanged.
The empty action is equivalent to <code>pass</code> in Python.
We will see how the empty action is used in our model of distributed
systems. 

<p>
The execution of an action by an agent
may change the agents' variables, send messages on the agent's output
channels, and receive a message on one of the agent's input channels.
The states of all other agents and channels remain unchanged.
A transition may be from a state back to itself.


<p>
The set of state transitions of a system is a set of
4-tuples \((S, a, x, S')\) where \(S\) and
\(S'\) are the states before and after (respectively) the transition caused by
execution of action \(a\) by agent \(x\).
Any agent may execute any action in any state.
So, for all states \(S\) and all actions \(a\) of all agents \(x\) there
is <i>at least one</i> transition from \(S\) due to the execution of \(a\)
by \(x\).




<h3 class="w3-text-teal">The State-Transition Graph</h3>
The states and transitions of a system are represented by a directed
multigraph, called the <i>state-transition graph</i> in which each vertex
represents a state and each edge represents a state
transition.
The graph has an edge labeled \((a, x)\) from \(S\) to \(S'\) exactly
when execution of action \(a\) by agent \(x\) in state \(S\) can cause
a transition to \(S'\).

Any action of any agent can be executed in any state; so,
for each vertex \(S\) and each action \(a\) of each agent \(x\) there is at
least one edge from \(S\) labeled \((a, x)\).


<p>
An edge from a vertex back to itself due to the execution of the empty
action is labeled \((None, None)\).
These edges are in the graph but aren't always shown in figures.

<h4 style="color:red;">Example of a State-Transition Graph</h4>
The figure below shows a state-transition graph with agents \(u,
v\). Agent \(u\) has actions \(b\) and \(g\); executing these actions
result in the transitions shown as blue edges and green edges
(respectively).
Agent \(v\) has action \(r\); executing this action
result in the transitions shown as red edges.

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.002.jpeg"
    alt="Fig2" style="width:75%"> 
    <figcaption>Fig.2: Example: A State-Transition Graph</figcaption>
</figure>
The transitions from each state back to itself due to empty actions are
not shown. Only some of the states are shown; the dangling edges are
    to states that don't appear in the figure.
<p>
For each edge label \((b, u), (g, u), (g, v)\), and each state, there
is at least one outgoing edge with that label.
There are two edges from state \(S1\) with label \((g, u)\); executing
    action \(g\) by agent \(u\) when the system is in state \(S1\) may
    result in a transition to \(S2\) or to some other state.


<h4 style="color:red;">Example: State-Transition Graph of a Simple Distributed System</h4>

This example system has two agents <code>u</code> and <code>v</code>.
The system has two channels
<code>uv</code> and <code>vu</code>, from <code>u</code>
to <code>v</code> and from <code>v</code> to <code>u</code>,
respectively. 
The system has one blue token and one red token.
(Later, when we discuss file management, we will use a token to represent exclusive
access to a file, and use the token color to identify the file.)

<p>

The state of an agent is the set of tokens that it holds.
Each agent has two actions: send a token and receive a token.
These actions are denoted
by <code>s</code> and <code>r</code> for send and receive, respectively.

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.003.jpeg"
    alt="Fig3" style="width:100%"> 
    <figcaption>Fig.3: Example</figcaption>
</figure>


<h4 style="color:red;">Example: States and Transitions</h4>
A state \(S\) of the system is a tuple, \((S_{u}, S_{v},S_{uv},
S_{vu})\), where the elements of the tuple are the states of agent
<code>u</code>, agent <code>v</code>, channel <code>uv</code>
and channel <code>vu</code>, respectively.

<p>
The figure shows some of the states and transitions of the system.
The diagram on the top left of the figure depicts a system state in
which <code>u</code> holds the blue token, 
<code>v</code> holds the red token, and both channels are empty.
This state, \((S_{u}, S_{v},S_{uv}, S_{vu})\), is <code>({b}, {r}, [],
[])</code>.

<p>
If agent <code>u</code>  sends
a token while the system is in this state then the system transits to
state <code>({}, {r}, [b], [])</code> in which the blue token is in
the channel <code>uv</code>; agent <code>u</code> holds no tokens; the
red token remains at agent <code>v</code>; and channel <code>vu</code>
remains empty.
This transition is labeled \((s, u)\) because
<code>u</code> <i>s</i>ends a token in the transition.
The state after the transition is shown in the diagram on the top row, second column.

<p>
A different transition from <code>({b}, {r}, [], [])</code> is one in
which <code>v</code> sends a token. The state, <code>({b},
{}, [], [r])</code> after the transition is shown in the first column, second row.  


<h5 style="color:red;">Example: Agent Actions</h5>
Each agent has a variable <code>tokens_I_hold</code> which is the set
of tokens that the agent holds.
Each agent also has a variable <code>token</code> which is
assigned to the token that the agent receives.

<h5 style="color:red;">Example: Receive token</h5>
The action in which agent <code>u</code> receives a token, and adds
the token to its set of tokens is: 
<pre>
if not vu.empty():
    token = vu.get()
    tokens_I_hold = tokens_I_hold.add(token)
</pre>

<h5 style="color:red;">Example: Send token</h5>
Agent <code>u</code> also has an action in which it sends a token that it
holds. The action is:
<pre>
// if the agent holds at least one token
if len(tokens_I_hold) > 0:
   // token is any element in tokens_I_hold
   token = state.pop()
   tokens_I_hold.remove(token)
   uv.put(token)
</pre>

<h5 style="color:red;">Example of Nondeterministic Actions</h5>
In the above example, when agent <code>u</code> holds both red and
blue tokens, the action in which <code>u</code> sends a token may
result in <code>u</code> sending 
either the red token or the blue token. So, the same action results in
one of two possible next states.

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.004.jpeg"
    alt="Fig2" style="width:60%"> 
    <figcaption>Fig.4: Example - Nondeterministic Action</figcaption>
</figure>

The two possible transitions are shown as the two edges labeled
<code>(s, u)</code> in the diagram at the extreme left of the figure.



<!----------------------------------------------------------------->
<h2 class="w3-text-teal">Computations: Paths in State Graphs</h2>

A <i>computation</i> of a system is a state
\(S_{0}\) of the system and a sequence of <i>steps</i> where each step
is a state transition and the \(i\)-th step is \((S_{i-1}, a_{i},
x_{i}, S_{i})\), where \(S_{i-1}\) is the state before the step,
\(S_{i}\) is the state after the step, and the transition is due to
the execution of action \(a_{i}\) at agent \(x_{i}\).
The sequence of steps may be empty, infinite, or finite.

<p>
A computation is specified by a path in the state transition graph.

<h4 style="color:red;">Example: Computation specified by a path in the
state transition graph</h4>
The figure below shows a path \((S_{0}, \ldots S_{8})\) in the state transition graph of the
example system given earlier.
<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.005.jpeg"
    alt="Fig16" style="width:60%"> 
    <figcaption>Fig.4: Example - Computation is a Path in the State Graph</figcaption>
</figure>

A state of this system is a tuple \((S_{U}, S_{V},S_{UV},
S_{VU})\).
State \(S_{0}\) is \((\{b\}, \{r\}, [], [])\). Examples of steps in
the computation are given below.
<ol>
  <li>
  Step 1: \((S_{0}, a_{1}, x_{1},  S_{1})\):
  <p>
  \(((\{b\}, \{r\}, [], []), s, u, (\{\}, \{r\}, [b], []))\)
  </li>
  <li>
  Step 2: \((S_{1}, a_{2}, x_{2},  S_{2})\):
  <p>
  \(((\{\}, \{r\}, [b], []), s, v, (\{\}, \{\}, [b], [r]))\)
  </li>
  <li>
  Step 3: \((S_{2}, a_{3}, x_{3},  S_{3})\):
  <p>
  \(((\{\}, \{\}, [b], [r]), r, v, (\{\}, \{b\}, [], [r]))\)
  </li>
</ol>


<h4 class="w3-text-teal">Message Delays are Arbitrary</h4>
A system can execute the empty action repeatedly
and thus remain in the same state for an arbitrary number of state
transitions.
For all \(n \geq 0\), 
there can be a computation with a state transition in which an agent sends a message,
followed by \(n\) state transitions from a state back to
itself, followed by a transition in which the message is received.
Message delay -- in terms of number of state transitions
-- is arbitrary.

<h4 class="w3-text-teal">Progress</h4>
The model allows for an infinite computation that executes the empty
action forever and remains forever in the same state.
Later, we extend the model to include the concept of <i>fairness</i>.
We use the concept of fairness to prove that all computations progress
towards a specified goal.


<h3 class="w3-text-teal">Model Simplicity, Adequacy, and Limitations</h3>
This model, based on
<a href="https://en.wikipedia.org/wiki/UNITY_(programming_language)">
UNITY, is chosen because it is both very simple and adequate</a> for
describing important algorithms.
Libraries such as
<a
href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">
Advanced Message Queuing Protocol</a>
and
<a href="https://aws.amazon.com/sqs/">
Amazon Web Services Simple Queue Service (AWS SQS)
</a>
offer communication operators in addition to appending
and removing elements from a queue, set, or other data structure.
Algorithms that use more powerful primitives
can be rewritten using our model.



<p>
The model can be extended to communication mechanisms other than first-in-first-out
channels. If messages may be delivered out of order then we represent
a channel by a set. Lossy channels are represented by having agents
that delete messages.


<p class="w3-text-teal">No construct for Time</p>
Inexpensive atomic clocks on PC boards, Precision Time
Protocols (PTP) in local area networks, and Network Time Protocol
(NTP) servers, allow processes to have accurate clocks.
The absence of time is a limitation of the model.
Later, we discuss clock synchronization, the use of time in
algorithms, and models that include time.



<h4 class="w3-text-red">
<i>Central Ideas: Review</i></h4>

<p class="w3-text-red">
A state of the system is given by the states of its components -- agents
and communication channels.

A state transition is caused by the execution of an action at an
agent.

A state transition may change the state of the agent that executes the
action, and receive a message on an input channel of the agent, and
send messages on output channels of the agent.

A computation is a sequence of steps where each step is specified by
the states of the system before and after the step, the agent that
executes the action that causes the state transition, and the action.

<p class="w3-text-red">
<i>Concepts</i>:
 Distributed system, agents and channels -> states -> state
transitions. 


<h3 class="w3-text-teal">Next</h3>
Next look at
<a href="Timelines.html">Timelines of Computations.</a>
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
