<title>DistributedSystemModels/DistributedSystemModels.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!--------------------------------------------------------->
    <h1 class="w3-text-teal">Models of Distributed Systems</h1>
<!----------------------------------------------------------------->
  <h5 class="w3-text-red">
  <i>Central Ideas</i></h5>
  <p class="w3-text-red">
  A model of distributed systems based on
  <a
  href="https://en.wikipedia.org/wiki/UNITY_(programming_language)">UNITY
  </a>
  which is a restricted version of
  <a
  href="https://lamport.azurewebsites.net/pubs/lamport-actions.pdf">
  action systems.
  </a>
  

  
  </p>

  <p class="w3-text-red">
  <i>
  A model is an abstraction that helps in developing algorithms.
  A model of a distributed system is defined by its components,
  states, and state transitions. The components of a distributed
  system are its agents and communication channels.
  </i>
  </p>

  <h2 class="w3-text-teal">Distributed System: Agents and Channels</h2>
  We use a simple model to develop algorithms. Later, we implement the
  algorithms using libraries such as
  <a href="https://en.wikipedia.org/wiki/Message_queue">Message Queue (MQ)</a> and
  <a href="https://aws.amazon.com/sqs/">AWS Simple Queue Service
  (SQS)</a>.

  <p>
  A distributed system consists of a set of agents and a set of
  communication channels.
  A communication channel is a queue.
  Each channel has exactly one agent that appends messages to it and
  exactly one agent that gets messages from it.
  The state of an agent is given by the agent's variables. An agent
  cannot access another agent's state.

<p>  
  Agents and channels of a system are represented by a labeled directed graph,
  called the agent-channel graph.
  In an agent-channel graph, vertices represent agents and
  edges represent channels.
  The direction and label of an edge are the direction and name of the
  channel that it represents.

  <p>
  A channel from an
  agent \(A\) to an agent \(B\) is an <i>output</i> channel of \(A\)
  and an <i>input</i> channel \(B\). An agent can append messages to its
  output channels and get messages from its input channels.  We
assume that the agent graph is given and does not change.
The model doesn't specify how the graph is created.

  
  <p style="color:red;">Example: Agent-Channel Graph</p>
  The figure below shows an agent-channel graph with agents \(A, B,
C\) and channels \(u, v, w, x, y, z\).

    <figure>
    <img src="DistributedSystemModels/DistributedSystemModels.001.jpeg" alt="Fig1" style="width:30%">
    <figcaption>Fig.1: Example: An Agent Graph</figcaption>
  </figure>
 

  <h2 class="w3-text-teal">Agent and Channel State Transitions</h2>
The state of a system is given by the states of its agents and
  channels. The system state is a tuple with an element of the tuple
for each agent and each channel.

<p>
An agent is specified by its variables and a set of atomic actions.
An atomic action is a program that may change the agent's variables,
send messages on the agent's output channels, and receive a message on
one of the agent's input channels.
An agent's action always terminates independent of the states of other
agents and the states of all channels.

<p>
The only operations on channels are: append a message to a channel,
check if a channel is empty, and receive a message from a <i>nonempty</i>
channel.
These operations, written (using Python notation for queues) with <code>q</code> as a
channel and <code>msg</code> as a variable of an agent, are as follows:
<pre>
// Append msg to queue q
q.put(msg)

// if q is not empty, assign the message received from q into msg
// and execute following steps ...
if not q.empty():
    msg = q.get()
    ....
</pre>

<p style="color:red;">Example of an Action</p>
An example action with input channel <code>x</code>, output channel
<code>y</code>, and variables <code>msg</code> and <code>sum</code> is:
<pre>
if not x.empty():
   msg = x.get()
   sum = sum + msg
   y.put(sum)
</pre>
This program takes no action if <code>x</code> is empty.
If <code>x</code> is not empty then a message is received from
<code>x</code> and assigned to  <code>msg</code>; then
<code>sum</code> is incremented; and then the resulting
<code>sum</code> is appended to  <code>y</code>.


<p>
(Note: Another way to get a message from a nonempty queue
is to use <code>get</code> without blocking, and catch the empty exception.)



<h2 class="w3-text-teal">System States and Transitions</h2>
The state of a distributed system is a tuple with an element of the
tuple for each agent and each channel.

<p>
The execution of an action at an agent causes a state transition.
The action may change the agents' variables, send messages on its output
channels, and receive a message on one of the agent's input channels.
The states of all other agents and channels remains unchanged.
A transition may be from from a state back to itself.


<p>
The set of state transitions of a system is a set of
4-tuples \((S, a, X, S')\) where \(S\) and
\(S'\) are the states before and after (respectively) the transition caused by
execution of action \(a\) of agent \(X\).
Any action of any agent may be executed in any state.
So, for all states \(S\) and all actions \(a\) of all agents \(X\) there
is <i>at least one</i> transition from \(S\) due to execution of \(a\)
by \(X\).

<p>
If a system has state transitions \((S, a, X, S')\) and \((S,
a, X, S'')\) then execution of action \(a\) of agent \(X\) in state
\(S\) may result in a next state that is \(S'\) or \(S''\).



<h4 class="w3-text-teal">Empty Action</h4>
In addition to agent actions, the system has an action called an <i>empty
action</i> or stutter that takes the system from each state back to the
same state.

<p>
A system can execute the empty action repeatedly
and thus remain in the same state for an arbitrary number of state
transitions.
So, there can be a state transition in which an agent sends a message,
followed by an arbitrary number of transitions from the state back to
itself, followed by a transition in which the message is received.
The message delay -- measured in terms of number of state transitions
-- is arbitrarily large.


<h3 class="w3-text-teal">The State-Transition Graph</h3>
The states and transitions of a system are represented by a directed
multigraph, called the <i>state-transition graph</i> in which each vertex
represents a state and each labeled edge represents the execution of
an action.
For each vertex \(S\) and each action \(a\) of an agent there is at
least one edge from \(S\) labeled \(a\).
The edge may be from a vertex back to itself.

<p style="color:red;">Example of a State-Transition Graph</p>
The figure below shows a state-transition graph with edge labels R, B,
G.
The edges corresponding to these labels are colored red, blue, and
green.
Each label represents an action of an agent.
<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.002.jpeg"
    alt="Fig2" style="width:75%"> 
    <figcaption>Fig.2: Example: A State-Transition Graph</figcaption>
</figure>
The transitions from each state back to itself due to stuttering are
not shown. 


<h4 style="color:red;">Example: State-Transition Graph of a Simple Distributed System</h4>

This system has two agents <code>U, V</code> and channels
<code>channel_UV</code>, <code>channel_VU</code> from <code>U</code>
to <code>V</code>, and from <code>V</code> to <code>U</code>,
respectively. 
The system has one blue token and one red token.
Later, when we discuss file management, we will use a token to represent exclusive
access to a file, and use the token color to identify the file.

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.003.jpeg"
    alt="Fig2" style="width:100%"> 
    <figcaption>Fig.3: Example</figcaption>
</figure>


<p style="color:red;">Example: States and Transitions</p>
A state \(S\) of the system is a tuple, \((S_{U}, S_{V},S_{UV},
S_{VU})\), where the elements of the tuple are the states of agent
<code>U</code>, agent <code>V</code>, channel <code>channel_UV</code>
and <code>channel_VU</code>, respectively.
The state of an agent is the set of tokens that it holds.
The state of a channel is a queue of tokens.

<p>
The figure shows some of the states and transitions of the system. All
the states are not shown.
<p>
The diagram on the top left of the figure depicts a system state in
which <code>U</code> holds the blue token, 
<code>V</code> holds the red token, and both channels are empty.
This state is <code>({B}, {R}, [], [])</code>.
<p>
There is a transition from this state in which <code>U</code> sends
the blue token. This transition is labeled \(U_{s}\) because
<code>U</code> <i>s</i>ends a token, and the transition is shown as a
blue arrow because the transition moves a blue token.

<p>
In the state after the transition, the blue token is in
<code>channel_UV</code>, and <code>U</code> holds no tokens.
The next state is <code>({}, {R}, [B], [])</code>.
This state is shown in the diagram on the top row, second column.

<p>
A different transition from <code>({B}, {R}, [], [])</code> is one in
which <code>V</code> sends the red token. The next state, <code>({B},
{}, [], [R])</code>, is shown in the first column, second row.  

<p style="color:red;">Example: Agent Actions</p>
The action in which agent <code>U</code> receives a message, and adds
the message (a token) to its set of tokens is: 
<pre>
receive msg on channel_VU:
    state = state.add(msg)
</pre>

Agent <code>U</code> also has an internal action in which it sends a token that it
holds. The action is:
<pre>
// if the agent holds a nonempty set of tokens
if len(state) > 0:
   // Identify any token held by this agent.
   token = state.pop()
   // Send token
   send token on channel_UV
   // Remove token from the set that the agent holds.
   state.remove(token)
</pre>

<p style="color:red;">Example of Nondeterministic Actions</p>
In the above example, when agent <code>U</code> holds both red and
blue tokens, the action in which it sends one of the tokens may send
either the red token or the blue token. So the same action results in
one of two possible next states.

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.004.jpeg"
    alt="Fig2" style="width:60%"> 
    <figcaption>Fig.4: Example - Nondeterministic Action</figcaption>
</figure>

The figure shows the two possible transitions in the edges labeled
\(U_{s}\) from the diagram at the extreme left of the figure.

<p style="color:red;">Example: Channel States</p>
In the above figure, the two diagrams on the right-hand side show two
different states for channel <code>channel_UV</code>; the state in the top
diagram is a queue with the blue token ahead of the red token, while
the state in the lower diagram is a queue with the red token ahead of
the blue one.


<!----------------------------------------------------------------->
<h2 class="w3-text-teal">Computations: Paths in State Graphs</h2>

A <i>computation</i> of a system is a state
\(S_{0}\) of the system and a sequence of <i>steps</i> where each step
is a state transition and the \(i\)-th step is \((S_{i-1}, a_{i},
X_{i}, S_{i})\), where \(S_{i-1}\) is the state before the step,
\(S_{i}\) is the state after the step, and the transition is due to
the execution of action \(a_{i}\) at agent \(X_{i}\).
The sequence of steps may be empty, infinite, or finite.

<p>
A computation is specified by a path in the state transition graph.

<p style="color:red;">Example: Computation specified by a path in the
state transition graph</p>
The figure below shows a path \((S_{0}, \ldots S_{8})\) in the state transition graph of the
example system given earlier.
The initial state \(S_{0}\) is depicted in the top left row.
Recall that a system state is a tuple \((S_{U}, S_{V},S_{UV},
S_{VU})\).
State \(S_{0}\) is \((\{b\}, \{r\}, [], [])\).
<p>
The first step in this path is a state transition due to agent \(U\) sending a token.
This step takes the system to the state shown in the top row, second
column. The step is \((S_{0}, s, U, S_{1})\): the state before the
step, the send action, the agent \(U\) that took the action, and the
state after the step.
The next step is \((S_{1}, s, V, S_{2})\).
<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.005.jpeg"
    alt="Fig16" style="width:60%"> 
    <figcaption>Fig.4: Example - Computation is a Path in the State Graph</figcaption>
</figure>
There may be steps from a state back to itself.



<h2 class="w3-text-teal">Rationale for the Model</h2>
This model, based on
<a href="https://en.wikipedia.org/wiki/UNITY_(programming_language)">
UNITY, is simple but adequate for describing many algorithms</a>
used in distributed systems, shared-memory concurrent systems, and sequential
machines.

<p>
The model can be extended to channels other than first-in-first-out
channels as shown next.

<p class="w3-text-teal">Out of order messages</p>
Messages may be delivered out of order in some types of channels,
though each message is delivered once. We represent the state of such
a channel as a multiset of messages. A message is sent by adding the
message to the multiset and a message is delivered by removing the message
from the multiset.

<p class="w3-text-teal">Lossy, multiple delivery channels</p>
In some channels the same message may be delivered repeatedly, and a
message sent later may be received before a message sent earlier.  We
represent the state of such a channel by a set.  A message is sent by
adding it to the set, and a message is delivered by delivering a copy
of any element in the set without modifying the set.

<p class="w3-text-teal">Progress</p>
The model allows for a computation that never executes a given action
even though the computation has an infinite number of steps.
In the example above, there is a computation that starts in \(S_{0}\)
and remains in that state for ever by executing only stuttering
steps.
Later, we extend the model to eliminate the problem of no progress.
We introduce the concept of <i>fairness</i>
where a computation with an infinite number of steps must execute some
actions infinitely often.

<p class="w3-text-teal">No construct for Time</p>
Inexpensive atomic clocks on PC boards, Precision Time
Protocols (PTP) in local area networks, and Network Time Protocol
(NTP) servers, allow processes to have accurate clocks.
Later, we discuss clock synchronization and the use of time in
algorithms. 

<p class="w3-text-teal">Limited Operators on Channels</p>
Libraries such as
<a
href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">
Advanced Message Queuing Protocol</a>
and
<a href="https://aws.amazon.com/sqs/">
Amazon Web Services Simple Queue Service (AWS SQS)
</a>
offer operations on message channels that are not in this model.
For example, RabbitMQ allows
<a href="https://www.rabbitmq.com/maxlength.html">
users to set the maximum length of a channel.</a>
Our model does not have some operators in popular
libraries.
It is, however, adequate for developing algorithms that
are implemented using these libraries.

<h4 class="w3-text-red">
<i>Central Ideas: Review</i></h4>

<p class="w3-text-red">
A state of the system is given by the states of its components -- agents
and communication channels.

A state transition is caused by the execution of an action at an
agent.

A state transition may change the state of the agent that executes the
action, and receive a message on an input channel of the agent, and
send messages on output channels of the agent.

A computation is a sequence of steps where each step is specified by
the states of the system before and after the step, the agent that
executes the action that causes the state transition, and the action.

<p class="w3-text-red">
<i>Concepts</i>:
 Distributed system, agents and channels -> states -> state
transitions. 


<h3 class="w3-text-teal">Next</h3>
Next look at a
<a href="Example.html">simple example of a distributed system</a> or skip it to
read about
<a href="Timelines.html">key concepts -- timelines and cuts of
computations</a> -- which are used in a large number of distributed algorithms.

<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
