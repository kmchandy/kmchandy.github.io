<title>DistributedSystemModels/DistributedSystemModels.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!---------------------------------------------------------------->
    <h2 class="w3-text-teal">A Model of a Distributed System</h2>
<!----------------------------------------------------------------->
  

  
  </p>

  <p class="w3-text-red">
  <i>
  A model is an abstraction that helps in developing algorithms.
  A model of a distributed system is defined by its components,
  states, and state transitions. The components of a distributed
  system are its agents and communication channels.
  </i>
  </p>


<!-------------------------------------------------------------->
<h3 class="w3-text-teal">System Trajectories</h3>
<!-------------------------------------------------------------->

The state of a distributed system is a tuple with an element of the
  tuple for each of its agents and channels.

We analyze distributed systems such as the electrical power grid by
  studying properties of its trajectories --  its states as
  a function of time. 

  Let's look at the trajectory of a system described in the
  <a href="Basics.html">previous page</a>.


<h4 style="color:red;">Example of a Trajectory</h4>
Figure 1 shows a trajectory of a system with two agents \(u\) and
  \(v\) and channels between them.

The horizontal axes represent time flowing from left to right.

There is a timeline for each agent that shows the state of the agent
  at each point in time.

<p>
The state of an agent \(u\) at time \(t\) is represented by a point
  \(t\) units to the right of the origin on \(u\)'s timeline.

A message sent at time \(c\) by an agent \(u\) and received at
  time \(d\) by an agent \(v\) is represented by a line from point
  \(c\) on \(u\)'s timeline to point \(d\) on \(v\)'s timeline.

The state of the system at time \(t\) is shown diagramatically by the
  vertical line at \(t\).

<figure>
    <img
    src="DistributedSystemModels/DistributedSystemModels.011.jpeg"
    alt="Fig1" style="width:100%"> 
    <figcaption>Fig.1: Example: A System Trajectory</figcaption>
</figure>


Next we describe a simple model that is adequate for reasoning about
many algorithms though it cannot represent  trajectories.

We show the relationship between the model and trajectories later on
this page.





<!-------------------------------------------------------------->
<h3 class="w3-text-teal">The Model</h3>
<!-------------------------------------------------------------->

<p>
The model deviates from the distributed system described on the <a
href="Basics.html">previous page</a> in several ways.

The model does not deal with states of an agent while it is executing
a <code>receive</code> command.

The model only represents states of an agent before the agent
begins, and after it completes, executing  a <code>receive</code>.

The model deals only with states in which all agents are idle.


<p>
The model is sequential -- at most one agent executes a
<code>receive</code> at a time while all other agents remain idle.

A state transition occurs when one, and only one, agent receives and
completes processing a message.

<p>
A <i>computation</i> is a sequence of one or more states where there
exists a transition from each state in the sequence to the next state
in the sequence.

We can think of a computation being generated by the following
while loop.
<pre>
while there exists a nonempty channel:
    select any one agent v with a nonempty channel
    execute <code>receive</code> on v
</pre>



<!-------------------------------------------------------------->
<h3 class="w3-text-teal">Events</h3>
<!-------------------------------------------------------------->

The change in state caused by an execution of a <code>receive</code> by
an agent \(v\) is specified by an <i>event</i> which is the 4-tuple:
<ol>
  <li>
  the state of \(v\) before it executes <code>receive</code>,
  </li>
  <li>
  the message received and the channel on which it is received,
  </li>
  <li>
  the state of  \(v\) after it completes execution of the
  <code>receive</code>, and  
  </li>
  <li>
  for each output channel of <code>v</code>, the sequence of messages
  sent on the channel during execution of the <code>receive</code>.
  </li>
</ol>
The states of agents other than \(v\) remain unchanged by the
transition.

The channels other than those listed in the event also remain
unchanged.

<p>
In any system state transition from \(S\) to
\(S'\) specified by an event \(e\), the post-transition state \(S'\)
is uniquely determined by the pre-transition state \(S\) and the event
\(e\). 

<!---------------------------------------------------------------->
<h4 style="color:red;">Example of a Simple Distributed System</h4>
<!---------------------------------------------------------------->

This example system has two agents <code>u</code> and <code>v</code>.

The system has channels in both directions between the agents and also
from each agent to itself.

The system has one blue token and one red token.

Agents send tokens to each other.

A token is either at an agent or in a channel.

Later, when we discuss file management, we will use a token to
represent exclusive access to a file and use the token color to
identify the file. 


<p>
The diagram in figure 2 shows two states, \(S_{0}\) and \(S_{1}\), and
a transition from \(S_{0}\) to \(S_{1}\).

The diagram at the left of the figure shows a system state in
which agent \(u\) holds the blue token, agent \(v\) holds the red
token, channels \((u, v)\) and \((v, u)\) are empty, and channels
\((u, u)\) and \((v, v)\) each contain a wakeup message, shown as a
star.


 
    <figure>
    <img
    src="DistributedSystemModels/DistributedSystemModels.002.jpeg"
    alt="Fig1" style="width:100%"> 
    <figcaption>Fig.2: Example: State Transition</figcaption>
</figure>

<p>
The diagram at the right shows a system state in
which \(u\) holds no tokens, \(v\)  holds the red
token, channel \((u, v)\) has the blue token, channels \((u, u)\) 
and \((v, u)\) are empty, and channel \((v, v)\) contains a wakeup
message.


<p>
The function <code>receive</code> below is self explanatory.

In the code for an agent, <code>other_agent</code> is the other
agent. 


<pre>
def receive(message, sender):
   if sender == other_agent:
       // message is a token
       list_of_tokens_I_hold.append(message)
   else:
       # Sender is me. Message is wakeup.
       # Send any token I hold.
       token_I_hold = tokens_held.pop()
       send(token_I_hold, other_agent)

   # If I hold a token then wake me 1 second later.
   if len(list_of_tokens_I_hold) > 0:
          time.sleep(1)
          send(wakeup, me)
</pre>

<!-------------------------------------------------------------->
<h4 class="w3-text-teal">Time</h4>
<!-------------------------------------------------------------->
The local clocks of agents are not synchronized.

When an agent executes <code>time.sleep(1)</code> the length of time
that it sleeps is unknown.

An agent's clock may be faster or slower than true time.

The length of time that an agent sleeps has no bearing on the
correctness of the algorithm; however, it can impact
performance. 

<p>
An agent may not start processing a message at the instant at which
the message arrives.

Multiple agents may be scheduled on the same resource and the time at
which an agent executes a <code>receive</code> command is unknown.


<!----------------------------------------------------------->
<h4 style="color:red;">Example of an Event</h4>

The event corresponding to the state transition is specified by the
state of \(u\) before the transition (\(u\) holds blue token), the
message <code>wakeup</code> that \(u\) receives on channel \((u, u)\),
the state of \(u\) after the transition (\(u\) holds no tokens), and
the message (blue token) sent by \(u\) along output channel \((u,
v)\).

The figure below illustrates the event.

    <figure>
    <img
    src="DistributedSystemModels/DistributedSystemModels.003.jpeg"
    alt="Fig1" style="width:80%"> 
    <figcaption>Fig.3: Example: Representation of an Event</figcaption>
</figure>


<!----------------------------------------------------------->
<h4 style="color:red;">Example of a State Transition Graph</h4>

The directed graph in which vertices are states and edges represent
state transitions is called the <i>state transition graph.</i>.

A computation is a path in the state transition graph.

A computation may start in any state and be finite or infinite.

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.004.jpeg"
    alt="Fig4" style="width:100%"> 
    <figcaption>Fig.4: Example of State Transitions</figcaption>
</figure>


<p>
Figure 4 shows a part of the state-transition graph for the
token-passing example.

Not all states are shown.

Channels from each agent to itself aren't shown so as to reduce
cluttering.

There is a <i>wakeup</i> message in the channel from an agent to
itself if the agent holds a token.

For example, in the diagram in the top left, there is a wakeup message
from each agent to itself because each agent holds a token.

A state transition in the diagram is labeled with the channel on
which the message is received that caused the transition.


<!----------------------------------------------------------->
<h4 style="color:red;">Example of a Computation</h4>
<!----------------------------------------------------------->

An example of a computation is the sequence \([S_{0}, \ldots S_{8}]\)
of states shown in figure 5 as a path in the state transition graph of
figure 4. 


<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.005.jpeg"
    alt="Fig5" style="width:100%"> 
    <figcaption>Fig.5: Example - A Computation is a Path in the State Graph</figcaption>
</figure>


<!---------------------------------------------------------------->
<h3 class="w3-text-teal">A Computation as an Event Sequence</h3>
<!---------------------------------------------------------------->
<p>
As remarked earlier, in a transition of the system from \(S\) to
\(S'\) caused by an event \(e\), the post-transition state \(S'\) is
uniquely determined \(S\) and \(e\).

A computation is a sequence of states with a transition from each
state to the next.

So, a computation can be specified by an initial state and the
sequence of events that cause transitions from each state to the next.

<p>
We represent the initial state of a computation by an initial event at
each agent.

The label of the agent edge from the initial event at \(u\) is its
initial state, and the output message edges represent the messages in
channels from \(u\) in the initial state. Figure 6 shows an example.

<p>
We will specify computations as sequences of states and also as sequences
of events.



<!---------------------------------------------------------------->
<h3 class="w3-text-teal">Dataflow Graph of a Distributed Computation</h3>
<!---------------------------------------------------------------->
<a href="https://en.wikipedia.org/wiki/Dataflow_programming">
Dataflow graphs
</a>
have been
<a
href="https://www.sigops.org/2020/the-remarkable-utility-of-dataflow-computing/">
used in many domains of computer science
</a>
from the 1960s.

Dataflow graphs, sometimes abbreviated to dataflow, helps in
understanding distributed algorithms.

<p>
Associated with a computation is a labeled, directed, acyclic graph,
called the <i>dataflow graph of the computation.</i>

An edge in a dataflow graph represents data, and a vertex represents a
transformation of data.

In our case vertices represent events of the computation.

Edges connect outputs of events to inputs of events (figure 3).


<p>
The graph has an edge from an event at an agent to the next event at
that agent; this event is labeled with the state of the agent between
the events and is called an agent edge.

The graph has an edge from each event in which a message is sent to
the event in which that message is received; this edge is labeled with
the message, and is called a message edge.

<p>
The initial state of the computation is represented by a set of events
called \(0\), and the final state is represented by a set of events
called \(N\).

The outputs of events numbered \(0\) are the initial states of agents
and message channels, and the inputs of events labeled \(N\) are their
final states.

<p class="w3-text-teal">Representation of a Computation by Dataflow
and an Ordering of Events</p>
A computation is represented by a dataflow graph with later events
placed to the right of earlier events.

Events at the same agent are placed on a horizontal line.

The diagramatic representation of a computation is similar to that of
a trajectory.

<p>
Dataflow graphs do not specify the sequence of events in a
computation.

There may be multiple computations with the same dataflow.


<!---------------------------------------------------------------->
<h4 style="color:red;">Example of a Representation of a
Computation</h4> 
<!---------------------------------------------------------------->
The computation of figure 5 is shown in figure 6 as a dataflow graph with
later events placed to the right of earlier events.

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.006.jpeg"
    alt="Fig6" style="width:100%"> 
    <figcaption>Fig.6: Example - A Computation and its Dataflow</figcaption>
</figure>


The top line in figure 6 shows the timeline -- the sequence of events
-- on agent \(u\) and the lower line shows the timeline for \(v\).

The horizontal black edges show states of agents.

The purple edges show messages.

Event 1 in the figure is the same as the event shown in figure 3.




<!---------------------------------------------------------------->
<h3 class="w3-text-teal">Trajectories and Computations: Commonality</h4>
<!---------------------------------------------------------------->
The dataflow graph of a trajectory is specified in the same way as that
of a system computation.

An event represents the states and messages sent and received during
the execution of a single <code>receive</code> command; the event does
not deal with states of an agent while it is executing the command.

<p>
Making the duration of events in a trajectory arbitrarily small gives
a system computation with the same dataflow as the trajectory.

For every trajectory there exists a system computation that has the same
dataflow as the trajectory.


<!---------------------------------------------------------------->
<h5 style="color:red;">Example of a Trajectory and a Computation</h5>
<!---------------------------------------------------------------->

The top diagram of figure 6 shows a trajectory and the lower
diagram shows a computation with the same dataflow.

The lower diagram can be obtained from the upper diagram by making the
durations of events infinitisimally small.


<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.012.jpeg"
    alt="Fig6" style="width:100%"> 
    <figcaption>Fig.7: Example - Trajectory and Computation with
identical Dataflow
</figcaption>
</figure>



<h3 class="w3-text-teal">Why is the Model Useful?</h3>
The model does not represent trajectories.

The model is sequential -- only one <code>receive</code> is executed
at a time, whereas

multiple agents may execute <code>receive</code> commands concurrently in
a distributed system.

Given its limitations, why is the model useful?


<p>
Agents in a distributed system cannot carry out actions synchronously
because they don't have access to a shared clock.

For example, an agent cannot add a value to a double-entry ledger at
the same instant as another agent subtracts the value.

Agents collaborate by sending messages, and the dataflow tells us
how agents communicate and collaborate.

<p>
What is the most information an agent can get from other agents?

An agent \(A\) can ask every agent to send their agent
computations to \(A\).

The information that \(A\) gets in this way is the dataflow of the
computation .

<i>The dataflow graph is the most information that an agent can
get.</i>




<h3 class="w3-text-teal">Model Limitations</h3>

<!-------------------------------------------------------->
<p class="w3-text-teal">Progress</p>
The model allows for infinite computations in which some agents
repeatedly send messages to each other while other agents
never process messages.

The model allows for messages to be delayed on a channel forever.

Later, we will present a model that does not have these limitations. 


<!-------------------------------------------------------->
<p class="w3-text-teal">No construct for Time</p>
Processes can maintain accurate clocks by using
inexpensive atomic clocks on PC boards, Precision Time
Protocols (PTP) in local area networks, and Network Time Protocol
(NTP) servers.

Later, we discuss the use of time in distributed algorithms.


<!-------------------------------------------------------->
<p class="w3-text-teal">Failure</p>
The model does not deal with failure of agents or channels.

Distributed computing platforms, such as AMQP, have operations to deal
with failure.

Secure systems deal with the possibility of Byzantine failure.

Failure modes are discussed later.





<h3 class="w3-text-teal">Next</h3>
Next look at
<a href="Timelines.html">Computations and Events</a>
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
