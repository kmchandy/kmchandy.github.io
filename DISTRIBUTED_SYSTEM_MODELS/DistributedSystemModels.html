<title>DistributedSystemModels/DistributedSystemModels.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!--------------------------------------------------------->
    <h1 class="w3-text-teal">Models of Distributed Systems</h1>
<!----------------------------------------------------------------->
  
  A model of a system is an abstraction.
  There are many models of distributed systems.
  This section introduces a simple model of distributed systems that
  we use in designing algorithms that ensure that
  systems remain safe --- nothing bad happens.
  Later, we will discuss models that also ensure progress --- goals
  will be achieved eventually.

<p>
A distributed system consists of a set of agents and a set of
message-passing channels.  Each channel has a name and is directed
from one agent to one agent.  A system is represented by a labeled
directed graph in which vertices represent agents and labeled directed
edges represent named channels.


<h3 style="color:red;">Example</h3>
The figure below shows a distributed system with agents A, B, C.

    <figure>
    <img src="DistributedSystemModels.001.jpeg" alt="Fig1" style="width:50%">
    <figcaption>Fig.1: Graph Representation of a Distributed Systems</figcaption>
  </figure>
  An edge labeled \(z\) directed from a vertex \(A\) to
    a vertex \(B\)
represents a channel named \(z\) directed from agent \(A\) to agent \(B\).

A channel  \(z\) from an agent \(A\) to an agent \(B\) is called an
<i>outgoing</i> channel of \(A\) and an <i>incoming</i> channel of
  \(B\);
  only \(A\) can send messages and only \(B\) can receive messages
  along this channel.

  <h2 class="w3-text-teal">Agents</h2>
  Each agent has a set of variables that are <i>local</i> to the agent;
other agents and channels cannot access these variables.
  An agent's state is given by the values of its variables.
<p>
An agent may have a local clock; however, clocks are not
  synchronized across agents. At a point in a trajectory, a clock in
  one agent may be ahead, identical to, or behind the clock of another
  agent. 
  We will discuss clock synchronization later.

<h2 class="w3-text-teal">Channels</h2>
  We will look at systems with different types of channels.
  Let's begin with a model of first-in-first-out (FIFO) channels. 

<h3 class="w3-text-teal">State of a FIFO Channel</h3>
The state of a FIFO channel is a sequence of messages; these are
the messages that have been sent along
that channel and that have not been received.
A channel state can be modified in two ways.
<ol>
  <li>
  <i>Send message</i>: A sender along a channel appends a message to
  the rear of sequence of messages which is the
  channel state.
  </li>
  <li>
  <i>Receive message</i>: A message is removed from the head of the
  non-empty sequence which is the channel state, and this message is
  delivered to the receiver along the channel. A message cannot be
  received from an empty channel.
  </li>
</ol>



<h2 class="w3-text-teal">State Transitions</h2>
The state of a system is given by the states of its agents and
channels. We refer to the state of the entire system as the <i>global
state</i> or <i>system state</i> to distinguish it from the
states of its component agents and channels.
A system state is a tuple with an element for each agent and each
channel.  

<p>
A system state can change in two ways: (1) A message is
delivered from a channel to an agent and the receiver's state changes,
or (2) an agent changes state without receiving messages.

<h3 class="w3-text-teal">State Transition due to Message Delivery</h3>
When a message is delivered the
receiver's state changes, and the receiver may send messages on its
outgoing channels. The states of all agents, other than the receiver,
remain unchanged in the transition.  Likewise, the states of all
channels other than the channel on which the message is delivered and the
receivers's outgoing channels remain unchanged in the transition.

<h3 class="w3-text-teal">State Transition without Message Delivery</h3>
This state transition changes the state of <i>one</i> agent
without messages being delivered. This transition may send
messages on that agent's outgoing channels.
The states of all other channels remain unchanged.
We call such state
transitions <i>internal</i> to the agent 
that changes state. An example of such a transaction is an agent
stepping its local clock forward without receiving messages.

<h3 style="color:red;">Example of State Transitions</h3>
Consider a state \(S\) of the system shown in Fig 1 in which
all channels other than \(x\) and \(y\) are empty.  There are multiple
transitions from \(S\) to other states. An example of a transition from
\(S\) is
  the delivery of the message \(M\) at the head of channel \(x\) to agent
\(B\).

<p>
Let \(S'\) be the state
after a transition from \(S\) due to the delivery of a message in
channel \(x\).
The states of agents \(A, C\) and channels \(u, v, t, z\) are the same
in \(S\) and 
\(S'\).  The state of channel \(x\) in \(S'\) is the same as its state
in \(S\) except that the message at the head of \(x\)'s state in \(S\)
is deleted.  The states of 
channel \(y\) and \(r\) in \(S'\) consists of messages appended to
the rear of their states in \(S\).
<p>
Transitions from \(S\) can be due to:
<ol>
  <li>
  the delivery of the message at the head of channel \(x\) to agent
  \(B\)
  </li>
  <li>
  the delivery of the message at the head of channel \(y\) to agent
  \(C\)
  </li>
  <li>
  a transition of the states any one of agents \(A, B, C\) without
  messages being delivered.
  </li>
</ol>

<p>


<h3 class="w3-text-teal">Specification of State Transitions</h3>
A state transition is specified by:
<ol>
  <li>
  the agent \(A\) that changes state,
  </li>
  <li>
  the states \(s\) and \(s'\) of \(A\) before and after the
  transition,
  </li>
  <li>
  for a message delivery event: 
  the non-empty channel \(c\) on which the message is delivered to \(A\), and the 
message \(m\) at the head of \(c\) which is delivered from \(c\) to \(A\), and 
  </li>
  <li>
  for each outgoing channel \(c'\) of \(A\), the message (if any) sent
  on \(c'\) which is appended to the tail of \(c'\).
  </li>
</ol>  
The states of agents other than \(A\) remain unchanged by the
transition.
Likewise the states of all channels other than \(c\) and \(A\)'s
outgoing channels remain unchanged by the transition.

<p>
A state transition is called an <i>event</i>,
and a transition that changes the state of an agent \(A\) is called
<i>an event at \(A\).</i>


<h3 class="w3-text-teal">Computations</h3>

A <i>computation</i> is a sequence \([S_{0}, S_{1}, S_{2}, \ldots]\) of
system states, where there exists a transition from \(S_{i}\) to
 \(S_{i+1}\) for all \(i\).
The computation can also
be specified by  the initial state \(S_{0}\) and
a sequence of events \([e_{0}, e_{1}, e_{2}, \ldots] \)where
\(e_{i}\) specifies the transition from \(S_{i}\) to \(S_{i+1}\), for
all \(i\).
We call \(S_{i}\) and \(S_{i+1}\) the <i>pre</i> and <i>post</i>
states of event \(e_{i}\).

<h3 style="color:red;">Example of a Computation</h3>
The figure below shows a distributed system with agents <code>A, B</code> and
channels <code>w, x, y, z</code>.
The channel <code>w</code> is from agent <code>A</code> back to
itself.
Likewise, the channel <code>z</code> is from agent <code>B</code> back to
itself.
Channels <code>x, y</code> are (respectively) from <code>A</code> to
<code>B</code>, and from <code>B</code> to <code>A</code>.
<p>
The agents have identical behavior.

    <figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.011.jpeg"
    alt="Fig2" style="width:60%"> 
    <figcaption>Fig.2: Example</figcaption>
</figure>
The state of each agent is given by the value of a single local
Boolean variable, <code>run</code>. Let <code>A.run, B.run</code> be
    the values of <code>run</code> in <code>A, B</code> respectively.

<p>
When an agent receives a message from
itself the agent sets its local variable <code>run</code> to <code>False</code>.
For example, when <code>A</code> receives a message along channel
<code>w</code>, the agent sets
<code>A.run = False</code>.

<p>
When an agent receives a message from the other agent, the receiver
sends the same message back to the sender if the receiver's local
variable <code>run</code> is <code>True</code>, and takes
no action otherwise.
For example, when <code>A</code> receives a message along channel
<code>y</code> when <code>A.run = True</code> then <code>A</code>
sends the same message along channel <code>x</code>.
When <code>A</code> receives a message while <code>A.run = False</code>
it takes no action.
<p>
Next, we describe the events at agent <code>A</code>; the
events at <code>B</code> follow by symmetry.

<h4 style="color:red;">Example Events</h4>
<p style="color:red;">Event 0</p>
When an agent receives a message from itself it sets <code>run</code>
to <code>False</code>.
<p>
Let <code>run', w'</code> be the values of
<code>run, w</code>, respectively, before the event.
The event delivers a message on channel <code>w</code>, and so
<code>w'</code> must be nonempty.
This event occurs independent of the value of <code>run</code> before
the event.

<pre>
For all nonempty sequences w' and all boolean values run'
pre:  run = run',   w = w'
post: run = False,  w = tail(w')
</pre>


<h5 style="color:red;">Event 1</h5>
When an agent with <code>run = True</code>, receives a message from
the other agent it sends the message back to the other agent.

<pre>
For all nonempty sequences y' and all sequences x'
pre:  run = True,  y = y',        x = x'
post: run = True,  y = tail(y'),  x = x' + head(y')
</pre>

<h5 style="color:red;">Event 2</h5>
When an agent with <code>run = False</code>, receives a message from
the other agent it takes no action.

<pre>
For all nonempty sequences y' and all sequences x'
pre:  run = False,   y = y',        x = x'
post: run = False,   y = tail(y'),  x = x'
</pre>

<h4 style="color:red;">Example Computations</h4>
Actions of agents in this simple example
do not depend on the contents of messages.
So, the state of a channel can be represented by the number of
messages in the channel rather than the sequence of messages in the
channel. 
<p>
Let \(e_{0,A}, e_{1,A}, e_{2,A}\) be Event 0, 1, 2 (respectively)
executed at agent <code>A</code>. Likewise, 
let \(e_{0,B}, e_{1,B}, e_{2,B}\) be Event 0, 1, 2 (respectively)
executed at agent <code>B</code>.
<p>
Consider computations that start in a state \(S_{0}\) in which <code>run</code>
is <code>True</code> for both agents, and where there is one message
in each channel. The states of agents and channels are as follows:
<p>
<code>[A, B, w, x, y, z]: [T, T, 1, 1, 1, 1]</code>
<p>
There are many transitions from \(S_{0}\). Events 0 or 1 could be executed
on either agent. Event 2 cannot be executed in \(S_{0}\) because the
precondition for the event is not satisfied in \(S_{0}\).

<p>
If Event 1 is executed at agent <code>A</code> in this state then the
event removes a message from channel <code>y</code> and adds that
message to channel <code>x</code>. So, the
next state is:
<p>
<code>[A, B, w, x, y, z]: [T, T, 1, 2, 0, 1]</code>.
<p>
An example computation is \(S_{0}, [e_{1,A}, e_{1,B}, e_{0,A},
e_{2,A}]\).
The intermediate states in the computation are shown below.
<p>
<code>[T, T, 1, 1, 1, 1]</code>
<br>
\(\stackrel{e_{1,A}} {\longrightarrow}\)
<br>
<code>[T, T, 1, 2, 0, 1]</code>
<br>
\(\stackrel{e_{1,B}} {\longrightarrow}\)
<br>
<code>[T, T, 1, 1, 1, 1]</code>
<br>
\(\stackrel{e_{0,A}} {\longrightarrow}\)
<br>
<code>[F, T, 0, 1, 1, 1]</code>
<br>
\(\stackrel{e_{2,A}} {\longrightarrow}\)
<br>
<code>[F, T, 0, 1, 0, 1]</code>
<p>
An example of a state and event sequence that is <i>not a
computation</i> is \(S_{0}, [e_{1,A}, e_{2,A}]\).
<code>A.run = True</code> in the state after event \(e_{1,A}\)
is executed in the above computation
But, Event 2 can be executed at agent <code>A</code> only when <code>A.run
= False</code>.

<h3 class="w3-text-teal">Different Types of Channels</h3>
Most of the algorithms in these notes use FIFO channels; however, we
also describe algorithms that use other types of channels. Models for
a couple of them are described next.

<p class="w3-text-teal">Out of order messages</p>
Messages may be delivered out of order in some types of channels,
though each message is delivered once. We represent the state of such
a channel as a bag or multiset. A message is sent by adding the
message to the bag and a message is delivered by removing the message
from the bag.

<p class="w3-text-teal">Lossy, multiple delivery channels</p>
In some channels the same message may be delivered repeatedly, and a
message sent later may be received before a message sent earlier.  We
represent the state of such a channel by a set.  A message is sent by
adding it to the set, and a message is delivered by delivering a copy
of any element in the set without modifying the set.



<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
