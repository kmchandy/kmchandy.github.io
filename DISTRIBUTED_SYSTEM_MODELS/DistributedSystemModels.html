<title>DistributedSystemModels/DistributedSystemModels.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!--------------------------------------------------------->
    <h1 class="w3-text-teal">Models of Distributed Systems</h1>
<!----------------------------------------------------------------->
  <h5 class="w3-text-red">
  <i>Central Ideas</i></h5>
  <p class="w3-text-red">
  A model of distributed systems based on
  <a
  href="https://en.wikipedia.org/wiki/UNITY_(programming_language)">UNITY
  </a>
  which is a restricted version of
  <a
  href="https://lamport.azurewebsites.net/pubs/lamport-actions.pdf">
  action systems.
  </a>
  

  
  </p>

  <p class="w3-text-red">
  <i>
  A model is an abstraction that helps in developing algorithms.
  A model of a distributed system is defined by its components,
  states, and state transitions. The components of a distributed
  system are its agents and communication channels.
  </i>
  </p>

  <h2 class="w3-text-teal">Distributed System: Agents and Channels</h2>
  We use a simple model that hides implementation details to develop
  algorithms that are implemented on platforms such as
  <a href="https://en.wikipedia.org/wiki/Message_queue">Message Queue (MQ)</a> and
  <a href="https://aws.amazon.com/sqs/">AWS Simple Queue Service
  (SQS)</a>.

  <p>
  A distributed system consists of a set of agents and a set of
  communication channels.
  Agents communicate with other agents only by
  sending and receiving messages along channels.
  Each channel has a name and is directed from one agent to one agent.

  <p>
  The state of an agent is given by the agent's variables including
  its program counters. An agent cannot access another agent's state,
  and an agent cannot access the states of channels.

<p>  
  Agents and channels are represented by a labeled directed graph,
  called the <i>agent graph</i> in which vertices represent agents and
  labeled directed edges represent named channels.  A channel from an
  agent \(A\) to an agent \(B\) is an <i>output</i> channel of \(A\)
  and an <i>input</i> channel \(B\). An agent can send messages on its
  output channels and receive messages on its input channels.  We
  assume that the agent graph is given; the model doesn't specify how
  the graph is created or how an agent graph can be modified.

  
  <h4 style="color:red;">Example: Agent Graph</h4>
  The figure below shows connections in a system with agents \(A, B,
C\).  Examples of channels are \(t\) and \(x\) directed from agent
\(C\) to agent \(B\); they are outputs of \(C\) and inputs of \(B\).

    <figure>
    <img src="DistributedSystemModels.001.jpeg" alt="Fig1" style="width:50%">
    <figcaption>Fig.1: Graph Representation of a Distributed Systems</figcaption>
  </figure>
 

  <h2 class="w3-text-teal">Agent and Channel State Transitions</h2>
The state of a distributed system is given by the states of its agents and
  channels. The system state is a tuple with an element of the tuple
for each agent and each channel.

<h4 class="w3-text-teal">Channel State Transitions</h4>
The state of a channel is a queue of messages.
When an agent sends a message along a channel, the message is appended
to the tail of the queue.  When an agent receives a message from a
nonempty channel then the message at the head of the queue is deleted and
is passed to the agent. 

<h4 class="w3-text-teal">Agent State Transitions</h4>
An agent is specified by sets of: states, actions, messages that the agent
receives, and messages that the agent sends.
Executing an agent's action causes a state transition of the
agent and may also send messages and receive a message.
An action in which an agent receives a message is called
<i>message-driven</i>, and an action in which no message is received
is called <i>internally-driven</i>

<h5 class="w3-text-teal">Message-Driven Actions</h5>
For each input channel of each agent, there is an action of the
agent that receives the message at the head of the
channel.
The action is specified by the channel on which the message is
received, the message (if any) that is received -- i.e., the message at the head
of a nonempty channel -- the states of the agent before and after the
execution of the action, and for each output channel, the message (if
any) sent on the channel.

<p>
If the channel on which a message is received is empty then the action
leaves states unchanged.

If the channel is nonempty then: the message at the head of the
channel is removed from the channel and assigned to one of the
receiver's variables, and the receiver executes a program that
may modify its variables and append messages to its output channels.


<p style="color:red;">Example: Action -- Receive a Message</p>
In this example, the agent has input channel <code>channel_y</code>,
output channel <code>channel_x</code>, and variables <code>msg</code>,
<code>sum</code> and <code>alert</code>.
<pre>
receive msg on channel_y:
   sum = sum + msg
   if sum < 0:
      send alert on channel_x
</pre>
If <code>channel_y</code> is empty, the execution of this action
leaves the state unchanged.
If <code>channel_y</code> is a nonempty queue, then <code>msg</code>
is assigned the value of the element at the head of the queue;
the head of the queue is removed from the queue;
and the agent executes the statements in the block.


<h5 class="w3-text-teal">Notation for Communicating Messages</h5>
The notation for receiving a message on a channel
<code>channel_c</code>, and its Python equivalent, with
<code>channel_c</code> as a queue, are:
<pre>
receive msg on channel_c:
   // process msg

// Equivalent with channel_c as a queue
if not channel_c.empty():
   msg = channel_c.get()
   // process msg
</pre>
The notation for sending a message <code>msg</code> on a channel
<code>channel_c</code>, and its equivalent, with
<code>channel_c</code> as a queue, are:
<pre>
send msg on channel_c

// Equivalent with channel_c as a queue
channel_c.put(msg)
</pre>

<h5 class="w3-text-teal">Internally-Driven Actions</h5>
An internally-driven action may modify the agent's variables and send
messages, and does not receive messages.

<p style="color:red;">Example: Internally-Driven Action</p>
An agent has variables <code>holding_file</code> and
<code>the_file</code>, and an output channel <code>channel_x</code>. 
<pre>
if holding_file:
   send the_file on channel_x
   holding_file = False
</pre>
If <code>holding_file</code> is False when this action is executed
then the action leaves the system state unchanged.



<h2 class="w3-text-teal">System States and Transitions</h2>
The state of a distributed system is a tuple with an element of the
tuple for each agent and each channel.

<p>
The execution of an action at an agent causes a state transition.
The action may change the agents' variables, send messages on its output
channels, and receive a message on one of the agent's input channels.
The states of all other agents and channels remains unchanged.
A transition may be from from a state back to itself.


<p>
A state transition is specified by \((S, a, X, S')\) where \(S\) and
\(S'\) are the states before and after the transition (respectively) caused by
execution of action \(a\) of agent \(X\).

<p>
Any action of any agent may be executed in any state.
So, for all states \(S\) and all actions \(a\) of all agents \(X\) there
is <i>at least one</i> transition \((S, a, X, S')\).
If a system has state transitions \((S, a, X, S')\) and \((S,
a, X, S'')\) then execution of action \(a\) of agent \(X\) in state
\(S\) may result in a next state that is \(S'\) or \(S''\).



<p class="w3-text-teal">Stuttering</p>
In addition to agent actions, the system has an action called an empty
action or a stutter that takes the system from each state back to the
same state.
A system can remain in the same state for an arbitrary number of state
transitions by executing the empty action repeatedly.
We will see later why this model is helpful.

<h3 class="w3-text-teal">The State-Transition Graph</h3>
The states and transitions of a system are represented by a directed
multigraph, called the <i>state-transition graph</i> in which each vertex
represents a state and each labeled edge represents the execution of
an action.
For each vertex \(S\) and each action \(a\) of an agent there is at
least one edge from \(S\) labeled \(a\).
The edge may be from a vertex back to itself.

<p style="color:red;">Example of a State-Transition Graph</p>
The figure below shows a state-transition graph with edge labels R, B,
G.
The edges corresponding to these labels are colored red, blue, and
green.
Each label represents an action of an agent.
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.013.jpeg"
    alt="Fig2" style="width:75%"> 
    <figcaption>Fig.2: Example</figcaption>
</figure>
The transitions from each state back to itself due to stuttering are
not shown. 


<h4 style="color:red;">Example: A Simple Distributed System</h4>
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.014.jpeg"
    alt="Fig2" style="width:100%"> 
    <figcaption>Fig.3: Example</figcaption>
</figure>
This system has two agents <code>U, V</code> and channels
<code>channel_UV</code>, <code>channel_VU</code> from <code>U</code>
to <code>V</code>, and from <code>V</code> to <code>U</code>,
respectively. 
The system has one blue token and one red token.
Later, when we discuss file management, we will use a token to represent exclusive
access to a file, and use the token color to identify the file.

<p style="color:red;">Example: States and Transitions</p>
A state \(S\) of the system is a tuple, \((S_{U}, S_{V},S_{UV},
S_{VU})\), where the elements of the tuple are the states of agent
<code>U</code>, agent <code>V</code>, channel <code>channel_UV</code>
and <code>channel_VU</code>, respectively.
The state of an agent is the set of tokens that it holds.
The state of a channel is a queue of tokens.

<p>
The figure shows some of the states and transitions of the system. All
the states are not shown.
<p>
The diagram on the top left of the figure depicts a system state in
which <code>U</code> holds the blue token, 
<code>V</code> holds the red token, and both channels are empty.
This state is <code>({B}, {R}, [], [])</code>.
<p>
There is a transition from this state in which <code>U</code> sends
the blue token. This transition is labeled \(U_{s}\) because
<code>U</code> <i>s</i>ends a token, and the transition is shown as a
blue arrow because the transition moves a blue token.

<p>
In the state after the transition, the blue token is in
<code>channel_UV</code>, and <code>U</code> holds no tokens.
The next state is <code>({}, {R}, [B], [])</code>.
This state is shown in the diagram on the top row, second column.

<p>
A different transition from <code>({B}, {R}, [], [])</code> is one in
which <code>V</code> sends the red token. The next state, <code>({B},
{}, [], [R])</code>, is shown in the first column, second row.  

<p style="color:red;">Example: Agent Actions</p>
The action in which agent <code>U</code> receives a message, and adds
the message (a token) to its set of tokens is: 
<pre>
receive msg on channel_VU:
    state = state.add(msg)
</pre>

Agent <code>U</code> also has an internal action in which it sends a token that it
holds. The action is:
<pre>
// if the agent holds a nonempty set of tokens
if len(state) > 0:
   // Identify any token held by this agent.
   token = state.pop()
   // Send token
   send token on channel_UV
   // Remove token from the set that the agent holds.
   state.remove(token)
</pre>

<p style="color:red;">Example of Nondeterministic Actions</p>
In the above example, when agent <code>U</code> holds both red and
blue tokens, the action in which it sends one of the tokens may send
either the red token or the blue token. So the same action results in
one of two possible next states.

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.015.jpeg"
    alt="Fig2" style="width:60%"> 
    <figcaption>Fig.4: Example - Nondeterministic Action</figcaption>
</figure>

The figure shows the two possible transitions in the edges labeled
\(U_{s}\) from the diagram at the extreme left of the figure.

<p style="color:red;">Example: Channel States</p>
In the above figure, the two diagrams on the right-hand side show two
different states for channel <code>channel_UV</code>; the state in the top
diagram is a queue with the blue token ahead of the red token, while
the state in the lower diagram is a queue with the red token ahead of
the blue one.


<!----------------------------------------------------------------->
<h2 class="w3-text-teal">Computations: Paths in State Graphs</h2>

A <i>computation</i> of a system is a state
\(S_{0}\) of the system and a sequence of <i>steps</i> where each step
is a state transition and the \(i\)-th step is \((S_{i-1}, a_{i},
X_{i}, S_{i})\), where \(S_{i-1}\) is the state before the step,
\(S_{i}\) is the state after the step, and the transition is due to
the execution of action \(a_{i}\) at agent \(X_{i}\).
The sequence of steps may be empty, infinite, or finite.

<p>
A computation is specified by a path in the state transition graph.

<p style="color:red;">Example: Computation specified by a path in the
state transition graph</p>
The figure below shows a path \((S_{0}, \ldots S_{8})\) in the state transition graph of the
example system given earlier.
The initial state \(S_{0}\) is depicted in the top left row.
Recall that a system state is a tuple \((S_{U}, S_{V},S_{UV},
S_{VU})\).
State \(S_{0}\) is \((\{b\}, \{r\}, [], [])\).
<p>
The first step in this path is a state transition due to agent \(U\) sending a token.
This step takes the system to the state shown in the top row, second
column. The step is \((S_{0}, s, U, S_{1})\): the state before the
step, the send action, the agent \(U\) that took the action, and the
state after the step.
The next step is \((S_{1}, s, V, S_{2})\).
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.016.jpeg"
    alt="Fig16" style="width:60%"> 
    <figcaption>Fig.4: Example - Computation is a Path in the State Graph</figcaption>
</figure>
There may be steps from a state back to itself.



<h2 class="w3-text-teal">Rationale for the Model</h2>
This model, based on
<a href="https://en.wikipedia.org/wiki/UNITY_(programming_language)">
UNITY, is simple but adequate for describing many algorithms</a>
used in distributed systems, shared-memory concurrent systems, and sequential
machines.

<p>
The model can be extended to channels other than first-in-first-out
channels as shown next.

<p class="w3-text-teal">Out of order messages</p>
Messages may be delivered out of order in some types of channels,
though each message is delivered once. We represent the state of such
a channel as a multiset of messages. A message is sent by adding the
message to the multiset and a message is delivered by removing the message
from the multiset.

<p class="w3-text-teal">Lossy, multiple delivery channels</p>
In some channels the same message may be delivered repeatedly, and a
message sent later may be received before a message sent earlier.  We
represent the state of such a channel by a set.  A message is sent by
adding it to the set, and a message is delivered by delivering a copy
of any element in the set without modifying the set.

<p class="w3-text-teal">Progress</p>
The model allows for a computation that never executes a given action
even though the computation has an infinite number of steps.
In the example above, there is a computation that starts in \(S_{0}\)
and remains in that state for ever by executing only stuttering
steps.
Later, we extend the model to eliminate the problem of no progress.
We introduce the concept of <i>fairness</i>
where a computation with an infinite number of steps must execute some
actions infinitely often.

<p class="w3-text-teal">No construct for Time</p>
Inexpensive atomic clocks on PC boards, Precision Time
Protocols (PTP) in local area networks, and Network Time Protocol
(NTP) servers, allow processes to have accurate clocks.
Later, we discuss clock synchronization and the use of time in
algorithms. 

<p class="w3-text-teal">Limited Operators on Channels</p>
Libraries such as
<a
href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">
Advanced Message Queuing Protocol</a>
and
<a href="https://aws.amazon.com/sqs/">
Amazon Web Services Simple Queue Service (AWS SQS)
</a>
offer operations on message channels that are not in this model.
For example, RabbitMQ allows
<a href="https://www.rabbitmq.com/maxlength.html">
users to set the maximum length of a channel.</a>
Our model does not have some operators in popular
libraries.
It is, however, adequate for developing algorithms that
are implemented using these libraries.

<h4 class="w3-text-red">
<i>Central Ideas: Review</i></h4>

<p class="w3-text-red">
A state of the system is given by the states of its components -- agents
and communication channels.

A state transition is caused by the execution of an action at an
agent.

A state transition may change the state of the agent that executes the
action, and receive a message on an input channel of the agent, and
send messages on output channels of the agent.

A computation is a sequence of steps where each step is specified by
the states of the system before and after the step, the agent that
executes the action that causes the state transition, and the action.

<p class="w3-text-red">
<i>Concepts</i>:
 Distributed system, agents and channels -> states -> state
transitions. 


<h3 class="w3-text-teal">Next</h3>
Next look at a
<a href="Example.html">simple example of a distributed system</a> or skip it to
read about
<a href="Timelines.html">key concepts -- timelines and cuts of
computations</a> -- which are used in a large number of distributed algorithms.

<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
