<title>DistributedSystemModels/DistributedSystemModels.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!--------------------------------------------------------->
    <h1 class="w3-text-teal">Models of Distributed Systems</h1>
<!----------------------------------------------------------------->
  <h5 class="w3-text-red">
  <i>Central Ideas</i></h5>
  <p class="w3-text-red">
  A model of distributed systems based on
  <a
  href="https://en.wikipedia.org/wiki/UNITY_(programming_language)">UNITY
  </a>
  which is a restricted version of
  <a
  href="https://lamport.azurewebsites.net/pubs/lamport-actions.pdf">
  action systems.
  </a>
  

  
  </p>

  <p class="w3-text-red">
  <i>
  A model is an abstraction that helps in developing algorithms.
  A model of a distributed system is defined by its components,
  states, and state transitions. The components of a distributed
  system are its agents and communication channels.
  </i>
  </p>

  <h2 class="w3-text-teal">Distributed System: Agents and Channels</h2>
  We use a simple model to develop algorithms. We implement
  algorithms using libraries such as
  <a href="https://en.wikipedia.org/wiki/Message_queue">Message Queue (MQ)</a> and
  <a href="https://aws.amazon.com/sqs/">AWS Simple Queue Service
  (SQS)</a>.
  These libraries are implemented on top of protocols such as
  <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>,
  <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>, and
  <a
  href="https://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a>.
  These platforms allow operations that are more powerful than allowed
  in our model; however, the model is adequate to describe most
  distributed algorithms.

  <p>
  A distributed system consists of a set of agents and a set of channels.
  Agents send and receive messages on channels.
  Each channel is directed from one agent to one agent.
  A system is represented by a directed graph in which vertices
  represent agents and directed edges represent channels.
  
  
  <h4 style="color:red;">Example: Agent-Channel Graph</h4>
  The figure below shows an agent-channel graph with agents \(A, B,
C\).

    <figure>
    <img src="DistributedSystemModels/DistributedSystemModels.001.jpeg" alt="Fig1" style="width:30%">
    <figcaption>Fig.1: Example: An Agent Graph</figcaption>
</figure>


<p>
A distributed system is initiated with a set of agents and channels, and these
sets remain unchanged.
Agents and channels are not created or deleted.


<p>
A channel is an ordered pair <code>(P, Q)</code> where <code>P</code>
  and <code>Q</code> are agents; this channel is an output of
  <code>P</code> and an input of <code>Q</code>.
An agent can send messages on its output channels and
  receive messages on its input channels.




<h4 class="w3-text-teal">Message Communication</h4>

The state of a channel is the sequence of messages in the channel --
these are the messages that have been sent but not received on the
channel.  A message that is sent is appended to the tail of the
sequence, and a message that is received is removed from the head of
the sequence.

<p>
Message delays are unknown and arbitrary.
Messages are not delivered instantaneously.
The model allows for the possibility that a message delay may be
infinite -- a message may never be delivered.
Later we introduce the temporal logic concept of <i>eventually</i> and
consider channels in which messages are delivered eventually.


<h4 class="w3-text-teal">Agents</h4>
Each agent executes an infinite loop in which the agent waits to receive a
message from any channel, and processes the message that arrives.
An agent is either waiting for a message or processing a message.
An agent is said to be <i>active</i> while it is processing a message,
and is said to be <i>idle</i> while it is waiting for a message.

An idle agent becomes active when it receives a message.
An active agent becomes idle after processing each message.

<p>
When a message arrives at an agent, if the agent is idle, then the
agent executes a function
<pre>
receive(message, sender)
</pre>
where
the first parameter is the message that arrived,
and the second paramenter is the agent that sent the message.
This message is removed from the channel.
When the agent finishes processing the message then it becomes idle.

<p>
If a message arrives at an agent while the agent is active then the
message is enqueued at the agent.
Enqueued messages are considered to be still in the channel.
When an agent finishes processing a message it becomes idle.
If there are 
enqueued messages for an idle agent, then the <code>receive</code>
method of the agent is called and passed the next enqueued message.


<p>
We use the following notation for sending a mesage
<pre>
send(message, receiver)
</pre>
The first parameter of <code>send</code> is the message that is sent,
and the second paramenter is the agent to which the message is sent.
A message can be sent on a channel independent of the state of the
channel.
We assume that channels have buffers of infinite size; however
for each algorithm we will prove that channels have bounded numbers of
messages.

<h4 style="color:red;">Example of an Agent</h4>
This is an example of <code>pos</code>  for an agent that receives messages from agents
<code>pos</code> and <code>neg</code>,
and that sends messages to agent <code>results</code>.
<pre>
def receive(message, sender):
   if sender == pos:
       sum = sum + m
   else:
       sum = sum - m
   send(sum, results)
</pre>

<h4 class="w3-text-teal">Restriction on receive</h4>
Each agent has its own <code>receive</code> function which is local to
that agent, and can only access that agent's variables, and can send
messages only on that agent's output channels.

<p>
A <code>receive</code> function does not call itself, and
every execution of <code>receive</code> must terminate.
The implementation of <code>receive</code> is arbitrary provided it
satisfies these restrictions.
For example,
<code>receive</code> can be implemented as a concurrent program.



<h2 class="w3-text-teal">System States and Transitions</h2>

<p>
We want to study distributed algorithms independent of the
implementation of <code>receive</code>.
So we restrict attention to the states of idle agents.
A state transition for an agent is a transition from a state in which
it is idle to the state in which it is next idle again after
processing a message.
We ignore intermediate states that occur while an agent is active
because these intermediate states are independent
of the rest of the system.

<h4 class="w3-text-teal">An Agent Action</h4>
An <i>action</i> of an agent is the process of receiving and
processing a single message by that agent.
An action of an agent <code>X</code> is specified by the inputs and
outputs of the action:
<p>
<i>Inputs to an action</i>
<ol>
  <li>
  <code>X</code>'s state <code>S</code> while it is idle, before it receives the message.
  </li>
  <li>
  The channel <code>c</code> on which the message is received and the
  message <code>m</code> that is
  received. 
  </li>
</ol>

<i>Outputs of the action</i>
<ol>
  <li>
  For each output channel of <code>X</code>, the sequence of messages
  sent on the channel while <code>m</code> is being processed.
  </li>
  <li>
  <code>X</code>'s state <code>S'</code>when it completes processing
  <code>m</code>, and becomes idle again.
  </li>
</ol>




<h4 style="color:red;">Example of an Agent's Action</h4>
In the above example, 
and assume that when the agent is idle, before receiving a message
<code>8</code> from <code>pos</code>, the
values of the agent's variables are: <code>a = neg, msg = 2, sum =
4</code>.
Then, the action executed by agent is specified as
follows.
<p>
Inputs to the action:
<ol>
  <li>
  Agent state while idle before receiving message: <code>a = neg, m = 2, sum = 4</code>.
  </li>
  <li>
  Message received from agent <code>pos</code>, message <code>8</code>
  </li>
</ol>
Outputs of the action:
<ol>
  <li>
  Sent to agent <code>results</code>, messages: <code>12</code>
  </li>
  <li>
  Agent state while idle after processing message: <code>a = pos, m = 8, sum = 12</code>.
  </li>
</ol>



<h4 style="color:red;">Example: State Transitions</h4>
This example system has two agents <code>u</code> and <code>v</code>.
The system has channels in both directions between the agents.
There are also channels from each agent to itself.
The system has one blue token and one red token.
A token is at an agent or is in a channel.
(Later, when we discuss file management, we will use a token to represent exclusive
access to a file, and use the token color to identify the file.)


<p>
The diagram below shows states and transitions.
The diagram at the top left of the figure shows a system state in
which agent \(u\) holds the blue token, agent \(v\) holds the red
token, and all channels are empty.
The diagram in the top row, middle column, shows a system state in
which \(u\) holds no tokens, \(v\)  holds the red
token, channel \((u, v)\) has the blue token, and
channel \((v, u)\) is empty.

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.003.jpeg"
    alt="Fig3" style="width:60%"> 
    <figcaption>Fig.3: Example of State Transitions</figcaption>
</figure>

<p>
Channels from each agent to itself aren't shown so as to reduce
cluttering.
Each agent sends a <i>wakeup</i> message to
itself if the agent holds a token. When an agent gets a wakeup
message it sends a token that it holds to the other agent.
For example, in the diagram in the top left, there is a wakeup message from each
agent to itself because each agent holds a token.


<p>
Each state transition in the diagram is labeled with the channel on
which the message is received that caused the transition.
For example, the transition from the state in the top-left to the
state to its right is labeled \((u, u)\) because this transition takes
place when \(u\) gets a message from itself.

<p>
The function <code>receive</code> below is self explanatory.
It is written to be easy to read rather than for efficiency.
Assume that in the code for agent \(u\), <code>other_agent</code> is
\(v\).
Likewise, in the code for agent \(v\), <code>other_agent</code> is
\(u\).
We postpone discussion of the notation for creating the system.

<pre>
def receive(message, sender):
   if sender == other_agent:
       list_of_tokens_I_hold.append(message)
   else:
       # sender is me; so send any token I hold
       token_I_hold = tokens_held.pop()
       send(token_I_hold, other_agent)

   # I hold tokens, so wake me up later.
   if len(list_of_tokens_I_hold) > 0:
          send(wakeup, me)
</pre>



<h4 class="w3-text-teal">Computation</h4>
A computation is a sequence of system states \([S_{0}, S_{1}, S_{2},
\ldots]\) where there exists a transition from \(S_{i-1}\) to
\(S_{i}\) for all \(i > 0\).
A computation may be finite or infinite.
A computation may start in any state.

<p>
The directed graph in which vertices are states and edges represent
state transitions is called the state transition graph.
A computation is a path in the state transition graph.


<h4 style="color:red;">Example: Computation specified by a path in the
state transition graph</h4>
The figure below shows a path \((S_{0}, \ldots S_{8})\) in the state transition graph of the
example system given earlier.
<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.005.jpeg"
    alt="Fig16" style="width:60%"> 
    <figcaption>Fig.4: Example - Computation is a Path in the State Graph</figcaption>
</figure>


<h3 class="w3-text-teal">Model Limitations</h3>

<p class="w3-text-teal">Progress</p>
The model allows for an infinite computation in which an agent forever
processes messages that it sends itself, while other agents starve.
The model also allows for messages to be delayed on a channel forever.
Later, we extend the model to include the temporal logic concepts of
<i>eventually</i> and <i>fairness</i> and prove that computations progress
towards a goal.

<p class="w3-text-teal">No construct for Time</p>
Processes can maintain accurate clocks by using
inexpensive atomic clocks on PC boards, Precision Time
Protocols (PTP) in local area networks, and Network Time Protocol
(NTP) servers.
The absence of time is a limitation of the model.
We will discuss the use of time in
algorithms.


<p class="w3-text-teal">Channel types</p>
The model can be extended to communication mechanisms other than first-in-first-out
channels.
The model is easily extended to the case of more than one channel from an
agent to an agent.
Later, we will describe algorithms in which messages may be lost and in which
messages may be delivered out of order.

<p class="w3-text-teal">Failure</p>
The model does not deal with failure of agents or channels.
Dealing with failure is essential in distributed systems.
We discuss failure modes later.

<h4 class="w3-text-red">
<i>Central Ideas: Review</i></h4>

<p class="w3-text-red">
A state of the system is given by the states of its components -- agents
and communication channels.

An agent is either idle (waiting to process a message) or active (processing a
message).

An active agent becomes idle.

We restrict attention to an agent's state when it is idle.

A state transition is from a state in which an agent is idle to
the next state in which that agent is idle, after processing a single message.

A state transition changes the state of the agent that receives a
message; messages may be sent on the agent's output channels
during the transition.

A computation is a sequence of states where there is a transition from
each state to the next.

<p class="w3-text-red">
<i>Concepts</i>:
 Distributed system, agents and channels -> states -> state
transitions. 


<h3 class="w3-text-teal">Next</h3>
Next look at
<a href="Timelines.html">Timelines of Computations.</a>
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
