<title>DistributedSystemModels/Models.html</title>
<title>DistributedSystemModels/Model.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

<!-------------------------------------------------------------->
<h2 class="w3-text-teal">Data Flow in Computations</h2>
<!-------------------------------------------------------------->
  <p class="w3-text-red">
  A dataflow graph of a computation is a labeled directed acyclic
  graph that shows the flow of data between agents during the
  computation. 
  All <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sorts</a> of a dataflow graph are computations.
  </p>
 



  <!----------------------------------------------->
  <h3 class="w3-text-teal">The Dataflow Graph of a Computation</h3>
  <!----------------------------------------------->
  <p>
<a href="https://en.wikipedia.org/wiki/Dataflow_programming">Data flow</a>
  is a concept that has been used in computer science for over 50
  years. 
  Next we show how data flow helps in developing distributed
  algorithms.
  </p>

  
<!--------------START SECTION: Dataflow ---------------------->
<div ID="SECTION", class="Dataflow">
<a name="Dataflow"></a>
    <p>
    <!--------START SECTION: Dataflow Definition ----------------->
  <div ID="SECTION", class="DataflowDefinition">
    <a name="DataflowDefinition"></a>
    
    <p>
    A computation \([S_{0}, S_{1}, \ldots, S_{n}]\) from a state
      \(S_{0}\) can be specified by \(S_{0}\) and a sequence \([e_{0},
      e_{1}, \ldots, ]\) where \(e_{i}\) is an event at an agent that
    causes a transition from \(S_{i}\) to \(S_{i+1}\).
    A dataflow graph of the computation is a labeled, directed, acyclic
    graph. The vertices of the graph are the steps \(e_{i}\).
    In addition, state \(S_{0}\)  is represented by a vertex for each
    agent <code>u</code> which specifies <code>u</code>'s
    state in \(S_{0}\). Likewise, state \(S_{n}\)  is represented by a vertex for each
    agent <code>u</code> which specifies <code>u</code>'s
    state in \(S_{n}\).


    <p>
    The edges of the dataflow graph of a computation are as follows.
    There is an edge from (the vertex representing) a step in which a
    message is sent to the step in which that message is received; the
    edge is labeled with the message.
    There is an edge from a step at an agent to the next step at that
    agent, and the edge is labeled with the state of the agent between the
    steps.

    <p>
    The vertex representing the state of an agent <code>u</code>
    in \(S_{0}\) has an output edge labeled with the state of
    <code>u</code> in \(S_{0}\) and an output edge labeled
    <code>m</code> for each message <code>m</code> which is in a
    channel <code>(u, v)</code> in state \(S_{0}\).
    State \(S_{n}\) is represented in a symmetric fashion.


<!---------------START SECTION: Example ------------------------------>
  <div ID="SECTION", class="Example">
    <a name="Example"></a>
<!------------------------------->
<h4 class="w3-text-red">Example of a Dataflow Graph</h4>
   <figure>
    <img
    src="Dataflow.002.jpeg"
    alt="Fig2" style="width:100%"> 
    <figcaption>Figure 1: Example of a Dataflow Graph</figcaption>
</figure>

<p>
Figure 1 shows the dataflow graph for a computation of a
system consisting of two agents <code>u</code> and <code>v</code>, and
with two channels <code>(u, v)</code> and <code>(v, u)</code>.
The computation is defined by its initial state and step sequence [1,
    2, 3, 4].
    Steps 1 and 4 are at agent <code>u</code>, and steps 2 and 3 are
    at <code>v</code>.
    The initial states at agents <code>u</code> and
<code>v</code> are represented by outputs of steps <code>u_init</code>
and <code>v_init</code>, respectively, and final states by inputs to
<code>u_fini</code> and <code>v_fini</code>, respectively.
    </p>
    
<p>
The top horizontal edges represent data flow between steps at agent
<code>u</code> and the lower horizontal edges represent data flow
between steps at agent <code>v</code>.
For example, the labels <code>u1, u2, u3</code> are: (1) the initial state
of agent <code>u</code>, (2) the state of <code>u</code> between steps 1
and 4, and (3) the state of <code>u</code> after step 4, respectively.
Likewise, the labels <code>v1, v2, v3</code> are the states of
agent <code>v</code> initially and after steps 2 and 3, respectively.
</p>

    <p>
    Message edges are labeled <code>m1, m2, m3, m4, m5</code>.
    Initially channel <code>(u, v)</code> contains message
    <code>m2</code> and channel <code>(v, u)</code> contains message
    <code>m1</code>.  Message <code>m3</code> is sent in step 1 and
    received in step 3, and message <code>m4</code> is sent in step 3
    and received in step 4.
    </p>

</div>
<!---------------END SECTION: Example ------------------------------>



<!-------------START SECTION: Computations and Dataflow ------------->
  <div ID="SECTION", class="ComputationsAndDataflow">
    <a name="ComputationsAndDataflow"></a>


<!---------------------------------------->
    <h5 class="w3-text-teal">Flow of Data in a Computation</h5>
    <p>
    The edges of the dataflow graph of a computation show the flow of
    data into and out of each step of a computation.  Data -- in the
    form of the agent's state -- flows from a step at an agent to the
    next step at that agent in the computation.  Data -- in the form
    of message contents -- flows from a step in which a message is
    sent to the step in which the message is received.  The graph is
    acyclic because every edge is directed from a step earlier in the
    sequence \([e_{0}, e_{1}, \ldots, e_{n}]\) to later in the
    sequence.
    </p>


    <!-------------------------------------------------->
    <h4 class="w3-text-teal">A Dataflow Lemma</h4>
    <!-------------------------------------------------->
    
    <p>
    Let <code>G</code> be the dataflow graph of a computation specified by a sequence of
    steps \(E = [e_{0}, e_{1}, \ldots, e_{n}]\).
    Let \(E'\) be the permutation of \(E\)
    obtained by switching the order of a pair of adjacent elements
    \(e_{i}, e_{i+1}\) in \(E\).
    <p>
    If there is no edge from \(e_{i}\) to \(e_{i+1}\) in <code>G</code> then \(E'\) is
    also a computation.
</p>

    <!-------------------------------------------------->
    <p class="w3-text-teal">Proof</p>
    <!-------------------------------------------------->
    
    <p>
    Let \(e_{i}\) be an event in which agent <code>u</code> receives a
    message <code>m</code> from agent <code>v</code> when the state of
    <code>u</code> is <code>s</code>.
    Let \(e_{i+1}\) be an event in which agent <code>u'</code> receives a
    message <code>m'</code> from agent <code>v'</code> when the state of
    <code>u'</code> is <code>s'</code>.

    <p>
    Because there is no edge from \(e_{i}\) to \(e_{i+1}\),
    agents <code>u</code> and <code>u'</code> are different and
    messages <code>m</code> and <code>m'</code> are different.


<p>Therefore the inputs to \(e_{i}\)  -- namely state <code>s</code>
of agent <code>u</code> and message <code>m</code> from agent
<code>v</code>  -- do not change if \(e_{i+1}\) appears before
\(e_{i}\). By the same argument the inputs to \(e_{i+1}\) do not
change if \(e_{i+1}\) appears before \(e_{i}\). Therefore there exists
a computation in which \(e_{i+1}\) appears before \(e_{i}\).


<!-------------------------------------------------->
<h6 class="w3-text-red">Example of Switching Adjacent Independent
Steps</h6>
<p>
Figure 2 shows two
diagrams with identical dataflow graphs. The upper and lower diagrams are 
representations of computations starting at the same state and step
sequences [1, 2, 3, 4], and [2, 1, 3, 4], respectively. Initial and
final vertices are not shown. The sequence of events in a computation
are shown in the diagram by placing the vertices representing the
events in order with later events appearing to the right of earlier
events.

<p>
The order in which vertices 1 and 2 appear, from left to right, in the
diagrams have been switched.
The dataflow lemma says that if there is a computation [1, 2, 3, 4]
then [2, 1, 3, 4] is also a computation because there is no edge from
vertex 1 to vertex 2.
</p>


   <figure>
    <img
    src="Dataflow.006.jpeg"
    alt="Fig6" style="width:100%"> 
<figcaption>Figure 2: Example of Switching Adjacent Independent Steps
</figcaption>
</figure>

  <!----------------------------------------------->
  <h3 class="w3-text-teal">Topological Sorts</h3>
<!----------------------------------------------->
<p>
A <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sort</a> of a directed acyclic graph is a sequence of
  vertices of the graph where for every edge \((x, y)\) in the graph,
    \(x\) appears before \(y\) in the sequence.
    </p>

    <h5 class="w3-text-red">Examples of Sequences that Are and Are Not
    Topological Sorts</h5>

<p>
Sequences [1, 2, 3, 4] and [2, 1, 3, 4] are topological sorts of the
graph.
Sequence [1, 2, 4, 3] is not a topological sort because there is a backward
edge , i.e., an edge directed from a later vertex in the sequence (i.e, vertex 3) to
an earlier vertex (4) in the sequence.


   <figure>
    <img
    src="Dataflow.007.jpeg"
    alt="Fig7" style="width:100%"> 
<figcaption>Figure 3: [2, 1, 3, 4] is a topological sort but [1, 2, 4,
    3] is not.
</figcaption>
</figure>

<a name="TheoremTopologicalSort">
<hr class="new2">
  <!----------------------------------------------->
  <h3 style="color:blue;">Theorem: Topological Sorts of Dataflow</h3>
<!----------------------------------------------->

<p style="color:blue;">
All topological sorts of a dataflow graph of a computation are
computations. 
</p>
<hr class="new2">
<p>

<h6 class="w3-text-teal">Proof of the Theorem</h6>
Let \(G\) be the dataflow graph of a computation specified by a
sequence of steps \(E = [e_{0}, e_{1}, \ldots]\).
Let \(E'\) be a topological sort of \(G\).
We will prove that \(E'\) is also a computation.

<p>
The theorem holds trivially if \(E'\) and \(E\) are identical.
If \(E\) and \(E'\) are not identical then there exists an adjacent
pair of steps \(e_{i}, e_{i+1}\) in \(E\) where \(e_{i+1}\) occurs
before \(e_{i}\) in \(E'\). Because \(E'\) is a topological sort,
there is no edge in the dataflow graph from \(e_{i}\) to \(e_{i+1}\).
</p>

<p>
Let \(H\) be the sequence of steps identical to \(E\) except that the
order of \(e_{i}\) and \(e_{i+1}\) is switched  in \(H\).
From the lemma \(H\) is also a computation.
The number of out of order pairs between \(H\) and \(E'\) is less than
that between \(E\) and \(E'\).
By repeatedly switching independent, adjacent, out-of-order pairs
the sequence \(E'\) is reached.
    </p>


<!-------------END SECTION: Computations and Dataflow ------------->

<p class="w3-text-teal">Note</p>
Some articles use the phrase "\(x\) causes \(y\)" for "there is a
path in the dataflow graph from step \(x\) to step \(y\)."




</div>
<!--------------END SECTION: Dataflow ---------------------->

 

    
<!---------------------------------------->
<h5 class="w3-text-teal">Next</h5>
<!---------------------------------------->
The next pages describes
<a href="../ChannelSnapshots/Timelines.html">Cuts in Dataflow Graphs
</a>
which are used in developing detection algorithms such as termination
detection and deadlock detection.

<p>
<a href="ModelExamples.html">Examples</a>

<p>
<a href="ModelFAQ.html">Frequenty Asked Questions</a>

<p>
<a href="ModelReview.html">Review</a>


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    

<!-- END MAIN -->
</div>

</body>
</html>


