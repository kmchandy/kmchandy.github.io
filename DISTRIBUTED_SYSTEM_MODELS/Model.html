<title>DistributedSystemModels/Models.html</title>
<title>DistributedSystemModels/Model.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

<!-------------------------------------------------------------->
<h2 class="w3-text-teal">Data Flow in Computations</h2>
<!-------------------------------------------------------------->
  <p class="w3-text-red">
  A dataflow graph of a computation is a labeled directed acyclic
  graph that shows the flow of data between agents during the
  computation. 
  All <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sorts</a> of a dataflow graph are computations.
  </p>
 



  <!----------------------------------------------->
  <h4 class="w3-text-teal">Dataflow Graph</h4>
  <!----------------------------------------------->
  <p>
<a href="https://en.wikipedia.org/wiki/Dataflow_programming">Data flow</a>
  is a concept that has been used in computer science for over 50
  years. 
  Next we show how data flow helps in developing distributed
  algorithms.
  </p>

  
<!--------------START SECTION: Dataflow ---------------------->
  <div ID="SECTION">
    <a name="Dataflow"></a>
    <p>
    <!--------START SECTION: Dataflow Definition ----------------->
  <div ID="SECTION">
    <a name="DataflowDefinition"></a>
A dataflow graph of a computation is a labeled, directed, acyclic
  graph  that shows the flow of data between agents during the
  computation. 
    The vertices of the graph represent steps of the computation.
We use <i>step</i> of a computation and <i>vertex</i> of its dataflow
graph interchangeably.
  </p>

<!------------------------------->
<h6 class="w3-text-red">Example of a Vertex in a Dataflow Graph</h6>
   <figure>
    <img
    src="Dataflow.001.jpeg"
    alt="Fig11" style="width:100%"> 
    <figcaption>Figure Example of a Vertex in a Dataflow Graph</figcaption>
</figure>

    <h6 class="w3-text-teal">Edges of a Dataflow Graph</h6>
  <p>
  The edges of a dataflow graph are as follows.
  <ol>
  <li>
There is an edge from a step at an agent to the next step at that
agent; this edge is labeled with the state of the agent between the
events and is called an <i>agent edge</i>.
  </li>
  <li>
There is an edge from a step in which a message is sent
to the step at which the message is received; this edge is called a
  <i>message edge</i>. The edge is labeled with a pair \((m, w)\)
  where \(m\) is the message and \(w\) is the sender of the message.
  </li>
</ol>
</p>

    
<h6 class="w3-text-teal">Dataflow Graphs are Acyclic</h6>
<p>
A dataflow graph of a computation is acyclic because each edge is
directed from a step to a later step of the computation.
</p>

<p>
We adopt the convention that agent edges are horizontal.
    So, all edges of the same agent are on the same horizontal line.
</p>
</div>
<!--------END SECTION: Dataflow Definition ----------------->


<!------START SECTION: Initial And Final States ------------>
  <div ID="SECTION">
    <a name="InitialAndFinalStates"></a>
<h5 class="w3-text-teal">Representing Initial and Final States by
    Fictitious Steps</h5>
    <p>
A computation is specified by its initial state and a sequence of
events.
For convenience, we represent the initial state of an agent \(u\) and
the initial states of \(u\)'s output channels be a fictitious step,
\(u_{init}\).
    The vertex representing this step has no inputs.
    </p>

<p>
The agent edge from this step is labeled with \(u\)'s initial state.
The message edges from this step to steps of an agent \(v\) are
labeled with the messages in the channel \((u, v)\) in the initial
state of the computation.
</p>
   <figure>
    <img
    src="Dataflow.003.jpeg"
    alt="Fig3" style="width:100%"> 
    <figcaption>Figure Example of an Initial Vertex of a Dataflow
    Graph </figcaption>
</figure>
<p>
The figure shows an example of an initial vertex, <code>u_init</code>
at agent <code>u</code> of a dataflow graph.
The vertex has an output agent edge labeled <code>u1</code> which is
the initial state of agent <code>u</code> in the computation.
The vertex has an output message edge labeled <code>m2</code>; this
edge is to a step in agent <code>v</code> and shows that the initial
state of the channel <code>(u, v)</code> consists of the single
    message <code>m2</code>.
    </p>


<p>
By symmetry, we use a fictitious step <code>u_init</code> to represent the final
state of <code>u</code> and the final states of channels to <code>u</code>.
With the introduction of fictitious initial and final steps for each
agent we can treat a computation as a sequence of steps where the
initial state is specified by initial steps.
</p>
   <figure>
    <img
    src="Dataflow.004.jpeg"
    alt="Fig4" style="width:100%"> 
    <figcaption>Figure Example of a Final Vertex of a Dataflow
    Graph </figcaption>
    </figure>
    </div>
    <!------END SECTION: Initial And Final States ------------>
 

<!---------------START SECTION: Example ------------------------------>
  <div ID="SECTION">
    <a name="Example"></a>
<!------------------------------->
<h6 class="w3-text-red">Example of a Dataflow Graph</h6>
   <figure>
    <img
    src="Dataflow.002.jpeg"
    alt="Fig2" style="width:100%"> 
    <figcaption>Figure Example of a Dataflow Graph</figcaption>
</figure>

<p>
The figure shows the dataflow graph for a computation of a
system consisting of two agents <code>u</code> and <code>v</code>, and
with two channels <code>(u, v)</code> and <code>(v, u)</code>.
The computation is defined by its initial state and event sequence [1,
2, 3, 4]. The initial states at agents <code>u</code> and
<code>v</code> are represented by outputs of steps <code>u_init</code>
and <code>v_init</code>, respectively, and final states by inputs to
<code>u_fini</code>
and <code>v_fini</code>, respectively.
    </p>
    
<p>
The top horizontal edges represent data flow between steps at agent
<code>u</code> and the lower horizontal edges represent data flow
between steps at agent <code>v</code>.
For example, the labels <code>u1, u2, u3</code> are the initial state
of agent <code>u</code>, the state of <code>u</code> between steps 1
and 4, and the state of <code>u</code> after step 4, respectively.
Likewise, the labels <code>v1, v2, v3</code> are the states of
agent <code>v</code> initially and after steps 2 and 3, respectively.
</p>

<p>
Message edges are labeled <code>m1, m2, m3, m4, m5</code>.
Initially channel <code>(u, v)</code> contains message <code>m2</code>
and channel <code>(v, u)</code> contains message <code>m1</code>.
Message <code>m3</code> is sent in step 1 and received in step 3, and
message <code>m4</code> is sent in step 3 and received in step 4.
    </p>
    
<p>
Vertex 1 in the graph, see figure 1 -- example of a vertex in a
dataflow graph -- represents the execution of a step at agent
<code>u</code>.
This step is the execution of an event specified by the following
4-tuple:
<ol>
  <li>
  The state of \(u\) before the event is <code>u1</code>.
  </li>
  <li>
  The message received in the event is <code>m1</code> from agent
  <code>v</code>.
  </li>
  <li>
  The state  of \(u\) after the event is <code>u2</code>.
  </li>
  <li>
  A single message <code>m3</code> is sent in the event and this
  message is  sent to agent <code>v</code>.
  </li>
</ol>
</p>
<p>
The input and output edges of the vertex are the inputs and outputs
(respectively) of the event.
</p>
</div>
<!---------------END SECTION: Example ------------------------------>



<!-------------START SECTION: Computations and Dataflow ------------->
  <div ID="SECTION">
    <a name="ComputationsAndDataflow"></a>


<!---------------------------------------->
<h3 class="w3-text-teal">Flow of Data in a Computation</h3>
<p>
The edges of the dataflow graph of a computation show the flow of data
into and out of each step of a computation.
Data -- in the form of the agent's state -- flows from a step of an
agent to the next step at that agent.
Data -- in the form of message contents -- flows from a step in which
a message is sent to the step in which the message is received.
</p>


<h6 class="w3-text-teal">The Relation: "data flows from" between Steps
of a Computation</h6>
<p>
We define a relation "data flows from" between steps of a
computation 
as follows: for steps \(x, y\) of a computation, data flows from
\(x\) to \(y\) exactly when there is a path in the computation's
dataflow graph from \(x\) to \(y\).
</p>

<p>
If there are paths in a graph from \(x\) to \(y\) and from
\(y\) to \(z\), then there is a path in the graph from \(x\) to \(z\).
So, if data flows from \(x\) to \(y\), and data flows from \(y\) to
\(z\) then data flows from \(x\) to \(z\).
The relation "data flows from" is a
<a
href="https://en.wikipedia.org/wiki/Partially_ordered_set#Partial_order">
strict partial order</a>.
</p>

<p>
We say that different steps \(x\) and \(y\) are <i>independent</i> if data does
not flow from  \(x\) to \(y\) or from \(y\) to \(x\).
</p>


<h5 class="w3-text-red">Example of data flows from a step to a
step</h5>
<p>
The figure "Example -- Data Flows from Step 2 to Step 4" shows
examples of data flow as red edges in the graph.
Steps 1 and 2 are independent because there is no path from step 1 to
step 2, and there is no path from step 2 to step 1.
</p>

   <figure>
    <img
    src="Dataflow.005.jpeg"
    alt="Fig5" style="width:100%"> 
    <figcaption>Figure Example -- Data Flows from Step 2 to Step 4</figcaption>
</figure>

  <!----------------------------------------------->
  <h3 class="w3-text-teal">Computations and Dataflow Graphs</h3>
<!----------------------------------------------->
<p>
Let a computation be specified by a sequence of steps \(E\), and
let \(E'\) be any permutation of \(E\).
<i>Data flows forwards in \(E\)</i> means that for all steps
\(x\) and \(y\) in \(E\):
<center>
If data flows from \(x\) to \(y\) in \(E\)
then \(x\) appears before \(y\) in
\(E'\). 
</center>
</p>

<p>
Next we prove properties about sequences of steps in which data flows forwards.
We start with the following lemma.
</p>


<h5 class="w3-text-teal">Lemma: Switching Order of Adjacent
Independent Steps in a Computation</h5>

Let a computation be specified by  a sequence of
steps \(E\), and let \(E'\) be any permutation of \(E\)
obtained by switching the order of a pair of adjacent elements in
\(E\). 

If data flows forward in \(E'\) then \(E'\) is a computation.

<p class="w3-text-teal">Proof</p>

Assume that the order of adjacent steps \(e_{i}\) and \(e_{i+1}\) are
switched in \(E\) to get \(E'\).

Because \(e_{i}\) precedes \(e_{i+1}\) in \(E\) there is no data flow
from \(e_{i+1}\) to \(e_{i}\).
Because data flows forwards in \(E'\) there is no data flow from
\(e_{i}\) to \(e_{i+1}\).

<p>
Therefore \(e_{i}\) and \(e_{i+1}\) are adjacent independent steps.
So, the inputs to \(e_{i}\) and \(e_{i+1}\) remain the same
regardless of the order in which they are executed, and so \(E'\) is
also a computation.

<h6 class="w3-text-red">Example of Switching Adjacent Independent
Steps</h6>
The Figure "Example of Switching Adjacent Independent Steps" shows two
diagrams with identical dataflow graphs. The upper and diagrams are 
representations of computations starting at the same state and step
sequences [1, 2, 3, 4], and [2, 1, 3, 4].
The order in which vertices 1 and 2 appear, from left to right, in the
diagrams have been switched.
The graphs, however, are identical.
<p>
The inputs to step 1 remain the same whether step 2 is executed
before or after step 1.
Likewise, the inputs to step 2 remain the same whether step 1 is executed
before or after step 2.

   <figure>
    <img
    src="Dataflow.006.jpeg"
    alt="Fig6" style="width:100%"> 
<figcaption>Figure Example of Switching Adjacent Independent Steps
</figcaption>
</figure>

<a name="TheoremPermutations">
<hr class="new2">
<h5 style="color:blue;">Theorem: Permutations of Computations in which
Data Flows Forwards</h5>
<p style="color:blue;">
Given a computation specifed by a sequence of
steps \(E\), all permutations of \(E\) in which data flows forwards in
the permutations are also computations.
</p>
<hr class="new2">



<h5 class="w3-text-teal">Proof</h5>
<p>
Let \(E'\) be a permutation of \(E\) where data flows forwards in
\(E'\).
The theorem holds trivially if \(E\) and \(E'\) are identical.
</p>

<p>
If \(E\) and \(E'\) are not identical then there exists an adjacent
pair of steps \(x, y\) in \(E\) where \(x\) occurs before \(y\) in
\(E\), and \(y\) occurs before \(x\) in \(E'\).
</p>

<p>
Because \(E\) is a computation, data flows forwards in \(E\) and
therefore there is no data flow from \(y\) to \(x\).
</p>

<p>
We are given that data flows forwards in \(E'\). So there is no
data flow from \(x\) to \(y\).
</p>

<!-------------START SECTION: Computations and Dataflow ------------->
  <div ID="SECTION">
    <a name="ComputationsAndDataflow"></a>


<p>
Therefore \(x\) and \(y\) are independent.
Let \(H\) be the sequence of steps obtained from \(E\) by switching
the order of \(x\) and \(y\).
From the lemma "Switching Order of Independent Adjacent Steps" it
follows 
    that \(H\) is also a computation.
    </p>

<p>
The number of out of order pairs between \(H\) and \(E'\) is less than
that between \(E\) and \(E'\).
By repeatedly switching of independent adjacent out of order pairs
the sequence \(E'\) is reached.
    </p>
</div>
<!-------------END SECTION: Computations and Dataflow ------------->



  <!----------------------------------------------->
  <h4 class="w3-text-teal">Relationship to Topological Sorts</h4>
<!----------------------------------------------->
The theorem on permutations of event sequences can be expressed in
terms of topological sorts.

A <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sort</a> of a directed acyclic graph is a sequence of
  vertices of the graph where for every edge \((x, y)\) in the graph,
\(x\) appears before \(y\) in the sequence.



<a name="TheoremTopologicalSort">
<hr class="new2">
  <!----------------------------------------------->
  <h4 style="color:blue;">Theorem: Topological Sorts of Dataflow</h4>
<!----------------------------------------------->

<p style="color:blue;">

All topological sorts of a dataflow graph are computations.
</p>
<hr class="new2">



  <!----------------------------------------------->
  <h5 class="w3-text-teal">Relationship to Causality</h5>
<!----------------------------------------------->
Some articles use the relation "\(x\) causes \(y\)" instead of
"data flows from \(x\) to \(y\)."

Causality and data flow have been widely used concepts for decades and
we will see the next pages how we use them to develop distributed
algorithms. 


</div>
<!--------------END SECTION: Dataflow ---------------------->

<!---------------------------------------->
<h5 class="w3-text-teal">Next</h5>
<!---------------------------------------->
The next pages describes
<p>
<a href="../ChannelSnapshots/Timelines.html">Cuts in Dataflow Graphs
</a>
which are used in developing detection algorithms such as termination
detection and deadlock detection.

<p>
<a href="ModelExamples.html">Examples</a>

<p>
<a href="ModelFAQ.html">Frequenty Asked Questions</a>

<p>
<a href="ModelReview.html">Review</a>


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    

<!-- END MAIN -->
</div>

</body>
</html>


