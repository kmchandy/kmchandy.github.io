<title>DistributedSystemModels/Models.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!-------------------------------------------------------------->
<h2 class="w3-text-teal">Data Flow in Computations</h2>
<!-------------------------------------------------------------->
  <p class="w3-text-red">
  A dataflow graph of a computation is a labeled directed acyclic
  graph that shows the flow of data between agents during the
  computation. 

  All <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sorts</a> of a dataflow graph are computations.
  </p>
 



  <!----------------------------------------------->
  <h4 class="w3-text-teal">Dataflow Graph</h4>
<!----------------------------------------------->


A dataflow graph of a computation is a labeled, directed, acyclic
  graph  that shows the flow of data between agents during the
  computation. 

  The vertices of the graph represent steps of the computation.

  The edges of a dataflow graph are as follows.

  <ol>
  <li>
There is an edge from a step at an agent to the next step at that
agent; this edge is labeled with the state of the agent between the
events and is called an <i>agent edge</i>.
  </li>
  <li>
There is an edge from a step in which a message is sent
to the step at which the message is received; this edge is called a
  <i>message edge</i>. The edge is labeled with a pair \((m, w)\)
  where \(m\) is the message and \(w\) is the sender of the message.
  </li>
</ol>

<h5 class="w3-text-teal">Representing Initial and Final States by
Fictitious Steps</h5>
A computation is specified by its initial state and a sequence of
events.

For convenience, we represent the initial state of an agent \(u\) and
the initial states of \(u\)'s output channels be a fictitious step,
\(u_{init}\).

The vertex representing this step has no inputs.

<p>
The agent edge from this step is labeled with \(u\)'s initial state.

The message edges from this step to steps of an agent \(v\) are
labeled with the messages in the channel \((u, v)\) in the initial
state of the computation.

<p>
By symmetry, we use a fictitious step \(u_{fini}\) to represent the final
state of \(u\) and the final states of channels to \(u\).

With the introduction of fictitious initial and final steps for each
agent we can treat a computation as a sequence of steps where the
initial state is specified by initial steps.


<p>
We adopt the convention that agent edges are horizontal.

So, all edges of the same agent are on the same horizontal line.

<p>
We use <i>step</i> of a computation and <i>vertex</i> of its dataflow
graph interchangeably, with the meaning understood by context.



<h6 class="w3-text-teal">Dataflow Graphs are Acyclic</h6>
A dataflow graph of a computation is acyclic because each edge is directed from a step
to a later step of the computation.

<!---------------------------------------->
<h4 class="w3-text-teal">Flow of Data in a Computation</h4>
The edges of the dataflow graph of a computation show the flow of data
into and out of each step of a
computation.

Data -- in the form of the agent's state -- flows from a step of an
agent to the next step at that agent.

Data -- in the form of message contents -- flows from a step in which
a message is sent to the step in which the message is received.

<h6 class="w3-text-teal">The Relation: "data flows from" between Steps
of a Computation</h6>
We define a relation "data flows from" between steps of a computation
as follows: for steps \(x, y\) of a computation, data flows from
\(x\) to \(y\) exactly when there is a path in the computation's dataflow graph
from \(x\) to \(y\).

<p>
We say that steps \(x\) and \(y\) are <i>independent</i> if data does not
flow from  \(x\) to \(y\) or from \(y\) to \(x\).

<!----------------------------------------------->
<h4 style="color:red;">Example of Dataflow</h4>

  
    <figure>
    <img
    src="Model/Model.003.jpeg"
    alt="Fig3" style="width:100%"> 
    <figcaption>Figure Dataflow_1: Example: Dataflow Graph</figcaption>
</figure>

<p>
The figure Dataflow_1 shows the dataflow graph for a computation of a
system consisting of two agents <code>u</code> and <code>v</code>, and
with two channels <code>(u, v)</code> and <code>(v, u)</code>.

The computation is defined by its initial state and event sequence [1,
2, 3, 4]. The initial states are represented by steps 0.

<p>
The top horizontal edges represent data flow between steps at agent
<code>u</code> and the lower horizontal edges represent data flow
between steps at agent <code>v</code>.

For example, the labels <code>u1, u2, u3</code> are the states of
agent <code>u</code> initially and after steps 1 and 4, respectively.

Likewise, the labels <code>v1, v2, v3</code> are the states of
agent <code>v</code> initially and after steps 2 and 3, respectively.



<p>
Message edges are labeled <code>m1, m2, m3, m4</code>.

Initially channel <code>(u, v)</code> contains message <code>m2</code>
and channel <code>(v, u)</code> contains message <code>m1</code>.

Message <code>m3</code> is sent in step 1 and received in step 3, and
message <code>m4</code> is sent in step 3 and received in step 4.

<p>
Vertex 1 in the graph represents execution of a step at agent
<code>u</code>.
This step is the execution of an event specified by the following
4-tuple:
<ol>
  <li>
  The state of \(u\) before the event is <code>u1</code>.
  </li>
  <li>
  The message received in the event is <code>m1</code> from agent
  <code>v</code>.
  </li>
  <li>
  The state  of \(u\) after the event is <code>u2</code>.
  </li>
  <li>
  A single message <code>m3</code> is sent in the event and this
  message is  sent to agent <code>v</code>.
  </li>
</ol>

The input and output edges of the vertex are the inputs and outputs
(respectively) of the event.




  <!----------------------------------------------->
  <h3 class="w3-text-teal">Computations and Dataflow Graphs</h3>
<!----------------------------------------------->

<i>Data flows forwards in a computation</i> -- i.e. If data flows from a step \(x\)
to a step \(y\) in a computation then \(x\) appears before \(y\) in
the computation.

<p>
It is sometimes helpful to use the negated version of this observation
-- Data does not flow backward in a computation. If \(x\) appears before \(y\) in
a computation then there is no data flow from \(y\) to \(x\)
<p>
Next we prove properties about sequences of steps in which data flows forwards.

We start with the following lemma.



<h5 class="w3-text-teal">Lemma: Switching Order of Adjacent
Independent Steps</h5>

Given a computation specified by  a sequence of
steps \(E = [e_{0}, \ldots, e_{i}, e_{i+1}, \ldots, e_{N}]\),

let \(E' = [e_{0}, \ldots, e_{i+1}, e_{i}, \ldots, e_{N}]\) be the
permutation of \(E\) obtained by switching the order of \(e_{i+1}\) and
\(e_{i}\).

If data flows forward in \(E'\) then \(E'\) is a computation.

<p class="w3-text-teal">Proof</p>


Because \(e_{i}\) precedes \(e_{i+1}\) in E there is no data flow from
\(e_{i+1}\) to \(e_{i}\).

So the inputs to \(e_{i}\) remain the same whether
\(e_{i+1}\) is executed before or after \(e_{i}\).

<p>
Because data flows forwards in \(E'\) there is no data flow from
\(e_{i}\) to \(e_{i+1}\).

So the inputs to \(e_{i+1}\) remain the same whether
\(e_{i}\) is executed before or after \(e_{i+1}\).

<p>
So events \(e_{i}\) and \(e_{i+1}\) are independent.
Switching the order in which they are executed does not change
the inputs and outputs of steps in the computation. 



<hr class="new2">
<h4 style="color:blue;">Theorem: Permutations of Computations</h4>
<p style="color:blue;">
Given a computation specifed by a sequence of
steps \(E\), all permutations of \(E\) in which data flows forwards
are also computations.
</p>
<hr class="new2">



<h5 class="w3-text-teal">Proof</h5>
Let \(E'\) be a permutation of \(E\) where data flows forwards in
\(E'\).

The theorem holds trivially if \(E\) and \(E'\) are identical.

<p>
If \(E\) and \(E'\) are not identical then there exists an adjacent
pair of steps \(x, y\) in \(E\) where \(x\) occurs before \(y\) in
\(E\), and \(y\) occurs before \(x\) in \(E'\).

<p>
Because \(E\) is a computation, data flows forwards in \(E\) and
therefore there is no data flow from \(y\) to \(x\).

<p>
We are given that data flows forwards in \(E'\). So there is no
data flow from \(x\) to \(y\).


<p>
Therefore \(x\) and \(y\) are independent.
Let \(H\) be the sequence of steps obtained from \(E\) by switching
the order of \(x\) and \(y\).

From the lemma "Switching Order of Adjacent Steps" it follows
that \(H\) is also a computation.

<p>
The number of out of order pairs between \(H\) and \(E'\) is less than
that between \(E\) and \(E'\).

By repeatedly switching of independent adjacent out of order pairs
the sequence \(E'\) is reached.





  <!----------------------------------------------->
  <h4 class="w3-text-teal">Relationship to Topological Sorts</h4>
<!----------------------------------------------->
The theorem on permutations of event sequences can be expressed in
terms of topological sorts.

A <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sort</a> of a directed acyclic graph is a sequence of
  vertices of the graph where for every edge \((x, y)\) in the graph,
\(x\) appears before \(y\) in the sequence.


<hr class="new2">
  <!----------------------------------------------->
  <h4 style="color:blue;">Theorem: Topological Sorts of Dataflow</h4>
<!----------------------------------------------->

<p style="color:blue;">

All topological sorts of a dataflow graph are computations.
</p>
<hr class="new2">




<!---------------------------------------->
<h5 class="w3-text-teal">Next</h5>
<!---------------------------------------->
The next pages describes
<p>
<a href="Timelines.html">Cuts in Dataflow Graphs
</a>
which are used in developing detection algorithms such as termination
detection and deadlock detection.

<p>
<a href="ModelExamples.html">Examples</a>

<p>
<a href="ModelFAQ.html">Frequenty Asked Questions</a>


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>


