<title>DistributedSystemModels/Models.html</title>
<title>DistributedSystemModels/Model.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

<!-------------------------------------------------------------->
<h2 class="w3-text-teal">Data Flow in Computations</h2>
<!-------------------------------------------------------------->
  <p class="w3-text-red">
  A dataflow graph of a computation is a labeled directed acyclic
  graph that shows the flow of data between agents during the
  computation. 
  All <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sorts</a> of a dataflow graph are computations.
  </p>
 



  <!----------------------------------------------->
  <h3 class="w3-text-teal">Dataflow Graph</h3>
  <!----------------------------------------------->
  <p>
<a href="https://en.wikipedia.org/wiki/Dataflow_programming">Data flow</a>
  is a concept that has been used in computer science for over 50
  years. 
  Next we show how data flow helps in developing distributed
  algorithms.
  </p>

  
<!--------------START SECTION: Dataflow ---------------------->
  <div ID="SECTION", class="Dataflow">
    <p>
    <!--------START SECTION: Dataflow Definition ----------------->
  <div ID="SECTION", class="DataflowDefinition">
    <a name="DataflowDefinition"></a>
A dataflow graph of a computation is a labeled, directed, acyclic
  graph  that shows the flow of data between agents during the 
  computation. 
  The vertices of the graph represent events that occur in the computation.
  </p>

<!------------------------------->
    <h5 class="w3-text-red">Diagrammatic Representation of an Event</h5>
    The figure shows a diagrammatic representation of an event at an
    agent <code>u</code>.
    Each occurrence of an event in a computation is represented by a
    vertex in the dataflow graph.
   <figure>
    <img
    src="Dataflow.001.jpeg"
    alt="Fig1" style="width:80%"> 
    <figcaption>Figure 1: Example of a Vertex in a Dataflow Graph</figcaption>
</figure>


    
    <h6 class="w3-text-teal">Edges of a Dataflow Graph</h6>
  <p>
  The edges of a dataflow graph are as follows.
  <ol>
  <li>
There is an edge from an event at an agent to the next event at that
    agent in the computation.
    This edge is labeled with the state of the agent between the
events and is called an <i>agent edge</i>.
  </li>
  <li>
There is an edge from an event in which a message \(m\) is sent
to the event at which \(m\) is received; this edge is called a
  <i>message edge</i> and is labeled \(m\).
  </li>
</ol>
</p>

    
<h6 class="w3-text-teal">Dataflow Graphs are Acyclic</h6>
<p>
A dataflow graph of a computation is acyclic because each edge is
directed from an to a later event of the computation.
</p>

<p>
We adopt the convention that agent edges are horizontal, and that
later events in a computation are represented by vertices to the right
of earlier events.
So, all edges of the same agent are on the same horizontal line,
and all edges have an orientation towards later times, i.e. towards
the right.

</p>
</div>
<!--------END SECTION: Dataflow Definition ----------------->


<!------START SECTION: Initial And Final States ------------>
  <div ID="SECTION", class="InitialAndFinalStates">
    <a name="InitialAndFinalStates"></a>
<h5 class="w3-text-teal">Representing Initial and Final States by
    Fictitious Steps</h5>
    <p>
A computation is specified by its initial state and a sequence of
events.
For convenience, we represent the initial state of an agent \(u\) and
the initial states of \(u\)'s output channels be a fictitious event,
\(u_{init}\).
    The vertex representing this step has no inputs.
    </p>

<p>
The agent edge from this event is labeled with \(u\)'s initial state.
The message edges from this event to steps of an agent \(v\) are
labeled with the messages in the channel \((u, v)\) in the initial
state of the computation.
</p>
   <figure>
    <img
    src="Dataflow.003.jpeg"
    alt="Fig3" style="width:80%"> 
    <figcaption>Figure 2: Example of an Initial Vertex of a Dataflow
    Graph </figcaption>
</figure>
<p>
The figure shows an example of an initial vertex, <code>u_init</code>
at agent <code>u</code> of a dataflow graph.
The vertex has an output agent edge labeled <code>u1</code> which is
the initial state of agent <code>u</code> in the computation.
The vertex has an output message edge labeled <code>m2</code>; this
edge is to a step in agent <code>v</code> and shows that the initial
state of the channel <code>(u, v)</code> consists of the single
    message <code>m2</code>.
    </p>


<p>
By symmetry, we use a fictitious event <code>u_fini</code> to represent the final
state of <code>u</code> and the final states of channels to <code>u</code>.
With the introduction of fictitious initial and final event for each
agent we can treat a computation as a sequence of events where the
    initial state is specified by initial events and where the
    final state is specified by final events.
    The figure below is an example of a final vertex of an agent
    <code>v</code>.
</p>
   <figure>
    <img
    src="Dataflow.004.jpeg"
    alt="Fig4" style="width:80%"> 
    <figcaption>Figure 3: Example of a Final Vertex of a Dataflow
    Graph </figcaption>
    </figure>
    </div>
    <!------END SECTION: Initial And Final States ------------>
 

<!---------------START SECTION: Example ------------------------------>
  <div ID="SECTION", class="Example">
    <a name="Example"></a>
<!------------------------------->
<h4 class="w3-text-red">Example of a Dataflow Graph</h4>
   <figure>
    <img
    src="Dataflow.002.jpeg"
    alt="Fig2" style="width:100%"> 
    <figcaption>Figure 4: Example of a Dataflow Graph</figcaption>
</figure>

<p>
The figure shows the dataflow graph for a computation of a
system consisting of two agents <code>u</code> and <code>v</code>, and
with two channels <code>(u, v)</code> and <code>(v, u)</code>.
The computation is defined by its initial state and event sequence [1,
2, 3, 4]. The initial states at agents <code>u</code> and
<code>v</code> are represented by outputs of events <code>u_init</code>
and <code>v_init</code>, respectively, and final states by inputs to
<code>u_fini</code>
and <code>v_fini</code>, respectively.
    </p>
    
<p>
The top horizontal edges represent data flow between events at agent
<code>u</code> and the lower horizontal edges represent data flow
between events at agent <code>v</code>.
For example, the labels <code>u1, u2, u3</code> are the initial state
of agent <code>u</code>, the state of <code>u</code> between events 1
and 4, and the state of <code>u</code> after event 4, respectively.
Likewise, the labels <code>v1, v2, v3</code> are the states of
agent <code>v</code> initially and after events 2 and 3, respectively.
</p>

<p>
Message edges are labeled <code>m1, m2, m3, m4, m5</code>.
Initially channel <code>(u, v)</code> contains message <code>m2</code>
and channel <code>(v, u)</code> contains message <code>m1</code>.
Message <code>m3</code> is sent in event 1 and received in event 3, and
message <code>m4</code> is sent in event 3 and received in event 4.
    </p>
    
<p>
Vertex 1 in the graph, see figure 1 -- example of a vertex in a
dataflow graph -- represents the execution of an event at agent
<code>u</code>.
This event is the execution of an event specified by the following
4-tuple:
<ol>
  <li>
  The state of \(u\) before the event is <code>u1</code>.
  </li>
  <li>
  The message received in the event is <code>m1</code> from agent
  <code>v</code>.
  </li>
  <li>
  The state  of \(u\) after the event is <code>u2</code>.
  </li>
  <li>
  A single message <code>m3</code> is sent in the event and this
  message is  sent to agent <code>v</code>.
  </li>
</ol>
</p>
<p>
The input and output edges of the vertex are the inputs and outputs
(respectively) of the event.
</p>
</div>
<!---------------END SECTION: Example ------------------------------>



<!-------------START SECTION: Computations and Dataflow ------------->
  <div ID="SECTION", class="ComputationsAndDataflow">
    <a name="ComputationsAndDataflow"></a>


<!---------------------------------------->
<h3 class="w3-text-teal">Flow of Data in a Computation</h3>
<p>
The edges of the dataflow graph of a computation show the flow of data
into and out of each event of a computation.
Data -- in the form of the agent's state -- flows from an event at an
agent to the next event at that agent in the computation.
Data -- in the form of message contents -- flows from an event in which
a message is sent to the event in which the message is received.
</p>

    <p>
    In a computation specified by a sequence of events \([e_{0},
    e_{1}, e_{2}, \ldots]\), we define a relation <i>depends on</i>
    between events as follows: \(e_{i}\) depends on \(e_{j}\) exactly
    when there is a path in the dataflow graph of the computation from
    \(e_{j}\) to \(e_{i}\).

    <p>
    Events \(e_{i}\) and \(e_{j}\) in the computation are
    <i>independent</i> exactly when neither event depends on the
    other, i.e., when there is no path from \(e_{i}\) to \(e_{j}\) and
    there is no path from \(e_{j}\) to \(e_{i}\).
</p>

  <!----------------------------------------------->
  <h6 class="w3-text-teal">Topological Sorts</h6>
<!----------------------------------------------->
<p>
A <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sort</a> of a directed acyclic graph is a sequence of
  vertices of the graph where for every edge \((x, y)\) in the graph,
    \(x\) appears before \(y\) in the sequence.
    </p>

    <p>
    An equivalent definition of a topological sort is a sequence of
    vertices of the graph where each vertex v appears in the sequence
    only after all vertices on which v depends.
    </p>

    <h5 class="w3-text-red">Examples</h5>
    <p>
    Figure 2, below, has two diagrams both of which show
    dataflow graphs identical to that in figure 1.
    The difference in the diagrams is the order in which vertices
    appear in the sequence from left to right.
    In figure 1, vertices appear from left to right in the sequence
    [1, 2, 3, 4].
    In the top diagram of figure 2, vertices appear from left to right
    in the sequence [2, 1, 3, 4], whereas in the lower diagram the
    sequence is [1, 2, 4, 3].
</p>
<p>
Sequences [1, 2, 3, 4] and [2, 1, 3, 4] are topological sorts of the
graph.
Topological sorts are sequences in which all edges are directed from
    earlier vertices in the sequence to later vertices in the sequence.
Sequence [1, 2, 4, 3] is not a topological sort because there is an
edge directed from a later vertex in the sequence (i.e, vertex 3) to
an earlier vertex (4) in the sequence.
</p>
<p>
Events 1 and 2 are independent because there is no path from either
    event to the other.
</p>
   <figure>
    <img
    src="Dataflow.007.jpeg"
    alt="Fig6" style="width:100%"> 
<figcaption>Figure 5: Examples of Sequences that are, and are not,
    topological sorts.
</figcaption>
</figure>



<a name="TheoremTopologicalSort">
<hr class="new2">
  <!----------------------------------------------->
  <h4 style="color:blue;">Theorem: Topological Sorts of Dataflow</h4>
<!----------------------------------------------->

<p style="color:blue;">
All topological sorts of a dataflow graph of a computation are
computations. 
</p>
<hr class="new2">
<p>
An equivalent statement of the theorem is as follows.
</p>
<p>
Let E = \([e_{0}, e_{1}, e_{2}, \ldots]\) be a sequence of events of a
computation, and let E' be a permutation of E.
Then E' is also a computation if
for all \(i\), event \(e_{i}\) appears in E' after all events
on which \(e_{i}\) depends.
</p>
<p>
To prove the theorem we start with the following observation.
</p>
<p class="w3-text-teal">Observation</p>
If E and E' are topological sorts, and x appears before y in E, and y
appears before x in E', then x and y are independent.


<h6 class="w3-text-teal">Lemma: Switching Order of Adjacent
Independent Events in a Computation</h6>
<p>
Let \(G\) be the dataflow graph of a computation specified by a sequence of
events \(E = [e_{0}, e_{1}, \ldots]\).
Let \(E'\) be a permutation of \(E\)
obtained by switching the order of a pair of adjacent elements
\(e_{i}, e_{i+1}\) in \(E\). 
If \(E'\) is a topological sort of \(G\) then \(E'\) is a computation.
</p>

<p class="w3-text-teal">Proof</p>
<p>
From the observation \(e_{i}\) and \(e_{i+1}\) are independent events,
and therefore they are at different agents.
</p>
<p>
Because \(e_{i}\) and \(e_{i+1}\) are independent, there is no message
sent in  \(e_{i}\) that is received in \(e_{i+1}\), and there is no message
sent in  \(e_{i+1}\) that is received in \(e_{i}\).
Therefore, the inputs to \(e_{i}\) remain unchanged if \(e_{i+1}\) is
executed before \(e_{i}\).
Likewise, the inputs to \(e_{i+1}\) remain unchanged if \(e_{i}\) is
executed after \(e_{i+1}\).
So \(E'\) is also a computation.

<h6 class="w3-text-red">Example of Switching Adjacent Independent
Events</h6>
The Figure "Example of Switching Adjacent Independent Events" shows two
diagrams with identical dataflow graphs. The upper and diagrams are 
representations of computations starting at the same state and event
sequences [1, 2, 3, 4], and [2, 1, 3, 4].
The order in which vertices 1 and 2 appear, from left to right, in the
diagrams have been switched.
The graphs, however, are identical.
<p>
The inputs to event 1 remain the same whether event 2 is executed
before or after event 1.
Likewise, the inputs to event 2 remain the same whether event 1 is executed
before or after event 2.

   <figure>
    <img
    src="Dataflow.006.jpeg"
    alt="Fig6" style="width:100%"> 
<figcaption>Figure Example of Switching Adjacent Independent Events
</figcaption>
</figure>


<h6 class="w3-text-teal">Proof of the Theorem</h6>
Let \(G\) be the dataflow graph of a computation specified by a
sequence of events \(E = [e_{0}, e_{1}, \ldots]\).
Let \(E'\) be a topological sort of \(G\).
We will prove that \(E'\) is also a computation.

<p>
The theorem holds trivially if \(E'\) and \(E\) are identical.
If \(E\) and \(E'\) are not identical then there exists an adjacent
pair of events \(e_{i}, e_{i+1}\) in \(E\) where \(e_{i+1}\) occurs
before \(e_{i}\) in \(E'\).
From the observation, these events are independent.
</p>

<p>
<p>
Let \(H\) be the sequence of events identical to \(E\) except that the
order of \(e_{i}\) and \(e_{i+1}\) is switched  in \(H\).
From the lemma \(H\) is also a computation.
The number of out of order pairs between \(H\) and \(E'\) is less than
that between \(E\) and \(E'\).
By repeatedly switching independent, adjacent, out-of-order pairs
the sequence \(E'\) is reached.
    </p>


<!-------------END SECTION: Computations and Dataflow ------------->



  <!----------------------------------------------->
  <h5 class="w3-text-teal">Relationship to Causality</h5>
<!----------------------------------------------->
Some articles use the relation "\(x\) causes \(y\)" instead of
"\(y\) depends on \(x\)" or
"data flows from \(x\) to \(y\)."

Causality and data flow have been widely used concepts for decades and
we will see the next pages how we use them to develop distributed
algorithms. 



</div>
<!--------------END SECTION: Dataflow ---------------------->

<!---------------------------------------->
<h5 class="w3-text-teal">Next</h5>
<!---------------------------------------->
The next pages describes
<p>
<a href="../ChannelSnapshots/Timelines.html">Cuts in Dataflow Graphs
</a>
which are used in developing detection algorithms such as termination
detection and deadlock detection.

<p>
<a href="ModelExamples.html">Examples</a>

<p>
<a href="ModelFAQ.html">Frequenty Asked Questions</a>

<p>
<a href="ModelReview.html">Review</a>


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    

<!-- END MAIN -->
</div>

</body>
</html>


