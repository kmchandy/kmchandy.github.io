<title>DistributedSystemModels/Models.html</title>


<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

<!-------------------------------------------------------------->
<h2 class="w3-text-teal">Data Flow in Computations</h2>
<!-------------------------------------------------------------->
  <p class="w3-text-red">
  A dataflow graph of a computation is a labeled directed acyclic
  graph that shows the flow of data between agents during the
  computation. 

  All <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sorts</a> of a dataflow graph are computations.
  </p>
 



  <!----------------------------------------------->
  <h4 class="w3-text-teal">Dataflow Graph</h4>
<!----------------------------------------------->


A dataflow graph of a computation is a labeled, directed, acyclic
  graph  that shows the flow of data between agents during the
  computation. 

  The vertices of the graph represent steps of the computation.

<!------------------------------->
<h6 class="w3-text-red">Example of a Vertex in a Dataflow Graph</h6>


   <figure>
    <img
    src="Dataflow.001.jpeg"
    alt="Fig11" style="width:100%"> 
    <figcaption>Figure Example of a Vertex in a Dataflow Graph</figcaption>
</figure>

  The edges of a dataflow graph are as follows.

  <ol>
  <li>
There is an edge from a step at an agent to the next step at that
agent; this edge is labeled with the state of the agent between the
events and is called an <i>agent edge</i>.
  </li>
  <li>
There is an edge from a step in which a message is sent
to the step at which the message is received; this edge is called a
  <i>message edge</i>. The edge is labeled with a pair \((m, w)\)
  where \(m\) is the message and \(w\) is the sender of the message.
  </li>
</ol>



<h5 class="w3-text-teal">Representing Initial and Final States by
Fictitious Steps</h5>
A computation is specified by its initial state and a sequence of
events.

For convenience, we represent the initial state of an agent \(u\) and
the initial states of \(u\)'s output channels be a fictitious step,
\(u_{init}\).

The vertex representing this step has no inputs.

<p>
The agent edge from this step is labeled with \(u\)'s initial state.

The message edges from this step to steps of an agent \(v\) are
labeled with the messages in the channel \((u, v)\) in the initial
state of the computation.



   <figure>
    <img
    src="Dataflow.003.jpeg"
    alt="Fig3" style="width:100%"> 
    <figcaption>Figure Example of an Initial Vertex of a Dataflow
    Graph </figcaption>
</figure>

The figure shows an example of an initial vertex, <code>u_init</code>
at agent <code>u</code> of a dataflow graph.

The vertex has an output agent edge labeled <code>u1</code> which is
the initial state of agent <code>u</code> in the computation.

The vertex has an output message edge labeled <code>m2</code>; this
edge is to a step in agent <code>v</code> and shows that the initial
state of the channel <code>(u, v)</code> consists of the single
message <code>m2</code>.


<p>
By symmetry, we use a fictitious step \(u_{fini}\) to represent the final
state of \(u\) and the final states of channels to \(u\).

With the introduction of fictitious initial and final steps for each
agent we can treat a computation as a sequence of steps where the
initial state is specified by initial steps.



   <figure>
    <img
    src="Dataflow.004.jpeg"
    alt="Fig4" style="width:100%"> 
    <figcaption>Figure Example of a Final Vertex of a Dataflow
    Graph </figcaption>
</figure>

<p>
We adopt the convention that agent edges are horizontal.

So, all edges of the same agent are on the same horizontal line.

<p>
We use <i>step</i> of a computation and <i>vertex</i> of its dataflow
graph interchangeably, with the meaning understood by context.



<!------------------------------->
<h6 class="w3-text-red">Example of a Dataflow Graph</h6>
   <figure>
    <img
    src="Dataflow.002.jpeg"
    alt="Fig2" style="width:100%"> 
    <figcaption>Figure Example of a Dataflow Graph</figcaption>
</figure>


<p>
The figure shows the dataflow graph for a computation of a
system consisting of two agents <code>u</code> and <code>v</code>, and
with two channels <code>(u, v)</code> and <code>(v, u)</code>.

The computation is defined by its initial state and event sequence [1,
2, 3, 4]. The initial states at agents <code>u</code> and
<code>v</code> are represented by outputs of steps <code>u_init</code>
and <code>v_init</code>, respectively, and final states by inputs to
<code>u_fini</code>
and <code>v_fini</code>, respectively.

<p>
The top horizontal edges represent data flow between steps at agent
<code>u</code> and the lower horizontal edges represent data flow
between steps at agent <code>v</code>.

For example, the labels <code>u1, u2, u3</code> are the initial state
of agent <code>u</code>, the state of <code>u</code> between steps 1
and 4, and the state of <code>u</code> after step 4, respectively.

Likewise, the labels <code>v1, v2, v3</code> are the states of
agent <code>v</code> initially and after steps 2 and 3, respectively.


<p>
Message edges are labeled <code>m1, m2, m3, m4, m5</code>.

Initially channel <code>(u, v)</code> contains message <code>m2</code>
and channel <code>(v, u)</code> contains message <code>m1</code>.

Message <code>m3</code> is sent in step 1 and received in step 3, and
message <code>m4</code> is sent in step 3 and received in step 4.

<p>
Vertex 1 in the graph, see figure 1 -- example of a vertex in a
dataflow graph -- represents the execution of a step at agent
<code>u</code>.
This step is the execution of an event specified by the following
4-tuple:
<ol>
  <li>
  The state of \(u\) before the event is <code>u1</code>.
  </li>
  <li>
  The message received in the event is <code>m1</code> from agent
  <code>v</code>.
  </li>
  <li>
  The state  of \(u\) after the event is <code>u2</code>.
  </li>
  <li>
  A single message <code>m3</code> is sent in the event and this
  message is  sent to agent <code>v</code>.
  </li>
</ol>

The input and output edges of the vertex are the inputs and outputs
(respectively) of the event.




<h6 class="w3-text-teal">Dataflow Graphs are Acyclic</h6>
A dataflow graph of a computation is acyclic because each edge is directed from a step
to a later step of the computation.

<!---------------------------------------->
<h4 class="w3-text-teal">Flow of Data in a Computation</h4>
The edges of the dataflow graph of a computation show the flow of data
into and out of each step of a
computation.

Data -- in the form of the agent's state -- flows from a step of an
agent to the next step at that agent.

Data -- in the form of message contents -- flows from a step in which
a message is sent to the step in which the message is received.

<h6 class="w3-text-teal">The Relation: "data flows from" between Steps
of a Computation</h6>
We define a relation "data flows from" between steps of a
computation 
as follows: for steps \(x, y\) of a computation, data flows from
\(x\) to \(y\) exactly when there is a path in the computation's
dataflow graph from \(x\) to \(y\).


<p>
The set of steps of a computation with the relation "data flows from"
is a
<a
href="https://en.wikipedia.org/wiki/Partially_ordered_set#Partial_order">
strict partial order</a>.

We say that steps \(x\) and \(y\) are <i>independent</i> if data does
not flow from  \(x\) to \(y\) or from \(y\) to \(x\).

<h6 class="w3-text-red">Example of data flows from a step to a
step</h6>

The figure "Example -- Data Flows from Step 2 to Step 4" shows
examples of data flow as red edges in the graph.

Steps 1 and 2 are independent because there is no path from step 1 to
step 2, and there is no path from step 2 to step 1.

   <figure>
    <img
    src="Dataflow.005.jpeg"
    alt="Fig5" style="width:100%"> 
    <figcaption>Figure Example -- Data Flows from Step 2 to Step 4</figcaption>
</figure>

  <!----------------------------------------------->
  <h3 class="w3-text-teal">Computations and Dataflow Graphs</h3>
<!----------------------------------------------->

Let a computation be specified by a sequence of steps \(E\), and
let \(E'\) be any permutation of \(E\).


<i>Data flows forwards in \(E\)</i> means that for all steps
\(x\) and \(y\) in \(E\):
<center>
If data flows from \(x\) to \(y\) in \(E\)
then \(x\) appears before \(y\) in
\(E'\). 
</center>

<p>
Next we prove properties about sequences of steps in which data flows forwards.

We start with the following lemma.



<h5 class="w3-text-teal">Lemma: Switching Order of Adjacent
Independent Steps in a Computation</h5>

Let a computation be specified by  a sequence of
steps \(E\), and let \(E'\) be any permutation of \(E\)
obtained by switching the order of a pair of adjacent elements in
\(E\). 

If data flows forward in \(E'\) then \(E'\) is a computation.

<p class="w3-text-teal">Proof</p>

Assume that the order of adjacent steps \(e_{i}\) and \(e_{i+1}\) are
switched in \(E\) to get \(E'\).

Because \(e_{i}\) precedes \(e_{i+1}\) in \(E\) there is no data flow
from \(e_{i+1}\) to \(e_{i}\).
Because data flows forwards in \(E'\) there is no data flow from
\(e_{i}\) to \(e_{i+1}\).

<p>
Therefore \(e_{i}\) and \(e_{i+1}\) are adjacent independent steps.
So, the inputs to \(e_{i}\) and \(e_{i+1}\) remain the same
regardless of the order in which they are executed, and so \(E'\) is
also a computation.

<h6 class="w3-text-red">Example of Switching Adjacent Independent
Steps</h6>
The Figure "Example of Switching Adjacent Independent Steps" shows two
diagrams with identical dataflow graphs. The upper and diagrams are 
representations of computations starting at the same state and step
sequences [1, 2, 3, 4], and [2, 1, 3, 4].
The order in which vertices 1 and 2 appear, from left to right, in the
diagrams have been switched.
The graphs, however, are identical.
<p>
The inputs to step 1 remain the same whether step 2 is executed
before or after step 1.
Likewise, the inputs to step 2 remain the same whether step 1 is executed
before or after step 2.

   <figure>
    <img
    src="Dataflow.006.jpeg"
    alt="Fig6" style="width:100%"> 
<figcaption>Figure Example of Switching Adjacent Independent Steps
</figcaption>
</figure>

<hr class="new2">
<h5 style="color:blue;">Theorem: Permutations of Computations in which
Data Flows Forwards</h5>
<p style="color:blue;">
Given a computation specifed by a sequence of
steps \(E\), all permutations of \(E\) in which data flows forwards
are also computations.
</p>
<hr class="new2">



<h5 class="w3-text-teal">Proof</h5>
Let \(E'\) be a permutation of \(E\) where data flows forwards in
\(E'\).

The theorem holds trivially if \(E\) and \(E'\) are identical.

<p>
If \(E\) and \(E'\) are not identical then there exists an adjacent
pair of steps \(x, y\) in \(E\) where \(x\) occurs before \(y\) in
\(E\), and \(y\) occurs before \(x\) in \(E'\).

<p>
Because \(E\) is a computation, data flows forwards in \(E\) and
therefore there is no data flow from \(y\) to \(x\).

<p>
We are given that data flows forwards in \(E'\). So there is no
data flow from \(x\) to \(y\).


<p>
Therefore \(x\) and \(y\) are independent.
Let \(H\) be the sequence of steps obtained from \(E\) by switching
the order of \(x\) and \(y\).

From the lemma "Switching Order of Independent Adjacent Steps" it
follows 
that \(H\) is also a computation.

<p>
The number of out of order pairs between \(H\) and \(E'\) is less than
that between \(E\) and \(E'\).

By repeatedly switching of independent adjacent out of order pairs
the sequence \(E'\) is reached.





  <!----------------------------------------------->
  <h4 class="w3-text-teal">Relationship to Topological Sorts</h4>
<!----------------------------------------------->
The theorem on permutations of event sequences can be expressed in
terms of topological sorts.

A <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sort</a> of a directed acyclic graph is a sequence of
  vertices of the graph where for every edge \((x, y)\) in the graph,
\(x\) appears before \(y\) in the sequence.


<hr class="new2">
  <!----------------------------------------------->
  <h4 style="color:blue;">Theorem: Topological Sorts of Dataflow</h4>
<!----------------------------------------------->

<p style="color:blue;">

All topological sorts of a dataflow graph are computations.
</p>
<hr class="new2">




<!---------------------------------------->
<h5 class="w3-text-teal">Next</h5>
<!---------------------------------------->
The next pages describes
<p>
<a href="Timelines.html">Cuts in Dataflow Graphs
</a>
which are used in developing detection algorithms such as termination
detection and deadlock detection.

<p>
<a href="ModelExamples.html">Examples</a>

<p>
<a href="ModelFAQ.html">Frequenty Asked Questions</a>

<p>
<a href="ModelReview.html">Review</a>


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>


