<title>DistributedSystemModels/DistributedSystemModels.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!---------------------------------------------------------------->
    <h1 class="w3-text-teal">A Model of a Distributed System</h1>
<!----------------------------------------------------------------->
  

  
  </p>

  <p class="w3-text-red">
  <i>
  A model is an abstraction that helps in developing algorithms.
  A model of a distributed system is defined by its components,
  states, and state transitions. The components of a distributed
  system are its agents and communication channels.
  </i>
  </p>


<!-------------------------------------------------------------->
<h3 class="w3-text-teal">System Trajectories</h3>
<!-------------------------------------------------------------->

The state of a distributed system is a tuple with an element of the
  tuple for each of its agents and channels.

We analyze distributed systems such as the electrical power grid by
  studying properties of its trajectories --  its states as
  a function of time. 

  Let's look at the trajectory of a system described in the
  <a href="Basics.html">previous page</a>.


  <p>
Figure 1 shows a trajectory of a system with two agents \(u\) and
  \(v\) and channels between them.

The horizontal axes represent time flowing from left to right.

There is a timeline for each agent that shows the state of the agent
  at each point in time.

<p>
The state of an agent \(u\) at time \(t\) is represented by a point
  \(t\) units to the right of the origin on \(u\)'s timeline.

A message sent at time \(t\) by an agent \(u\) and received at
  time \(t'\) be an agent \(v\) is represented by a line from point
  \(t\) on \(u\)'s timeline to point \(t'\) on \(v\)'s timeline.

The state of the system at time \(t\) is shown diagramatically by the
  vertical line at \(t\).

<figure>
    <img
    src="DistributedSystemModels/DistributedSystemModels.008.jpeg"
    alt="Fig1" style="width:100%"> 
    <figcaption>Fig.1: Example: A System Trajectory</figcaption>
</figure>


Next we describe a simple model that deviates from the distributed
system described on the <a href="Basics.html">previous page</a> in
several ways.

The model is adequate for reasoning about many
algorithms though it cannot represent  trajectories.



<!-------------------------------------------------------------->
<h3 class="w3-text-teal">The Model</h3>
<!-------------------------------------------------------------->

<p>
The model does not deal with states of an agent while it is executing
a <code>receive</code> command.

The model only represents states of an agent before the agent
begins, and after it completes, executing  a <code>receive</code>.

States are determined only when all agents are idle.


<p>
The model is sequential -- at most one agent executes a
<code>receive</code> at a time while all other agents remain idle.

A state transition occurs when one, and only one, agent receives and
completes processing a message by executing a <code>receive</code>.

<p>
A <i>computation</i> is a sequence of one or more states where there
exists a transition from each state in the sequence to the next state
in the sequence.

The model of execution is: While there exists a nonempty channel,
select any one agent with a nonempty channel and execute a
<code>receive</code> on that agent.




<!-------------------------------------------------------------->
<h3 class="w3-text-teal">Events</h3>
<!-------------------------------------------------------------->

The change in state caused by an execution of a <code>receive</code> by
an agent \(v\) is specified by an <i>event</i> which is the 4-tuple:
<ol>
  <li>
  the state of \(v\) before it executes <code>receive</code>,
  </li>
  <li>
  the message received and the channel on which it is received,
  </li>
  <li>
  the state of  \(v\) after it completes execution of the
  <code>receive</code>, and  
  </li>
  <li>
  for each output channel of <code>v</code>, the sequence of messages
  sent on the channel during execution of the <code>receive</code>.
  </li>
</ol>
The states of agents other than \(v\) remain unchanged by the
transition.

The channels other than those listed in the event also remain
unchanged.

<p>
In any system state transition from \(S\) to
\(S'\) specified by an event \(e\), the post-transition state \(S'\)
is uniquely determined by the pre-transition state \(S\) and the event
\(e\). 

<!---------------------------------------------------------------->
<h4 style="color:red;">Example of a Simple Distributed System</h4>
<!---------------------------------------------------------------->

This example system has two agents <code>u</code> and <code>v</code>.

The system has channels in both directions between the agents and also
from each agent to itself.

The system has one blue token and one red token.

Agents send tokens to each other.

A token is either at an agent or in a channel.

Later, when we discuss file management, we will use a token to
represent exclusive access to a file and use the token color to
identify the file. 


<p>
The diagram in figure 2 shows two states, \(S_{0}\) and \(S_{1}\), and
a transition from \(S_{0}\) to \(S_{1}\).

The diagram at the left of the figure shows a system state in
which agent \(u\) holds the blue token, agent \(v\) holds the red
token, channels \((u, v)\) and \((v, u)\) are empty, and channels
\((u, u)\) and \((v, v)\) each contain a wakeup message.


 
    <figure>
    <img
    src="DistributedSystemModels/DistributedSystemModels.002.jpeg"
    alt="Fig1" style="width:100%"> 
    <figcaption>Fig.2: Example: State Transition</figcaption>
</figure>

<p>
The diagram at the right shows a system state in
which \(u\) holds no tokens, \(v\)  holds the red
token, channel \((u, v)\) has the blue token, channels \((u, u)\) 
and \((v, u)\) are empty, and channel \((v, v)\) contains a wakeup
message.


<p>
The function <code>receive</code> below is self explanatory.
It is written to be easy to read rather than for efficiency.
Assume that in the code for agent \(u\), <code>other_agent</code> is
\(v\).
Likewise, in the code for agent \(v\), <code>other_agent</code> is
\(u\).
We postpone discussion of the notation used for creating the system.

<pre>
def receive(message, sender):
   if sender == other_agent:
       // message is a token
       list_of_tokens_I_hold.append(message)
   else:
       # Sender is me. Message is wakeup.
       # Send any token I hold.
       token_I_hold = tokens_held.pop()
       send(token_I_hold, other_agent)

   # If I hold a token then wake me up later.
   if len(list_of_tokens_I_hold) > 0:
          send(wakeup, me)
</pre>

<p>
The event corresponding to the state transition is specified by the
state of \(u\) before the transition (\(u\) holds blue token), the
message <code>wakeup</code> that \(u\) receives on channel \((u, u)\),
the state of \(u\) after the transition (\(u\) holds no tokens), and
the message (blue token) sent by \(u\) along output channel \((u,
v)\).
The figure below illustrates the event.

    <figure>
    <img
    src="DistributedSystemModels/DistributedSystemModels.003.jpeg"
    alt="Fig1" style="width:100%"> 
    <figcaption>Fig.3: Example: Representation of an Event</figcaption>
</figure>



<!-------------------------------------------------->
<h3 class="w3-text-teal">Computation</h3>
<!-------------------------------------------------->

<p>
The directed graph in which vertices are states and edges represent
state transitions is called the <i>state transition graph.</i>.

A computation is a path in the state transition graph.

A computation may start in any state and be finite or infinite.


<!----------------------------------------------------------->
<h4 style="color:red;">Example: State Transition Graph</h4>

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.004.jpeg"
    alt="Fig4" style="width:100%"> 
    <figcaption>Fig.4: Example of State Transitions</figcaption>
</figure>


<p>
Figure 4 shows a part of the state-transition graph for the
token-passing example.

Not all states are shown.

Channels from each agent to itself aren't shown so as to reduce
cluttering.

There is a <i>wakeup</i> message in the channel from an agent to
itself if the agent holds a token.

For example, in the diagram in the top left, there is a wakeup message
from each agent to itself because each agent holds a token.

A state transition in the diagram is labeled with the channel on
which the message is received that caused the transition.


<!----------------------------------------------------------->
<h4 style="color:red;">Example: Computation</h4>
<!----------------------------------------------------------->

An example of a computation is the sequence \([S_{0}, \ldots S_{8}]\)
of states shown in figure 5 as a path in the state transition graph of
figure 4. 


<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.005.jpeg"
    alt="Fig5" style="width:100%"> 
    <figcaption>Fig.5: Example - A Computation is a Path in the State Graph</figcaption>
</figure>



<!---------------------------------------------------------------->
<h3 class="w3-text-teal">Event Graph of a Computation</h3>
<!---------------------------------------------------------------->
Associated with a computation is a labeled, directed graph, called an
event graph in which vertices represent events of the computation.

Edges connect outputs of events to inputs of events (figure 3).


<p>
The graph has an edge from an event at an agent to the next event at
that agent; this event is labeled with the state of the agent between
the events and is called an agent edge.

The graph has an edge from each event in which a message is sent to
the event in which that message is received; this edge is labeled with
the message, and is called a message edge.

<p>
A diagram of a computation is similar to that of a trajectory except
that the only concept of time in a computation is that some events
occur before others.

<!---------------------------------------------------------------->
<h4 style="color:red;">Example: Event Graph</h4>
<!---------------------------------------------------------------->
The computation of figure 5, is represented as an event graph with
later events in the computation appearing to the right of earlier
events. 

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.006.jpeg"
    alt="Fig6" style="width:100%"> 
    <figcaption>Fig.6: Example - A Computation and its Event Graph</figcaption>
</figure>


The top line in figure 6 shows the timeline -- the sequence of events
-- on agent \(u\) and the lower line shows the timeline for \(v\).

Events \(0\) and \(N\) represent the initial and final states of the
computation.

The outputs of events numbered \(0\) are the initial states of agents
and message channels, and the inputs of events labeled \(N\) are their
final states.

Let's look at the representation of event 1, shown in figure 3, as it
apears in figure 6.

<p>
Event 1 is at agent \(u\).

The inputs to event 1 are the state of \(u\) before the event and the
message <code>wakeup</code> received by \(u\) on channel \((u, u)\).

The outputs of event 1 are the state of \(u\) after the event and the
message <code>blue token</code> sent by \(u\) on channel \((u, v)\).

Before the event \(u\)'s state is that it holds the blue token.

After the event \(u\)'s state is that it holds no tokens show in the
figure by the letter "e" for empty.



<!---------------------------------------------------------------->
<h3 class="w3-text-teal">Event Graphs in Computations and Trajectories</h4>
<!---------------------------------------------------------------->
The 4-tuple specification of an event is independent of the duration
of the event.

The next figure shows a trajectory in which agent \(v\) executes
multiple receives while agent \(u\) is executing a single receive.

The event graph of a trajectory is specified in the same way as that
of a computation.

A vertex represents an event -- an execution of a single
<code>receive</code>.

Edges and labels are the same as in a computation.


<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.006.jpeg"
    alt="Fig6" style="width:100%"> 
    <figcaption>Fig.6: Example - A Computation and its Event Graph</figcaption>
</figure>



<p>
Given any trajectory, there is a computation with the same event graph
as the trajectory.

The computation can be obtained from the trajectory by making executions of
<code>receive</code> instantaneous in the trajectory.


<p>
The sets of event graphs of trajectories and computations of a system
are identical.

<p>
For the next section of this website we focus on event graphs and not
on trajectories.

The next page tells us why we can focus on event graphs rather than computations.



<h4 class="w3-text-teal">Predecessors of Vertices</h4>

In graph theory, a vertex \(e\) is a
<a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">
predecessor
</a>
of a vertex \(e'\) exactly when there is a path in the graph from
\(e\) to \(e'\).

An event graph is acyclic because edges are directed from events
to later events.

So, the predecessor relation is a
<a href="https://en.wikipedia.org/wiki/Partially_ordered_set">
partial order.
</a>

A subgraph is <i>predecessor closed</i> exactly when all predecessors
of vertices in the subgraph are in the subgraph.


<!---------------------------------------------------------------->
<h5 style="color:red;">Example: Predecessors of Vertices</h5>

Event 0 represents the initial state of the entire
system; so it represents all vertices labeled 0.

Similarly event \(N\) represents the final state of the system.

Events 0, 1, 2 are predecessors of event 5 in figure 6.

Events 3, 4, 5, 6 are not predecessors of event 5.


<p>
Examples of subgraphs that are predecessor closed are \(\{0, 1\}\),
\(\{0, 2\}\), and  \(\{0, 1, 2, 5\}\).

An example of a subgraph that is not predecessor closed is \(\{0, 1,
3\}\) because there is an edge to vertex \(3\) from vertex \(2\) which
is not in the subgraph.



<!----------------------------------------------------------------->
<h4 class="w3-text-teal">System States and the Event Graph</h4>
<!----------------------------------------------------------------->

Let \(past\) be a predecessor-closed subgraph of an event
graph and let \(future\) be the subgraph consisting of vertices that
are not in \(past\).

The reason for our choice of these names will become clear shortly.

We associate a system state \(S\) with \(past\) where \(S\) is
defined by the labels of edges from \(past\) to \(future\).

<p>
The state of an agent \(u\) in \(S\) is the label of the \(u\)
edge from a vertex in \(past\) to a vertex in \(future\).

The state of a channel \((u, v)\) in \(H\) is the sequence of labels
of \((u, v)\) edges from vertices in \(past\) to vertices in
\(future\).


<!------------------------------------------------------------------>
<h4 style="color:red;">Example: State associated with a Subgraph</h4>
<!------------------------------------------------------------------>

<p>
Let's look at how system state \(S_{3}\) associated with the
predecessor-closed subgraph consisting of vertices 0, 1, 2, 3.

Here \(past = \{0, 1, 2, 3\}\) and \(future = \{4, 5, 6\}\).

The edges from \(past\) to \(future\) are the edges that cross the
boundary -- the vertical line -- between \(past\) to \(future\).

<p>
A vertical line between events 3 and 4 intersects the agent edge for
\(u\) at an edge with label "e"; so, \(u\) holds no tokens in
\(S_{3}\).

The line intersects the edges for channel \((v, u)\) at a single edge
and that edge has label "red token" and so the state of the \((v, u)\)
in \(S_{3}\) is a sequence of messages consisting of a single message
-- the red token.

The line does not intersect an edge for the channel \((u, v)\), and so
the state of this channel is the empty sequence of messages.

The states of other agents and channels are determined similarly.


<p>
The state \(S_{i}\) that occurs in a computation after events \(0,
\ldots, i\) is shown in figure 7. 


<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.007.jpeg"
    alt="Fig6" style="width:100%"> 
    <figcaption>Fig.7: Example - System States in the Event Graph</figcaption>
</figure>



<!------------------------------------------------------------------>
<h4  class="w3-text-teal">
Theorem: State Transitions 
</h4>
<!------------------------------------------------------------------>
Let \(past\) be a closed subgraph of an event graph \(G\), and let
\(future\) be the subgraph consisting of vertices in \(G\) that are
not in \(past\).

Let \(e\) be an event in \(future\).

Let \(next\) be the subgraph with vertex \(e\) and the vertices in
\(past\). 

If \(next\) is closed then there is a transition from the state
associated with \(past\) to the state associated with \(next\).

<p>
For example there is a transition from the state associated with
\(past\) to the state associated with \(next\) where \(past = \{0, 1,
2, 5\}\),\(next = \{0, 1, 2, 5, 3\}\), and where \(past = \{0,
\ldots i\}, next = \{0, \ldots, i, i+1\}\), for all \(i\) in figure
7.

<p  class="w3-text-teal">
Proof
</p>
The state associated with \(past\) is determined by the labels of
edges from \(past\) to \(future\), and these edges include the edges
from \(past\) to \(e\).

So, event \(e\) can occur after events in \(past\) have been executed.

Therefore there is a transition from the state associated with
\(past\) to the state associated with \(next\).





<!------------------------------------------------------------------>
<h4 style="color:red;">Example: State Transitions</h4>
<!------------------------------------------------------------------>

<p>
Let \(Q\) be the sequence of events \([0, 2, 1, 5, 3, 4, 6]\).

The subgraph consisting of the first \(i\) events of \(Q\) is
predecessor closed for all \(i\).

So, there is a transition from the state associated with the subgraph
consisting of the first \(i\) events of \(Q\) to that associated with
the first \(i+1\) events.

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.009.jpeg"
    alt="Fig" style="width:100%"> 
<figcaption>
Fig.7: Example - State Transition
</figcaption>
</figure>
Let's look at the transition from \(\{0, 2, 1, 5\}\) to \(\{0, 2, 1,
5, 3\}\).

The state \(S'_{3}\) corresponding to \(\{0, 2, 1, 5\}\) is given by
the labels of edges that cross the vertical line after event \(5\) and
before event \(3\).

These edges include the message edge from \(1\) to \(3\) and the agent
edge from \(2\) to \(3\).

Therefore event \(e\) can occur in this state, and there is a
transition from \(S'_{3}\) to \(S'_{4}\).



<!------------------------------------------------------------------>
<!------------------------------------------------------------------>
<h4 class="w3-text-teal">Theorem: Computations with the same
Event Graphs</h4>
<!------------------------------------------------------------------>
<!------------------------------------------------------------------>

Let \(G\) be an event graph of a computation starting in a state
\(S\).

Any sequence of events of \(G\), where
<center>
<i>
each event \(e\) in the sequence appears after all its predecessors
</i>
</center>
is also a computation starting in \(S\).

<p>
The theorem can also be stated in the following ways.
<ol>
  <li>
  A sequence of events of \(G\) is a computation starting
  in \(S\) if for all edges \((e, e')\) of the graph, \(e\) appears
  before \(e'\) in the sequence.
  </li>
  <li>
  All
  <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sorts
  </a>
  of \(G\) are computations starting in \(S\).
  </li>
</ol>

<p class="w3-text-teal">Proof</p>
The proof follows directly from the previous theorem.



<!---------------------------------------------------------------->
<h4 style="color:red;">Examples of Computations with the same Event
Graph</h4> 
<!---------------------------------------------------------------->
Some examples of event sequences of computations with the same event
graph are \([0, 1, 2, 3, 4, 5, 6]\), \([0, 2, 1, 3, 4, 5, 6]\),
 \([0, 2, 1, 3, 4, 5, 6]\), and  \([0, 1, 2, 3, 5, 4, 6]\).


<h5 class="w3-text-teal">Extending the Model to Different Channel types</h5>

The model can be extended to communication mechanisms other than
first-in-first-out channels.

Later, we will describe algorithms in which messages may be lost and
in which messages may be delivered out of order.

Extending the model to more than one channel from one agent to another
is straightforward.

<h3 class="w3-text-teal">Model Limitations</h3>


<p class="w3-text-teal">Progress</p>
The model allows for an infinite computation in which an agent forever
processes messages that it sends itself, while other agents starve.
The model also allows for messages to be delayed on a channel forever.
Later, we extend the model to include the temporal logic concepts of
<i>eventually</i> and <i>fairness</i> and prove that computations progress
towards a goal.

<p class="w3-text-teal">No construct for Time</p>
Processes can maintain accurate clocks by using
inexpensive atomic clocks on PC boards, Precision Time
Protocols (PTP) in local area networks, and Network Time Protocol
(NTP) servers.
The absence of time is a limitation of the model.
We will discuss the use of time in
algorithms.




<p class="w3-text-teal">Failure</p>
The model does not deal with failure of agents or channels.
Dealing with failure is essential in distributed systems.
We discuss failure modes later.

<h4 class="w3-text-red">
<i>Central Ideas: Summary</i></h4>

<p class="w3-text-red">
A state of the system is given by the states of its components -- agents
and communication channels.

The state of a channel is the sequence of messages in transit along
the channel.

An agent is either idle (waiting to process a message) or active (processing a
message).

An agent may send messages while it is executing an action.

A state transition occurs when a single agent receives and processes a
message.

A computation is a sequence of states where there is a transition from
each state to the next.

An event graph is a labeled directed acyclic graph in which vertices
represent events.






<p class="w3-text-red">
<i>Concepts</i>:
 Distributed system, agents and channels -> system states as tuples -> state
transitions -> computations.


<h3 class="w3-text-teal">Next</h3>
Next look at
<a href="Timelines.html">Timelines of Computations.</a>
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
