<title>Timelines.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

  
<!--------------------------------------------------------->
<h1 class="w3-text-teal">Causality Graphs and Cuts</h1>
<!--------------------------------------------------------->

  <p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/DISTRIBUTED_SYSTEM_MODELS/DistributedSystemModels.html">
  Distributed System Models.</a>
  </p>

  <!------------------------------------------------------------------->
  <h4 class="w3-text-red">
  <i>Central Ideas</i></h4>

  <p class="w3-text-red">
  (1) Causality graphs of computations. (2) Consistent cuts of
  causality graphs.
  </p>
  
  <p class="w3-text-red">
  <i>Causality graphs and consistent cuts of computations are the
  foundation of many distributed algorithms.</i> 


  <!---------------------------------------------------------------->
  <h2 class="w3-text-teal">A Timeline Representation of a Trajectory</h2>
  <!---------------------------------------------------------------->
A timeline of a trajectory shows the system state at each point in the
  trajectory.

  By convention, time flows from left to right.
  
  Each agent has a horizontal line showing the state of the agent as
  a function of time; this line is called the agent's timeline.

  A message sent by an agent \(u\) at time \(t\) and received by an agent
  \(u'\) at time \(t'\) is represented by a line from \(u\)'s timeline
  at point \(t\) to \(u'\)'s timeline at point \(t'\).

  where the m
  There is a line from the time a
  
  <!---------------------------------------------------------------->
  <h2 class="w3-text-teal">Dependence Relation</h2>
  <!---------------------------------------------------------------->
  The output of an action is dependent on its inputs, which are, in
  turn, outputs of other actions.
  The dependence of actions is represented by a dependence graph.

  <p>
  The dependence graph of a computation is a labeled, directed graph
  in which vertices represent actions of the computation.
  The graph has an edge from the action taken by an agent to the next action taken 
  by that agent; this action is labeled with the state of the agent
  between the actions. 
  The graph has an edge from each action in which a message is
  sent to the action in which that message is received; this edge is
  labeled with the contents of the message.
  
  The graph is acyclic because each edge is from an earlier action in
  the computation to a later action.

  We define the dependence relation between actions in the computation
  as follows: action \(v\) is dependent on action \(v'\) exactly when
  there is a path in the dependency graph from \(v\) to \(v'\).
  

  ; this edge is called an agent edge and is labeled with
  the state of the agent between the actions.
 
  <!---------------------------------------------------------------->
  <h2 class="w3-text-teal">A Timeline Representation of a Computation</h2>
  <!---------------------------------------------------------------->
  A timeline of a computation is a graphical representation of the
  computation.
  A timeline is a labeled, directed graph and a total ordering of the vertices of the
  graph.
  The vertices of the graph represent actions by agents.

  <p>
  The graph has an edge from each (vertex representing an) action taken by the agent to the next action taken
  by the agent; this edge is called an agent edge and is labeled with
  the state of the agent between the actions.
  The graph has an edge from each action in which a message is
  sent to the action in which that message is received; this edge is
  called a message edge and is labeled with the contents of the message.

  <p>
  Actions are ordered in the order in which they occur in the
  computation with
  later actions placed to the right of earlier actions.
  Actions by the same agent are placed on the same horizontal line.
  

  

<!--------------------------------------------------------------------------->
  <h5 style="color:red;">Example: Timeline of a Computation</h5>
  <!--------------------------------------------------------------------------->
<p>
Figure 1 shows a computation \([S_{0}, S_{1}, \ldots, S_{6}]\) at the top and
  the timeline of the computation at the bottom.
  The computation is from the example on the previous
<a href="DistributedSystemModels.html">
page on distributed system models.
</a>
</p>
The system has two agents \(u\) and \(v\), and channels between them,
and channels from each agent to itself.
The system has a blue token and a red token (shown as squares).
The agents exchange tokens.

  </figure>

    <figure>
    <img src="Timelines/Timelines.001.jpeg" alt="Fig001" style="width:100%">
    <figcaption>Fig.1: Example: A Computation and its Timeline</figcaption>
</figure>

<p>
The transition from \(S_{0}\) to \(S_{1}\) occurs when agent \(u\)
executes an action.
The action is specified by vertex 1 and its input and output edges.
Next, we look in detail at the representation of this state transition
in a timeline.
Figure 2 shows the state transition.

 
  <figure>
    <img src="Timelines/Timelines.002.jpeg" alt="Fig001" style="width:60%">
    <figcaption>Fig.2: Example: A State Transition</figcaption>
</figure>

The specification of the action that causes the transition is as follows.

<p>
<i>Inputs to the action</i>
<ol>
  <li>
  State of \(u\) before receiving the message: Holds blue token.
  <br>
  This is the label of the agent edge directed towards the vertex.
  </li>
  <li>
  Message "wakeup" received on channel \((u, u)\).
  <br>
  This is the label of the message edge directed towards the vertex.
  </li>
</ol>
<p>
<i>Outputs of the action</i>
<ol>
  <li>
  Messages sent by the action: Blue token sent on edge \((u, v)\).
  <br>
  This is the label of the message edge directed from the vertex.
  </li>
  <li>
  State of \(u\) after the action.
  <br>
  This is the label of the agent edge directed from the vertex.
  </li>
</ol>

The representation of the action as a vertex is shown below. The inputs to the
  action are the labels of the edges directed towards the vertex, and
  the outputs of the action are the labels of the edges directed away
  from the vertex.
  <figure>
    <img src="Timelines/Timelines.003.jpeg" alt="Fig001" style="width:60%">
    <figcaption>Fig.3: Example: Timeline Representation of an Action</figcaption>
</figure>


gets a wakeup message from itself.
The action 
The specification to the action is
as follows:
  
  <!---------------------------------------------------------------->
  <h2 class="w3-text-teal">The Causality Graph of a Computation</h2>
  <!---------------------------------------------------------------->

  <p>
  A <i>causality graph of a computation</i> is a labeled, directed, acyclic
  graph.
  Each vertex of the graph represents an action taken by an
  agent in the computation.
  In addition, the start and end states of the computation are
  represented by a start vertex and end vertex for each agent.
  <p>
  The edges of the graph are as follows.
  <ol>
    <li>
    <i>Agent Edges</i>:
    For each agent, the graph has an edge
    <ol>
      <li>
      from each action taken by the agent to the next action taken
    by the agent,
      </li>
      <li>
      from the start vertex to the first action of the agent,
      </li>
      <li>
      from the last action of the agent to the end vertex.
      </li>
    </ol>
    The agent edges to and from an action are labeled with the states of the
  agent immediately before and immediately after the action (respectively).
    </li>
    <li>
    <i>Message Edges</i>:
    The graph has an edge for each message sent or received in the
  computation. A message edge is labeled with the message.
  A message edge is directed from an action in which the
    message is sent to the action in which the message is
    received.
    Messages in channels in the initial state of the
    computation are represented by message edges from the start vertex.
    Likewise, messages in channels in the final state of the
    computation are represented by message edges to the end vertex.
    </li>
  </ol>

  
  <!--------------------------------------------------------------------------->
  <h5 style="color:red;">Example: Causality Graph of a Single Step of a
  Computation</h5>
  <!--------------------------------------------------------------------------->
  
  This example is the same as that in the previous page
  <a href="DistributedSystemModels.html">Distributed System
  Models</a>.
  A system with agents \(u\) and \(v\) has a blue token and a red
  token.
  The state of the system is specified by the locations of the tokens.
  Figure 1 shows a single step of a computation.
 
  
  <figure>
    <img src="Timelines/Timelines.001.jpeg" alt="Fig001" style="width:60%">
    <figcaption>Fig.1: Example: A Step in a Computation</figcaption>
  </figure>



Figure 2 shows the causality graph of the computation consistng of the
  single step shown in
  figure 1.
  The causality graph has start and end vertices, and a single vertex
  representing execution of an action by agent \(u\).
  The input and output edges to this vertex are labeled with
  \(u\)'s state before and after execution of the action.
The vertex has an output message edge labeled with the message that is
  sent by the action.



  
    <figure>
    <img src="Timelines/Timelines.002.jpeg" alt="Fig001" style="width:75%">
    <figcaption>Fig.2: Example: A Causality Graph of the Computation</figcaption>
  </figure>



<h5 class="w3-text-teal">Representation of an Action in the Causality Graph</h5>
  Actions are represented as edges in a state-transition graph, but as
  vertices in a causality graph.
  States are represented as vertices in a state-transition graph, but as
  edges in a causality graph.
  <p>
Each vertex \(v\) in a causality graph of a computation represents a step of a computation
due to the execution of an action \(a\) by an agent \(x\).
When \(v\) represents an action \(a\) executed by an agent \(x\),
the states of \(x\) before and after the transition are given by the
labels of the agent edges into and out of \(v\), respectively.
The messages received in the action are given by the labels of
the input message edges of \(v\).
Likewise, the messages sent in the action are given by the labels of
the output message edges of \(v\).


<p class="w3-text-teal">Conventions in Diagrams of Computations</p>
We adopt the following conventions in diagrams of causality graphs of
computations. 
Earlier actions in the computation appear to the left of later ones.
Actions by the same agent are placed on the same horizontal line.
So, all agent edges are horizontal and directed from left to right.
The start and end vertices have labels <i>O</i> and <i>N</i>
respectively. 
The timeline diagrams of figure 2 and 3 follow these conventions.

<!--------------------------------------------------------------------------->
  <h5 style="color:red;">Example: Causality Graph of a Multistep
  Computation</h5>
  <!--------------------------------------------------------------------------->
<p>
Figure 3 shows the sequence of states in a computation at the top and
  the causality graph of the computation at the bottom.
  </figure>

    <figure>
    <img src="Timelines/Timelines.003.jpeg" alt="Fig006" style="width:75%">
    <figcaption>Fig.3: Example: A Computation and its Causality Graph</figcaption>
</figure>


<!--------------------------------------------------------------->
<h2 class="w3-text-teal">Cuts of Causality Graphs</h2>
<!--------------------------------------------------------------->

<p class="w3-text-teal">The Relation: "Depends On"</p>
We say that a vertex \(v\) <i>depends on</i> a vertex \(v'\) exactly when there is a
path in the graph from \(v'\) to \(v\).
In the causality graph of figure 3, vertex 5 depends on vertex 2 but
not on vertex 3.

<p class="w3-text-teal">Consistent Cuts of a Causality Graph</p>
A <i>cut</i> of a causality graph is a subset of the vertices of the graph.
A cut is <i>consistent</i> exactly when for every vertex \(v\) in the
cut all vertices on which \(v\) depends are in the cut.

<p>
An equivalent definition is: A consistent cut of a causality graph is
a subset of vertices of the graph such that every edge to every vertex
in the cut is from a vertex in the cut.


<p style="color:red;">Example of a consistent cut</p>
In figure 1, the sets of vertices with numbers at most
\(i\) are consistent cuts for all \(i \geq 0\).
For example, \(S = \{0, 1, 2, 3\}\) is consistent because \(3\) depends on
\(\{0, 1, 2\}\), and \(1\) and \(2\) depend on \(\{0\}\), which are
subsets of \(S\).

<p style="color:red;">Example of an inconsistent cut</p>
The set \(\{0, 1, 2, 5, 6\}\) is not consistent because 
\(6\) depends on \(4\) which is not in the set.


<h4 class="w3-text-teal">The State at a Cut</h4>
We define the state at a cut as follows.
The state of an agent \(x\) is the label of the edge for \(x\)
from a vertex in the cut to a vertex outside the cut.
The state of a channel is the sequence of labels of message edges, for
messages sent on the channel, in the order in which messages are sent,
from vertices in the cut to vertices outside the cut.

<p>
The state of a cut is evident from diagrams of causality graphs: the state is given by
the labels of edges that cross the cut boundary.

<p style="color:red;">Example of the state at a cut</p>
For example, let's determine the state at the cut \(\{0, 1,
2, 3\}\) in figure 1.
The state at the cut is given by the labels of edges that cross the
cut which are:
<ol>
  <li> the state of \(u\): the label of \(u\)'s agent edge from \(1\) to \(5\) which is
  "e" representing the set of empty tokens;
  </li>
  <li>
   the state of \(v\): the label of \(v\)'s agent edge from \(3\) to \(4\) which is the set
  consisting of the blue token;
  </li>
  <li>
  the state of channel \(uv\): the label (the red token) of the
  message edge from \(3\) to \(5\) represents a sequence of messages
  consisting of a single message -- the red token
  </li>
</ol>
The state of channel \(vu\) is the empty sequence of messages because
there are no messages on this channel that cross the cut.

<!---------------------------------------------------------------------->
<h2 class="w3-text-teal">Computations with the same Causality
Graph</h2>
<!---------------------------------------------------------------------->
More than one computation can share the same causality graph.
The causality graph captures the dependence of the inputs of an action
to the outputs of other actions.
The graph does not, however, capture the order in which actions are
executed.
Next, we look at examples of computations that share the same
causality graph and then prove a theorem which helps in developing
many algorithms.

<h5  style="color:red;">Examples of Computations with the same Causality
Graph</h5>
Figure 4 is an example of a computation that is different from that shown in
figure 3, but with the same causality graph as in figure 3.
The sequence of actions is represented by the vertex sequence \([0, 2,
1, 3, 5, 4, 6]\).
The sequence of states in the computation is represented by the states at cuts
\(\{0\}\), \(\{0, 2\}\), \(\{0, 2, 1\}\),...
This sequence \([S'_{0},
\ldots, S'_{6}]\) is shown in figure 4.


<figure>
    <img src="Timelines/Timelines.004.jpeg" alt="Fig006" style="width:75%">
    <figcaption>Fig.4: Example: A Computation and its Causality Graph</figcaption>
</figure>

<p>
Other examples of computations with the same causality graph are
computations represented by vertex sequences \([0, 2, 1, 3, 4, 5,
6]\), and \([0, 1, 2, 3, 5, 4, 6]\).

<p>
The next theorem tells us which
computations have the same causality graph.


<hr class="new2">
<h5 style="color:blue;">
Theorem:
<br>
A causality graph and a sequence of its vertices represents a
computation if:
<center>
<p style="color:blue;">
each vertex \(v\) appears in the sequence after all vertices on which
\(v\) depends.
</h5>
</center>
</p>
<hr class="new2">
<p class="w3-text-teal">Proof</p>
Let \(G\) be the causality graph of a computation, and let \(Q\) be a
sequence of vertices of \(G\) where a vertex \(w\) appears in \(Q\) only
after all vertices on which \(w\) depends.
Let \(W_{i}\) be the cut consisting of the first \(i \geq 0\) vertices
of \(Q\).
Because each vertex appears in \(Q\) only after vertices on 
which it depends, \(W_{i}\) is consistent for all \(i\).
Let \(S_{i}\) be the state at the cut \(W_{i}\), for all \(i\).
We will prove that there is a computation with the state sequence
\([S_{0}, S_{1}, S_{2}, \ldots]\).

<p>
Let the \(i+1\)-th vertex in \(Q\) be \(v\).
Let the label of the agent edge to \(v\) be \(L\).
Consider the case where there is a message edge to \(v\), and let the
label of the edge be \(m\) where the edge represents a message
received on a channel \(c\).
(The case where no message is received is proved in the same way.)
Action \(a\) can be executed by agent \(x\) in state \(S_{i}\) if the
state of \(x\) in \(S_{i}\) is \(L\) and the state of \(c\) in
\(S_{i}\) is a sequence of messages with 
message \(m\) at its head.

<p>
All edges to \(v\) are from \(W_{i}\) because \(W_{i+1}\) is
consistent.
\(S_{i}\) is specified by the labels of edges from vertices
in \(W_{i}\) to vertices outside \(W_{i+1}\).
Therefore the state of channel \(c\) in \(S_{i}\) is a sequence of messages that has
\(m\) at its head, and
the state of agent \(x\) in \(S_{i}\) is \(L\).
So \(S_{i}\) satisfies the precondition for agent \(x\) to execute action
\(a\), and 
there exists a transition from \(S_{i}\) to \(S_{i+1}\),
for all \(i\).

<h5 class="w3-text-teal">Topological Sorts of Causality Graphs</h5>
The theorem can also be expressed in terms of topological sorts of
acyclic graphs.
A topological sort of an acyclic graph is a sequence of vertices of the graph
such that for all edges \((v, v')\) in the graph, \(v\) occurs before
\(v'\) in the sequence.

<hr class="new2">
<p style="color:blue;">
Theorem:
All topological sorts of the causality graph of a computation of a system
represent computations of the system.
</p>
<hr class="new2">


<!--------------------------------------------------------->
<h2 class="w3-text-teal">Computations that generate the same Agent
Logs</h2>
<!--------------------------------------------------------->

A log of an agent's actions during a computation is the sequence of
actions taken by that agent in the computation.
The log includes the agent states before and after each action, and
the messages sent and received.
An agent's log is represented by its timeline -- the horizontal
sequence of vertices and the edges incident on the vertices -- in the
computation.

<p>
An <i>interleaving</i> of logs of a set of agents is a sequence \(S\) of
actions in the logs where the order of actions in each log is
preserved, i.e. if \(v\) appears before \(v'\) in the log of an agent
then \(v\) appears before \(v'\) in \(S\).
The log of an agent \(x\) can be obtained from an interleaving \(S\) by
deleting all actions by all agents other than \(x\) in \(S\).

<p>
The causality graph of a computation can be determined from the logs
recorded by agents in the computation. The vertices of the graph are
the vertices in the agent timelines. The agent edges are given in the
agent timelines, and the message edges connect actions in which
messages are sent to those in which they are received.

<hr class="new2">
<h5 style="color:blue;">
Theorem
<br>
An interleaving \(Q\) of agent logs represents a computation exactly
when each action in which a message is received appears in \(Q\) only
after the action in which that message is sent.
</h5>
<hr class="new2">

<p class="w3-text-teal">Proof</p>
Any interleaving \(Q\) of agent logs preserves the <i>depends on</i>
relation for actions at the same agent.
If each message received in \(Q\) is received only after it is sent in
\(Q\) then each vertex in \(Q\) appears only after the vertices on
which it depends.

<p  style="color:red;">Examples of Computations with the same Agent
Logs</p>
The figure below shows two computations with the same agent logs.
We can get one computation from another with the same logs by moving
vertices horizontally -- from left to right or right to left -- while
ensuring that all message edges are directed forward in time, i.e.,
have a rightward direction.
For example, we can get the computation shown below in the figure from
the one shown above in this way.
In the top diagram, we can move vertex 1 to the right -- later in time -- so that
it passes vertex 2; however, we can't move vertex 1 to the right of
vertex 3 because then the edge from vertex 1 to vertex 3 would be directed to the left -- backwards
in time.
Likewise we can move vertex 5 to the left so that it passes vertices 4
and/or 3, but not 2.

<figure>
    <img src="Timelines/Timelines.005.jpeg" alt="Fig005" style="width:60%">
    <figcaption>Fig.5: Example: Computations with the same Agent Logs</figcaption>
</figure>


<h4 class="w3-text-red">
<i>Central Ideas: Review</i></h4>
<p class="w3-text-red">
Causality graphs show how actions in a computation depend on each
other.
A consistent cut is subset of vertices of a causality graph where for
every vertex \(v\) in the cut, all the vertices on which \(v\) depends
are in the cut.
A sequence of vertices of a causality graph represents a computation
if every vertex in the sequence appears only after vertices on which
it depends.
All interleavings of agent logs in which messages are received only
after they are sent are computations.

<p class="w3-text-red">
<i>Concepts</i>:
Causality graphs -> the "depends on" relation -> consistent cuts ->
vertex sequences that preserve the "depends on"relation 
</p>


<h3 class="w3-text-teal">Next</h3>
Next read about
<a href="../ChannelSnapshots/ChannelSnapshots.html">
the global snapshot algorithm by which agents determine the state at a
consistent cut.

<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
