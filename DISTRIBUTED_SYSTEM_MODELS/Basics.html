<title>DistributedSystemModels/Basics.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!---------------------------------------------------------------->
    <h1 class="w3-text-teal">Basics</h1>
<!----------------------------------------------------------------->
  

  
  </p>

  <p class="w3-text-red">
  This page describes a simple model and notation for distributed
  algorithms.

  Converting this notation to widely-used programming
  languages is straightforward.

  The model, though simple, is adequate for designing many
  algorithms.

  More models are introduced when needed.
  </i>
  </p>

  <!----------------------------------------------------------------->
  <h3 class="w3-text-teal">Models of Distributed Systems</h3>
  <!----------------------------------------------------------------->

  <!---------------------------------------->
  <p class="w3-text-teal">Complex Systems</p>

  Distributed systems are complex.

  The information system that supports a bank has actions taking place
  in ATM machines, branch offices, and fraud analysis centers.

  An earthquake monitoring system has thousands of sensors and agents
  connected to sensors and in the cloud.


  <!---------------------------------------->  
  <p class="w3-text-teal">Simple Models</p>
  
  A model of a distributed system is an abstraction that ignores some
  features of systems while retaining features that help in designing
  algorithms.

  We use different models to design algorithms in different
  settings.

  For example, models of systems in which messages may be
  corrupted are different from models if systems in which messages
  are not corrupted.

  <p>
  We begin with a very simple model.

  We will identify features that the model ignores and show why the
  model is useful despite its simplicity.



  <!---------------------------------------->  
  <p class="w3-text-teal">Powerful Programming Languages</p>

  A small number of programming languages and software libraries
are used to implement most distributed systems.

In addition, there are beautiful concurrent programming languages
that becoming widely adopted.

These languages and libraries have many features because distributed
systems are complex.


  <!---------------------------------------->  
<p class="w3-text-teal">Simple Notations</p>

The algorithms in this course are very short.

Implementing them in
different programming languages is straightforward.

We use a simple notation and show how algorithms in this notation are converted in a
straightforward way into programs
using libraries such as 
  <a
  href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">
  Advanced Message Queuing Protocol (AMQP)
</a>,
and 
  <a
  href="https://www.rabbitmq.com/tutorials/tutorial-one-python.html">
  a Python implementation of AMQP.
</a>




  
  
  <!----------------------------------------------------------------->
  <h3 class="w3-text-teal">A Simple Model: Agents and Channels</h3>
  <!----------------------------------------------------------------->
<p>

A distributed system consists of a set of agents and a set of
channels.
  
  A channel is directed from one agent to one agent.

  A channel from an agent <code>P</code> to an agent <code>Q</code> is
  an output of <code>P</code> and an input of <code>Q</code>.
  
  An agent can send messages on its output channels and receive
  messages on its input channels.

A system is represented by a directed graph in which vertices
represent agents and edges represent channels.

<p>
A distributed system is initiated with sets of agents and channels
  that remain unchanged. 

Agents and channels are not created or deleted.


  <h4 style="color:red;">Example: Agent-Channel Graph</h4>
  The figure below shows an agent-channel graph with agents \(A, B, C\).

    <figure>
    <img
    src="DistributedSystemModels/DistributedSystemModels.001.jpeg"
    alt="Fig1" style="width:60%"> 
    <figcaption>Fig.1: Example: An Agent Graph</figcaption>
    </figure>



<!---------------------------------------------------->
<h4 class="w3-text-teal">Message Communication: Channels</h4>
<!----------------------------------------------------------------->

The state of a channel is the sequence of messages in the channel --
these are the messages that have been sent on the
channel and that have not been received.

An agent sends a message by appending the message to the tail of the
sequence of messages in the channel.

An agent can receive the message at the head of a nonempty sequence of
messages in any of the agent's input channels.

When an agent receives a message it is deleted from the sequence.

<p>
Associated with each channel is its initial state -- the sequence of
messages in the channel when the distributed system starts executing.


<!---------------------------------------------------->
<h4 class="w3-text-teal">Agents</h4>
<!---------------------------------------------------->

Associated with each agent is a program that initializes the
variables of the agent and a function 
<pre>
receive(message, sender)
</pre>
called a callback function in
<a href=
"https://www.rabbitmq.com/tutorials/tutorial-one-python.html">
message queuing libraries.
</a>
The parameters <code>message</code> and <code>sender</code> of the function are the
message that is received, and the sender of the message.

<p>
If an agent has a nonempty input channel then the <code>receive</code>
function of the agent is called where <code>message</code> is the
message at the head of the channel, and <code>sender</code> is the
agent that sent the message.

<p>
An agent sends a mesage by executing
<pre>
send(message, receiver)
</pre>
The first parameter of <code>send</code> is the message that is sent,
and the second paramenter is the agent to which the message is sent.

Execution of this statement places the message in the output channel
from the agent to the receiver.

A message can be sent on a channel independent of the state of the
channel.

An agent is never blocked from sending a message.



<h4 style="color:red;">Example of an Agent</h4>
This is an example of an agent that receives messages from agents
<code>pos</code> and <code>neg</code>,
and sends messages to agent <code>results</code>.
The state of the agent is given by the values of its local variable
<code>sum</code> and its program counter.
<pre>
// Initial state
sum = 0

def receive(message, sender):
   if sender == pos:
       sum = sum + message
   else:
       sum = sum - message
   send(sum, results)
</pre>


<!----------------------------------------------------->
<p class="w3-text-teal">Restrictions on Agents</p>
<!----------------------------------------------------->

An agent can only access that agent's variables, send
messages only on that agent's output channels, and receive messages
only on that agent's input channels.

A <code>receive</code> function must not call itself, and every
execution of <code>receive</code> must terminate. 





<h5 class="w3-text-teal">Next</h5>
<a href="DistributedSystemModels.html">
States, transitions and
computations in a model of a distributed system.</a>
The next two webpages continue the description of a model of
distributed systems and point out its strengths and limitations.

<p>
<a href="BasicsFAQ.html">Frequenty Asked Questions</a>



<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
