<title>DistributedSystemModels/BasicsFAQ.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!---------------------------------------------------------------->
    <h1 class="w3-text-teal">Basics: FAQ</h1>
<!----------------------------------------------------------------->

  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Why use such a simplistic model?</p>
  <!----------------------------------------------------------------->
  The model is indeed simplistic; however, it is adequate for describing
  and reasoning about many of the algorithms described in the first
  part of this course.

  We introduce other models later.

  We use the simplest model adequate for the problem at hand.


  <!----------------------------------------------------------------->
  <p class="w3-text-teal">What are the weaknesses of the model?</p>
  <!----------------------------------------------------------------->
  The model has many weaknesses, only some of which are described
  here.

  <p>
  The network of agents and messages in the model is static.

  In contrast, distributed systems evolve; agents and channels may be
  added and deleted; agents may change; channel protocols may be modified.

  <p>
  The model only considers channels in which messages are delivered in
  the order sent.

  Some distributed systems have channels in which messages may be
  duplicated and delivered out of order.

  <p>
  Distributed systems are (usually) fault tolerant, whereas the model
  does not deal with faults.

  <p>
  The model makes no provision for time or clocks.

  Atomic clocks and GPS provide great accuracy, and many distributed
  systems such as those that monitor the electric grid use clocks.

  
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">How many channels are there in a system?</p>
  <!----------------------------------------------------------------->
  In the model there is a channel from every agent to every agent.

  So, if there are \(N\) agents there are \(N^{2}\) channels.

With a thousand agents there are a million channels.

That's a lot of channels!

<p>
The model allows channels between every pair of agents.

In practice very few of these channels are used.

When we implement an algorithm using AMQP, for instance, we will
declare channels.
  
  
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Can you describe channels in more detail?</p>
  <!----------------------------------------------------------------->
  Channels in our model are asynchronous (non-blocking) and
  unidirectional.

  A sender can send messages on a channel regardless of how many
  messages have been sent in the past and how many messages have been
  received on that channel.

  The model assumes that the queue of messages in the channel has
  infinite capacity.

  <p>
A channel is unidirectional.

It is represented by a directed edge in a directed graph.

Messages can be sent by an agent <code>P</code> to an agent
<code>Q</code> along a channel <code>(P, Q)</code>.

Agent <code>Q</code> cannot send a message to agent <code>P</code>
along channel <code>(P, Q)</code>.

<p>
A system may have a channel <code>(P, Q)</code> and may or may not have a channel
<code>(Q, P)</code>.

Some systems have bidirectional channels but our model does not allow
for bidirectional channels.

<p>
In our model, 
a channel is directed from exactly one agent to exactly one agent.

In some systems, multiple agents can send messages on the same
channel, and multiple agents can receive messages on the same channel.

Our model does not allow for such channels.

  
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Can an agent refuse to receive a message?</p>
<!----------------------------------------------------------------->
  In this model an agent cannot refuse to receive a message.

  If a channel is not empty then a message from the channel can be
  delivered to the agent <i>independent of the state of the agent</i>.
  

<p>
 Suppose you want to design an algorithm in which an agent
  <code>X</code> refuses to receive messages from an agent
  <code>Z</code> until it first receives a message from an agent
  <code>Y</code>.

  How would you use this model?

  <p>

In our model, agent <code>X</code> has to receive the message from
  <code>Z</code> in every state of <code>X</code>.

  <p>
  Agent <code>X</code> can copy the message from <code>Z</code> into a
  local queue -- a local variable of <code>X</code> -- and process the
  message only after receiving the message from <code>Y</code>.
  

  
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Can a full channel block a sender from
  sending more messages?</p>
<!----------------------------------------------------------------->
In the model a sender is never blocked from sending a message.

<p>
Our model assumes that channels have unlimited capacity.

We can represent a situation in which channels have limited capacity
in the following way.

An agent has a local output queue of unlimited size.

The agent puts messages into this queue when it cannot send messages
on a channel because the channel is full.

Messages from this queue are sent on the channel when the
channel stops being full.




    
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Can you represent systems in which agents
  are created and deleted in the model?</p>
  <!----------------------------------------------------------------->
  The model doesn't have features that allow agents to be created and
  deleted.


<p>
A work around for the case in which agents are created or deleted a
finite number of times is as follows.

The network of agents in the model is made large enough to include
agents that have not been created as yet and also include agents that
have been deleted.

<p>
An agent that has not been created is represented by an agent that is
idle, i.e., one is waiting for a message. It never receives a message
until the agent is created. The message is created by the operating
system sending a "create" message to the agent and informing other
agents that this agent has been created.

<p>
An agent this is deleted is represented in the same way.

The operating system deletes an agent by sending a "delete" message to
the agent.

A deleted agent discards messages that it receives without
taking action.

  


    
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Can an agent process background jobs that
  are interrupted when messages arrive?</p>
<!----------------------------------------------------------------->

No, there are no interruptions in the model.

When an agent is executing a receive it is not interrupted.

<p>
There are systems in which messages have different priorities, and the
arrival of high-priority messages interrupts the execution of
low-priority messages.

Our model does not allow for interruptions.


  
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">How do you represent channels that are not
  first in first out?</p>
  <!----------------------------------------------------------------->
We use queues to represent states of first in first out channels, and
  we use other data structures -- such as multisets -- to represent
  states of other types of channels. 

<p>
Later we describe algorithms with different types of channels.

  For example, the state of a channel in which messages may overtake
  each other is a multiset or bag.

  A message is sent on a channel by adding the message to the
  multiset.

  A nonempty multiset may deliver any message in the mutliset to the
  receiving agent.

  <p>
  Lossy channels, and channels in which messages have priorities, are
  also modeled by defining channel states appropriately.

        
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Can the model represent sequential
  composition of distributed computations?</p>
  <!----------------------------------------------------------------->
Yes.

<p>
There are problems in which we would like to start a distributed
computation <code>P</code>; wait for <code>P</code> to finish, and
then start another distributed computation <code>Q</code>.

We want a barrier between <code>P</code> and <code>Q</code>.

<p>
A barrier can be implemented in several ways.

An agent, say a <i>coordinator</i> agent, sends messages to all agents to start
<code>P</code>.

The coordinator then detects termination of <code>P</code>; we discuss
termination detection algorithms later.

After detecting termination of <code>P</code> the coordinator sends
messages to all agents to start <code>Q</code>.
  
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Can the model represent agents that make state transitions
  without receiving messages? </p>
<!----------------------------------------------------------------->
No, the model does not represent agents that make state transitions
without receiving messages.

The effect of a state transition without receiving a message can be
simulated by an agent sending itself a message and carrying out the
transition when it receives a message from itself.

<p>

For example, an agent that is computing using a set of files may
  transition to a state in which it no longer needs those files; this
transition occurs without the agent receiving a message.

We model this event by having the agent send itself a message when it
starts using the set of files, and it transits to a state in which it
no longer needs the files when it receives the message from itself.

  <p>
  Representing internal state changes in this way is an artifice;
  however, the artifice allows us to use a very simple model in which a
  state change occurs when, and only when, a message is delivered.



  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Is an agent the same as a process? </p>
<!----------------------------------------------------------------->
Yes, some documents use "process" instead of "agent."



  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Local clocks can be synchronized using NTP
  and other protocols. Why do you assume that clocks aren't synchronized? </p>
<!----------------------------------------------------------------->
Local clocks can, indeed, be synchronized very accurately; however, we
  do not assume that they are perfect.

<p>
We use agents' local clocks for evaluating algorithm performance but
not for proving correctness because even a small drift can cause race
conditions. 

<p>
Consider an algorithm in which one agent carries out a computation
starting at 1pm and another agent carries out a computation starting at 2pm.

When we prove the correctness of our algorithms, we allow for the
unlikely possibility that that the agent starting its 
computation at 2pm does so before the agent that starts a 1pm.

For evaluating performance, however, we assume that the agent that starts a 1pm
usually does so before the agent that starts at 2pm.



  <!----------------------------------------------------------------->
  <p class="w3-text-teal">What are other examples of models? </p>
<!----------------------------------------------------------------->
The model we use is an
<a href="https://en.wikipedia.org/wiki/Actor_model">actor model.</a>

For more general asynchronous models of concurrent systems see
<a
href="https://books.google.com/books/about/Parallel_Program_Design.html?id=QYlQAAAAMAAJ">
UNITY
</a>
and
<a href="https://en.wikipedia.org/wiki/TLA%2B">
TLA
</a>.

<p>
Perhaps the most widely used model is
<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">
CSP -- Communicating Sequential Processes</a>.

<p>
An overview of 
<a href="https://en.wikipedia.org/wiki/Parallel_programming_model">
models used in parallel programming<a/> describes models used in
shared-memory and distributed computing.




<h5 class="w3-text-teal">Next</h5>


<a href="BasicsStates.html">
States of a Distributed System.</a>


<p>
<a href="BasicsReview.html">Review material for this page</a>




<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
