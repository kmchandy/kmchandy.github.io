<title>DistributedSystemModels/BasicsFAQ.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!---------------------------------------------------------------->
    <h1 class="w3-text-teal">Basics: FAQ</h1>
<!----------------------------------------------------------------->

    <!----------------------------------------------------------------->
  <p class="w3-text-teal">Why use such a simplistic model?</p>
  <!----------------------------------------------------------------->
  The model is indeed simplistic; however, it is adequate to describe
  and prove the correctness of the algorithms described in this
  website. 
    
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Can you represent systems in which agents
  are created and deleted in the model?</p>
  <!----------------------------------------------------------------->
  Construct a system with a large number of agents and channels.

  Represent an agent that has yet to be created by an agent \(a\) that
  is created in a special state -- "dormant."

  \(a\) has an input channel from a system manager which
  sends \(a\) a message -- say a "create" message -- and when \(a\) receives the
  message it starts executing and changes state from dormant to executing.

  <p>
  A similar method can be used for representing channels that are
  created and deleted.

      
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">How do you represent channels that are not
  first in first out?</p>
  <!----------------------------------------------------------------->
  Later we describe algorithms with different types of channels.

  For example, the state of a channel in which messages may overtake
  each other is a multiset or bag.

  A message is sent on a channel by adding the message to the
  multiset.

  A nonempty multiset may deliver any message in the mutliset to the
  receiving agent.

  <p>
  Lossy channels, and channels in which messages have priorities, are
  also modeled by defining channel states appropriately.

        
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Can the model represent sequential
  computation of distributed computation?</p>
  <!----------------------------------------------------------------->
  A sequential composition of distributed computations is one in which
  a distributed computation starts and later terminates after
which a new distributed computation starts.

The model has no constructs for implementing such algorithmic structures.

<p>
In the model, once an agent starts it waits to receive messages for
ever; there are no provisions for stopping and restarting agents.

We can, however, represent sequential composition of distributed
computations.

<p>
Consider an example in which a distributed computation starts and ends
after which a new distributed computation is initiated.

Call the computations phase 0 and phase 1.

Each agent has a local variable which identifies the phase in which it
is operating.

When an agent -- say a systems manager -- detects termination of phase
0 it sends messages to all agents telling them to start phase 1.

(We discuss algorithms for termination detection later.)

<p>
We can represent complex sequential and parallel compositional
structures in our simple model.

The algorithms in this course do not, however, use such compositional
structures. 
  
  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Can the model represent agents that make state transitions
  without receiving messages? </p>
<!----------------------------------------------------------------->
Some books on distributed systems allow agents to make <i>internal</i>
  state transitions -- these are transitions without receiving
messages.

For example, an agent that is computing using a set of files may
  transition to a state in which it no longer needs those files; this
transition occurs without the agent receiving a message.

Can the model represent such internal state transitions?

<p>
Internal state transitions are represented by transitions in which an
agent receives a message from itself.

  We represent an internal state change by having the agent
  send a message to itself; the agent makes a state change when it
receives the message.

<p>
For example, an agent that is computing using a set of files sends a
message "<i>finished using files</i>" to itself, and when the message
arrives, the agent changes state to one in which it no longer using
the files.



  <p>
  Representing internal state changes in this way is an artifice;
  however, the artifice allows us to use a simple model in which a
  state change occurs only when a message is delivered.


  <!----------------------------------------------------------------->
  <p class="w3-text-teal">Local clocks can be synchronized using NTP
  and other protocols. Why do you assume that clocks aren't synchronized? </p>
<!----------------------------------------------------------------->
Local clocks can, indeed, be synchronized very accurately; however, we
  do not assume that they are perfect.

We use agents' local clocks for ensuring algorithm performance but not for proving
correctness.

<p>
Consider an algorithm in which one agent carries out a computation
starting at 1pm and another agent carries out a computation starting at 2pm.

When we prove the correctness of our algorithms, we allow for the
unlikely possibility that that the agent starting its 
computation at 2pm does so before the agent that starts a 1pm.

For evaluating performance, however, we assume that the agent that starts a 1pm
usually does so before the agent that starts at 2pm.


<h5 class="w3-text-teal">Next</h5>
<a href="DistributedSystemModels.html">States, transitions and
computations in a model of a distributed system.</a>
<p>
<a href="Basics.html">Basics.</a>


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
