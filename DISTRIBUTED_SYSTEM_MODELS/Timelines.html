<title>Timelines.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


  
<!--------------------------------------------------------->
<h2 class="w3-text-teal">Timelines</h2>
<!--------------------------------------------------------->

<p>
A timeline is a labeled directed graph that represents a system
  execution.
  An execution is also called a computation or a trajectory of a
  system.

  <p>
  There is a vertex corresponding to each event (i.e. state
  transition) in the execution, and there are
  initial and final vertices representing the beginning and
  ending of the execution.
  The edges in the graph are as follows:
<ul>
  <li>
  <i>Agent timeline edges</i>:
  There is an edge directed from an
    event \(e\) at an agent \(A\) to the next event \(e'\) at \(A\); the edge is
  labeled with \(A\)'s state immediately after \(e\).
  </li>
  <li>
  <i>Message edges</i>
  A message \(m\) sent at an event \(e\) and received at an event
    \(e'\) is represented by an edge directed from \(e\) to \(e'\),
  and the edge is labeled \(m\).
  </li>
</ul>

  <p>
The events in the timeline are shown in the order in which they occur with earlier events
appearing to the left of later events. 
All the events on the same agent are shown on the same horizontal
line which we call the agent's timeline.
A timeline has a vertex for each agent representing the initiation of
the execution, and a vertex representing the end of the execution.

<p>
The timeline graph is acyclic
because all edges are directed from earlier to later events.

<h4 style="color:red;">Example</h4>
<figure>
    <img src="Timelines.001.jpeg" alt="Fig1" style="width:100%">
    <figcaption>Fig.1: A System Timeline</figcaption>
</figure>
This example shows a system timeline with two agents, \(A\) and
\(B\).  The vertices  A1, A2, A3 represent events at agent \(A\);
likewise vertices B1 B2,represent \(B\)'s events. Vertices A0 and B0
represent the start of the execution. The vertices representing the
end of the execution are not shown; instead edges from the last events
(A3, B2) on agents \(A, B\) are shown as dangling edges with no
terminal vertex. 

<p>
An edge along an agent's timeline is labeled with the state of that
agent at the point. For example, the edge from event A1 to event A2 is
labeled \(S[A1]\) which is agent \(A\)'s state immediately after event
A1. 

<p>
Event A1 is an example of an internal event in which an agent changes
state without receiving a message.
Event A2 is an example of an event in which an agent changes
state when it receives a message.

<p>
The diagram shows that
agent \(A\) sends message \(m_{0}\) in event A1 and this message is
received by agent \(B\) in event B1.


<h4 class="w3-text-teal">Channel States in System Timelines</h4>
The state of a channel \(c\) at time \(T\) is the sequence (in time
order) of messages that are sent along \(c\) before \(T\) and that are
received after \(T\). The state of \(c\) at \(T\) can be obtained from
the system timeline as the sequence of labels of edges representing
messages along \(c\) that are cut by the \(T\)-line, the vertical line
at \(T\).

<h4 style="color:red;">Example</h4>
<figure>
    <img src="Timelines.002.jpeg" alt="Fig2" style="width:100%">
    <figcaption>Fig.2: Global State from a System Timeline</figcaption>
</figure>
Figure 2 shows a system
timeline with agents \(A, B, D\). Agent \(A\) sends messages
\(m_{0}\) along a channel \(x\) and sends \(m_{1}\) along a different
channel \(c\) at event A1.  When agent \(D\) receives \(m_{0}\) at
event D1 it sends message \(r_{0}\) to \(A\) along a channel \(y\).
When agent \(A\) receives \(r_{0}\) at event A2 it sends message
\(m_{2}\) to \(B\) along channel \(c\).  When agent \(B\) receives
message \(m_{1}\) at event B1 it sends message message \(u_{0}\) to
\(A\) along a channel \(v\).

<p>
The state of \(c\) at time \(T\) is the sequence of labels, \([m_{1},
m_{2}]\), of edges representing messages on \(c\) that are cut by the
\(T\)-line.  The state of an agent \(A\) at \(T\) is the label of the
edge on \(A\)'s timeline cut by the \(T\)-line.  So, the global state
of the system at T can be obtained from labels of edges cut by the
\(T\)-line.


<h4 class="w3-text-teal">Sequence of Global States</h4>
The sequence of <i>global</i> states in a trajectory can be 
obtained from the system timeline from the labels of edges cut by the
sequence of vertical lines before each event.
The starting and ending states of the trajectory are obtained from the
earliest (leftmost) and latest (rightmost) vertical
lines in the diagram.

<h4 style="color:red;">Example</h4>
<figure>
    <img src="Timelines.003.jpeg" alt="Fig3" style="width:100%">
    <figcaption>Fig.3: Global States in the Trajectory</figcaption>
</figure>


<h4 class="w3-text-teal">Different Trajectories with Identical Graphs</h4>
Are there different trajectories with identical graphs?
Look at the next figure.

<figure>
    <img src="Timelines.004.jpeg" alt="Fig5" style="width:100%">
    <figcaption>Fig.4: A Different Trajectory with Same Graph</figcaption>
</figure>
The trajectory in this diagram is specified by the sequence of events:
Initial events (A0, B0, D0) followed by the sequence A1, D1, B1,
A2, A3, B2.

<p>
The graphs of figures 3 and 4 are the same but the trajectories that
the figures represent are different.  In figure 4 event B1 occurs
before event A2 whereas in figure 3, B1 occurs after A2.  So, the
global state after B1 and before A2 in figure 4 is never
visited in figure 3;
However, figures 3 and 4 have the same starting and ending states.
The following theorem captures the idea illustrated by figures 3 and
4.


<h4 class="w3-text-teal">Theorem about Permutation of Event Sequences</h4>

<hr class="new2">
    <h5 style="color:blue;">
Let \(X\) be a trajectory of a system that starts in a state \(S\) and
    ends in a state \(S'\). Any permutation \(Y\)
of the sequence of events in \(X\), where agents have the same
timelines in \(X\) and \(Y\),
is also a trajectory of the system that starts in \(S\) and ends in \(S'\)
if and only if:
<br>
<i>every message in \(Y\) is received only after it is sent.</i>
</h5>
<hr class="new2">

The conditions imply that the graphs of \(X\) and \(Y\) are identical.
Moreover all edges in the permutation \(Y\) are directed forwards in
time, i.e. from left to right.
The theorem is illustrated in figures 3 and 4 with \(X, Y\) as the
timelines.


<h4 class="w3-text-teal">Proof</h4>

The theorem holds trivially if \(X\) and \(Y\) are identical. If \(X\)
and \(Y\) are different then there exists a pair of consecutive events
\(e\) and \(e'\) in \(X\) where  \(e'\) appears after \(e\) in \(X\)
but \(e'\) appears before \(e\) in \(Y\).

<p>
Events \(e\) and \(e'\) are at different agents because agent
timelines are identical in \(X\) and \(Y\).
There is no edge from \(e'\) to \(e\)
because \(e'\) occurs after \(e\) in \(X\), and a message sent in
event \(e'\) is not received at an earlier event \(e\). Likewise, there is no edge
from \(e\) to \(e'\) because \(e\) occurs after \(e'\) in \(Y\).
Therefore, the inputs to \(e\) and the inputs to \(e'\)  remain unchanged whether \(e'\) appears
before or after \(e\).
So, the outputs to \(e\) and the outputs to \(e'\)  remain unchanged whether \(e'\) appears
before or after \(e\).



<p>
Let \(Z\) be the
permutation obtained from \(X\) by flipping the order of \(e\) and
\(e'\). Then \(Z\) is also a trajectory of the system that starts in
\(S\) and ends in \(S'\).

<h4 style="color:red;">Example</h4>
The diagram to the left
in the figure below shows the events before their order is switched, while
the diagram to the right shows the events after their order is switched.
<figure>
    <img src="Timelines.005.jpeg" alt="Fig5" style="width:100%">
    <figcaption>Fig.5: Switching order of consecutive independent events</figcaption>
</figure>

We can obtain \(Y\) from \(X\) by repeatedly flipping the order of
independent adjacent events.

<p>
This theorem is instance of the <i>diamond property</i> from functional
programming.

<h3 class="w3-text-teal">Cuts of System Timelines</h3>
A cut of a a system timeline is a partition of the events in
the timeline into two subsets called <i>past</i> and <i>future</i>.


<hr class="new2">
    <h5 style="color:blue;">
A <i>consistent cut</i> is one
in which there is no edge in the graph from a <i>future</i> event
to a <i>past</i> event.
</h5>
<hr class="new2">


<p class="w3-text-teal">Equivalent Definitions of Consistent Cuts</p>
<p>The following are equivalent definitions of a consistent cut:
<ol>
  <li>
  All edges <i>to past</i> events are <i>from past</i> events.
  </li>
  <li>
  All edges <i>from future</i> events are <i>to future</i> events.
  </li>
</ol>
  

<h4 style="color:red;">Example</h4>
The figure below shows cuts across two system timelines
where past events are colored black and future events are green.
<figure>
    <img src="Timelines.007.jpeg" alt="Fig7" style="width:100%">
    <figcaption>Fig.7: Cuts of Timelines</figcaption>
</figure>

The cuts in both diagrams are identical: past events are A0, A1, B0,
D0, D1. 
The cuts are consistent because there is no edge from
green to black.
<p>
A purple vertical line, representing an instant in time, separates past from
future in the lower diagram.
By contrast, a curved line separates past from future in the upper
diagram. There is no vertical line that separates past from future in
the upper diagram because a past event (B1) appears after a future
event (A2).

<p class="w3-text-teal">Intuition for Permuting Past before Future</p>
Given the upper diagram, in which past and future are separated by a
curved line,
we can use the following intuitive method to obtain the trajectory of the lower
diagram in which past and future are separated by a vertical line.

<p>
Treat the purple curved separating line in the upper diagram as a
string, and pull the string taut. Doing so may push some events, such
as A2, to the right, and other events, such as B1, to the left.  As
events move, while the string is tautened, all edges always remain
directed from past to future. This is because there is no edge that
crosses the string from the right to the left. Therefore the the
events that are permuted are independent of each other and the
conditions of the theorem are satisfied.

<h3 class="w3-text-teal">Theorem about Consistent Cuts</h3>
<hr class="new2">
    <h5 style="color:blue;">
For any consistent cut, \([past, future]\), of a system timeline \(X\)
there exists a system timeline \(Y\) in which the sequence of events is a
permuation of of the sequence of events in \(X\), and
where <i>all \(past\) events occur <str>before</str> all
\(future\) events</i>.
</h5>
<hr class="new2">
<p>
The proof follows directly from the theorem on the permutation of
event sequences.
We create a system  timeline \(Y\) with the same agent
timelines as system timeline \(X\).
The theorem tells us that \(Y\)
also represents a trajectory if the event timelines are the same in
\(X\) and \(Y\) and <i>each message is received only
after it is sent</i> in \(Y\).
We can create a system timeline \(Y\) in which all \(past\) events occur
before all \(future\) events because there are no messages from
\(future\) to \(past\).
<p>
We permute events to get \(Y\) as follows: if there is a pair of adjacent events
in which a \(future\) event occurs before the \(past\) event
then flip the order of this pair of events. The theorem on the permutation of
event sequences says that the sequence of events
after flipping the order of events is also a valid timeline because
there is no message from a \(future\) event to a \(past\) event in a
consistent cut. Repeatedly flip out-of-order adjacent events until all 
\(future\) events occur after all \(past\) events.

<h4 style="color:red;">Example</h4>
The cut in the diagram on the top of figure 7 is consistent.
Therefore, there exists a system timeline diagram, shown at the bottom of the
figure, in which all past events occur before all
future events.


<h4 class="w3-text-teal">Corollary: Trajectory from Initial to Snapshot to Final State</h4>
Consider an algorithm that computes the state at a consistent
cut. Let \(s_{init}\) and \(s_{fini}\) be the states in which the
algorithm starts and finishes (respectively), and let \(s_{snap}\) be
the state at the consistent cut.
<hr class="new2">
<h5 style="color:blue;">
There exists a trajectory from
\(s_{init}\) that visits \(s_{snap}\) and later visits \(s_{fini}\).
</h5>
<hr class="new2">

<p>
For example, an algorithm in the top diagram of figure 7 determines
the global state \(s_{snap}\) along the curved consistent cut during a
trajectory. Let \(s_{init}\) and \(s_{fini}\) be the states before the
algorithm starts and after it finishes, i.e. at the left and
right-hand ends of the system timeline diagram. Then, the diagram in the
lower diagram of figure 7 also represents a trajectory 
from \(s_{init}\) to \(s_{snap}\) and then to \(s_{fini}\).


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
