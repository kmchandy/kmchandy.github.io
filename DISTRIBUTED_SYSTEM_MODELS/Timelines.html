<title>Timelines.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


  
<!--------------------------------------------------------->
<h1 class="w3-text-teal">Timelines, Causality Graphs and Cuts</h1>
<!--------------------------------------------------------->

  <p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/DISTRIBUTED_SYSTEM_MODELS/DistributedSystemModels.html">
  Distributed System Models.</a>
  </p>

  <!------------------------------------------------------------------->
  <h4 class="w3-text-red">
  <i>Central Ideas</i></h4>

  <p class="w3-text-red">
  (1) Timelines. (2) Causality graphs. (3) Consistent cuts of computations
  </p>
  
  <p class="w3-text-red">
  <i>Causality graphs and consistent cuts of computations are the
  foundation of many distributed algorithms.</i> 
  </p>
  These ideas are described in terms of timelines.


 
  <!---------------------------------------------------------------->
  <h2 class="w3-text-teal">Timelines</h2>
  <!---------------------------------------------------------------->
  A <i>timeline of a computation</i> is a labeled, directed, acyclic graph in
  in which a vertex represents a step; vertices are laid
  out from left to right in the order of steps in the computation; and edges are as
  follows:
  <ol>
    <li>
    <i>Agent Edges</i>: There is an edge from (the vertex representing) a step in which an
    agent executes an action to the next step in which that agent
    executes an action. The edge is labeled with the state of the agent between the steps.
    </li>
    <li>
    <i>Message Edges</i>: There is an edge from a step in which a
    message is sent to the step in which the message is received; the
  edge is labeled with the message.
    </li>
  </ol>
  
  
  <!---------------------------------------------------------------->
  <h3 class="w3-text-teal">Historical Timelines</h3>
  <!---------------------------------------------------------------->
  
A <a href="https://en.wikipedia.org/wiki/Timeline">timeline</a> in
history and archaeology is a display of a sequence of events at the
times at which they occurred.  The length of the interval between
events represents the time elapsed between them. 

  <h4 style="color:red;">Example</h4>
  <figure>
    <img src="HistoricalTimeline.001.jpeg" alt="Fig001" style="width:60%">
    <figcaption>Fig.1: A Partial Historical Timeline of Microsoft and IBM</figcaption>
  </figure>

  The example shows an incomplete and selective timeline of IBM and
  Microsoft over a short interval.
</p>

  <!---------------------------------------------------------------->
  <h3 class="w3-text-teal">Time</h3>
  <!---------------------------------------------------------------->

  
  <p>
  The <a href="DistributedSystemModels.html">
  model of distributed systems</a>, which we gave earlier,
  has no concept of time.

A computation is specified by an initial state and a sequence of
events, but the times of events are not specified.
The only notion of time in a computation is that of <i>before</i> and
<i>after</i>.
For example, an event \(e\) occurs after an event \(e'\) in a
computation. 
Later we introduce the idea an event occurring
<i>eventually</i> in a computation.
For instance a message that is sent is delivered eventually but the
time interval between sending and receiving the message is left
unspecified. 


<p>
Agents in many distributed systems have local clocks that are are
synchronized (imperfectly) with the local clocks of
other agents. We will describe algorithms that use 
<a href="https://en.wikipedia.org/wiki/Network_Time_Protocol"> the
Network Time Protocol (NTP)</a> and <a
href="https://en.wikipedia.org/wiki/Precision_Time_Protocol"> the
Precision Time Protocol (PTP)</a> to synchronize clocks.
Cyberphysical systems, such as fleets of autonomous vehicles, can only
be studied by using models that include physical time.

<p>

Later, we study distributed systems, models, and algorithms that use
local clocks and incorporate time.
In this page, however, we restrict attention to
the <a href="DistributedSystemModels.html">
  simple model</a>, which has no concept of time other than
ordering of events.

  
  <!--------------------------------------------------------->
  <h3 class="w3-text-teal">From Agent Logs to Computations</h3>
<!--------------------------------------------------------->

An agent can keep a log of the sequence of events at that agent.

An event at an agent is specified by the state of the agent before and
after the event; the messages (if any) received and the messages (if
any) sent in the event.

<p>
Consider the following problem.
Each agent keeps a log of the sequence of events at that agent during
a computation.
The problem is to determine the computation -- the total ordering of
events -- that generated the logs.
Initially all channels are empty.

<h4 style="color:red;">Example: From Agent Logs to Computations</h4>

<p>
The diagram at the bottom in figure 1 shows logs of agents
\(A\) and \(B\). The computation has an event \(a0\) followed by event
\(a1\) at agent \(A\), and an event \(b0\) followed by event
\(b1\) on agent \(B\). In event \(a0\) agent \(A\) sends a message to agent
\(B\), and in \(a1\), \(A\) receives a message sent by \(B\). Likewise, in
\(b0\), \(B\) sends a messaget
\(A\), and in event \(b1\), \(B\) receives a message sent by \(A\).

<figure>
    <img src="DISTRIBUTED_SYSTEM_MODELS_TIMELINES/
DISTRIBUTED_SYSTEM_MODELS_TIMELINES.001.jpeg" alt="Fig1" style="width:100%">
    <figcaption>Fig.1: Composing Agent Logs to get Computations</figcaption>
</figure>

<p>
The diagram at the top left of figure 1 shows a computation \(a0, b0,
a1, b1\) while the diagram at the top right shows computation \(b0,
a0, b1, a1\).
In the top left diagram \(a1\) occurs before \(b1\), whereas in the
top right diagram \(b1\) occurs before \(a1\).
Both computations, however, produce the same agent
logs. So, we cannot uniquely determine the computation that generated
the agent logs.

<p>
The agent logs give us some information about the computation.
The logs tell us that \(a1\) occurred after \(a0\) and
\(b1\) occurred after \(b0\).
A message can be received only after it is sent.
Initially, channels are empty.
So the message received in \(b1\) is the message sent in
\(a0\). 
So the logs also tell us that \(b1\) occurred
after \(a0\), and \(a1\) occurred after \(b0\).
The information from agent logs is represented in a <i>causality
graph</i> in which vertices are events and the edges specify which
events must happen after which events.

  <!--------------------------------------------------------->
  <h3 class="w3-text-teal">Causality Graphs</h3>
<!--------------------------------------------------------->
The vertices of the causality graph represent events in a computation.
The labeled directed edges of the graph are as follows:
<ul>
  <li>
  <i>Agent timeline edges</i>:
  There is an edge directed from an
  event \(e\) at an agent \(A\) to the next event \(e'\) at \(A\).
  The edge is
  labeled with \(A\)'s state immediately after \(e\).
  </li>
  <li>
  <i>Message edges</i>
  A message \(m\) sent along a channel \(c\) at an event \(e\) and received at an event
    \(e'\) is represented by an edge directed from \(e\) to \(e'\),
  and the edge is labeled \(m, c\). In the examples, there is at most
  one channel from an agent \(A\) to an agent \(A'\), and so we drop
  the channel and use just \(m\) as the label.
  </li>
</ul>

<p>
A computation specifies a single causality graph;
however, a causality graph may be generated by more than one
computation.

<h4 class="w3-text-teal">Topological Sorts of Graphs</h4>
A topological sort of a graph is a sequence of vertices of the graph
such that for all edges \((e', e)\) in the graph \(e'\) occurs before
\(e\) in the sequence. 

<hr class="new2">
<h4 style="color:blue;">
Theorem: 
All topological sorts of a causality graph are computations.
</h4>
<hr class="new2">


<p class="w3-text-teal">Proof</p>

<p>
If \(X\) is different from \(Y\) then there is an adjacent pair of
events \(e_{0}, e_{1}\) in \(X\) where \(e_{0}\) occurs before \(e_{1}\) in \(X\) but \(e_{0}\)
occurs after \(e_{1}\) in \(Y\).
There are no edges between \(e_{0}\) and \(e_{1}\) in \(G\) because \(e_{1}\) occurs before
\(e_{0}\) in \(Y\), and \(e_{0}\) occurs before
\(e_{1}\) in \(X\).
<p>
Therefore \(e_{0}\) and \(e_{1}\) occur on different agents, and there is no
message sent in \(e_{0}\) that is received in \(e_{1}\), and there is no
message sent in \(e_{1}\) that is received in \(e_{0}\).
Events \(e_{0}\) and \(e_{1}\) are similar to events \(a1\) and \(b1\) in the
top left of figure 1.

<p>
Let \(X^{(1)}\) be the sequence identical to \(X\) except that order of
\(e_{0}\) and \(e_{1}\) is flipped. It is easy to prove that \(X^{1}\) is also a
computation.

<p>
By repeatedly flipping adjacent out-of-order events we can produce a
sequence of computations \(X, X^{(1)}, X^{(2)}, \ldots\) that terminates
in \(Y\).

<h3 class="w3-text-teal">Timeline of a Computation</h3>
A <i>timeline</i> is a diagrammatic representation of a
computation.
A timeline of a computation is the causality graph of the computation
in which events (vertices) are placed in the sequence in which they
occur in the computation.
By convention later events are placed to the right of earlier events,
and all events at the an agent are placed on a horizontal line.
<h4 style="color:red;">Example</h4>
<figure>
    <img src="Timelines.001.jpeg" alt="Fig2" style="width:100%">
    <figcaption>Fig.2: A Timeline</figcaption>
</figure>

<p>
The horizontal line representing the events at an agent is called the
agent's timeline.
An edge along an agent's timeline is labeled with the state of that
agent at the point. For example, the edge from event A1 to event A2 is
labeled \(S[A1]\) which is agent \(A\)'s state after event
A1 and before event A2.

<p>
Event A1 is an example of an internal event in which an agent changes
state without receiving a message.
Event A2 is an example of an event in which an agent changes
state when it receives a message.



<h4 class="w3-text-teal">The Global State at a point in a
Timelines</h4>
The global state of the system at a point \(T\) on a timeline can be
obtained from labels of edges cut by a vertical line at point \(T\).
We call the vertical line at \(T\), the \(T\)-line. 
<h4 style="color:red;">Example</h4>
<figure>
    <img src="Timelines.002.jpeg" alt="Fig2" style="width:100%">
    <figcaption>Fig.2: Global State from a System Timeline</figcaption>
</figure>


The state of an agent \(A\) at \(T\) is the label of the
edge on \(A\)'s timeline cut by the \(T\)-line.  
The state of a channel \(c\) at point \(T\) in a computation is the sequence (in time
order) of messages that are sent along \(c\) before \(T\) and that are
received after \(T\). The state of \(c\) at \(T\) is the sequence
of edge labels representing
messages along \(c\) that are cut by the \(T\)-line.
<p>
In the figure, the state of channel \(c\) at time \(T\) is the sequence of labels, \([m_{1},
m_{2}]\), of edges representing messages on \(c\) that are cut by the
\(T\)-line. 



<h2 class="w3-text-teal">Cuts of Computations</h2>
<p>
A <i>cut of a computation</i> is a partition of the events in the
computation into sets <i>past</i> and <i>future</i>.

<h5 class="w3-text-teal">Consistent Cuts of Computations</h5>
A <i>consistent cut of a computation</i> is a cut \((past, future)\) such that
all edges in the causality graph to events in \(past\) are from events in
\(past\).
Equivalently, a consistent cut of a computation is a cut \((past,
future)\) such that all edges in the causality graph from future events
are to future events.

<h4 style="color:red;">Example</h4>
The figure below shows consistent cuts across two system computations
where past events are colored black and future events are green.
<figure>
    <img src="Timelines.007.jpeg" alt="Fig7" style="width:100%">
    <figcaption>Fig.7: Consistent Cuts of Computations</figcaption>
</figure>
An instant \(T\) in the
lower timeline is represented by the vertical purple line which separates
past events shown in black (A0, A1, B0, B1, D0, D1) from future events
shown in green.  The states of agents A, B, D are their states
immediately after events A1, B1, and D1, respectively. The states of
channels are the sequences of message lines from the past to the
future. For example, at \(T\), message \(u_{0}\) has been sent in past
event B1, and has yet to be received.

<p>
The upper timeline shows the same sets of past and future events in
black and green, respectively. The vertical line representing the
instant \(T\) in the lower timeline corresponds to a curvilinear line
in the upper timeline.

<p>
An example of an inconsistent cut is the set <i>past</i> of events {A0, A1, A2,
B0, D1}. This cut is inconsistent because there is an edge (D1, A2) of
the causality graph from an event, D1, in the <i>future</i> to an
event, A2, in the <i>past</i>.

<hr class="new2">
<h4 style="color:blue;">
Consistent Cut Theorem
</h4>
<h6 style="color:blue;">
Let \((past, future)\) be a consistent cut of a computation that starts in a state \(S\) and ends
in a state \(S'\). There exists a computation that starts in \(S\) and
ends in \(S'\) and in which all events in \(past\) occur in the
computation before any event in \(future\).
</h6>
<hr class="new2">

<p class="w3-text-teal">Proof</p>
For a consistent cut \((past, future)\) there are no edges of the
causality graph from future to past.
Therefore there is
a topological sort of the causality graph of the computation in which 
all events in the past appear before all events in the future.
All topological sorts of the causality graph are computations.

<h4 style="color:red;">Example</h4>
The cut in the diagram on the top of figure 7 is consistent.
Therefore, there exists a system timeline diagram, shown at the bottom of the
figure, in which all past events occur before all
future events.
<p>
This result is helpful in developing algorithms that detect properties
of the states of computations.



<hr class="new2">
<h4 style="color:blue;">
Consistent Cut Corollary
</h4>
<h6 style="color:blue;">
Let \(S*\) be the state at a consistent cut of a computation that starts in a state \(S\) and ends
in a state \(S'\). There exists a computation that starts in \(S\),
visits \(S*\) and then visits \(S'\).
</h6>
<hr class="new2">

<p class="w3-text-teal">Proof</p>
Let \(S*\) be the state at a consistent cut \((past, future)\) of a
computation that starts in \(S\) and ends in \(S'\).
From the consistent cut theorem there is a computation \(C\) that starts in
\(S\) and ends in \(S'\), and in which all \(past\) events occur
before any \(future\) event.
Computation \(C\) starts in \(S\),
visits \(S*\) and then visits \(S'\).



<h4 class="w3-text-red">
<i>Central Ideas: Review</i></h4>
<p class="w3-text-red">
Timelines help in understanding distributed algorithms.
Causality graphs show how events depend on each other.
All topological sorts of causality graphs are computations.
A consistent cut is a partition of the set of events in a computation
into subsets <i>past, future</i>, where all edges
in the causality graph to the past are from the past.

<p class="w3-text-red">
<i>Concepts</i>:
Timelines -> causality graphs -> topological sorts of causality graphs
are computations -> consistent cuts.
</p>


<h3 class="w3-text-teal">Next</h3>
Next read about
<a href="../ChannelSnapshots/ChannelSnapshots.html">
the global snapshot algorithm by which agents determine the state at a
consistent cut.

<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
