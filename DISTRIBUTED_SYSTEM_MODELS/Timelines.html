<title>DistributedSystemModels/Timelines.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

<h2 class="w3-text-teal">Computations and Events</h2>

  
  This page specifies the set of system computations that have the
  same event graph, and hence the same agent computations.
  
  <p>
  We begin with a review of reachability in  graphs.

<p class="w3-text-teal">Reachability in a Graph</p>

A vertex \(e'\)
<a href="https://en.wikipedia.org/wiki/Reachability">
is reachable from
</a> 
a vertex \(e\) exactly when there is a (non-empty) path in the graph from
\(e\) to \(e'\).

An event graph is acyclic because edges are directed from events
  to later events.

  So, the
  <a href="https://en.wikipedia.org/wiki/Reachability">
  reachability relation is a partial order.
  </a>
  

<p class="w3-text-teal">Input-Closed Vertex Sets</p>

  A subset \(H\) of vertices of a directed acyclic graph is <i>input
  closed</i> exactly when every edge to every vertex in \(H\) is from a
  vertex in \(H\).
  
  <p>
  There is no path into an input-closed subgraph from a vertex outside
  it; 
  
  there may, however, be paths from inside an input-closed subgraph to
  vertices outside it. 

  


<!---------------------------------------------------------------->
<h5 style="color:red;">Example: Reachability</h5>

  Figure 1 is the event graph from figure 6 of the
  <a href="DistributedSystemModels.html">previous page.</a>
  
<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.014.jpeg"
    alt="Fig14" style="width:50%"> 
    <figcaption>Fig.1: Example of Reachability</figcaption>
  </figure>

Events 0, 1, 2 can reach event 5 in figure 1.

  Events 3, 4, 5, 6, 7 cannot reach event 5.

<p>
Examples of vertex sets that are input closed are \(\{0, 1, 2\}\),
and  \(\{0, 1, 2, 5\}\).

An example of a vertex set that is not input closed is \(\{0, 1,
3\}\) because there is an edge to vertex \(3\) from vertex \(2\) which
is not in the subgraph.



<!----------------------------------------------------------------->
<h3 class="w3-text-teal">System States and the Event Graph</h3>
<!----------------------------------------------------------------->

We define the state \(S\) of an input-closed vertex set \(H\) of an event
graph as follows.

\(S\) is specified by the labels of edges from
  vertices inside \(H\) to vertices outside \(H\).

The state of an agent \(u\) in \(S\) is the label of the agent \(u\)
edge from a vertex inside \(H\) to a vertex outside \(H\).

The state of a channel \((u, v)\) in \(S\) is the sequence of labels
of \((u, v)\) edges from vertices inside \(H\) to vertices outside \(H\).




<!------------------------------------------------------------------>
<h4 style="color:red;">Example: State after a Set of Events</h4>
<!------------------------------------------------------------------>

<p>
Let's look state \(S_{3}\) of the
input-closed event set \(H = \{0, 1, 2, 3\}\) in figure 1.

A vertical line between events 3 and 4 is a boundary between vertices
in \(H\) and vertices outside it.

\(S_{3}\) is determined by the labels of edges that cross the
boundary.

<p>
The boundary line intersects the agent edge for
\(u\) at an edge with label "e" signifying empty; so, \(u\) holds no tokens in
\(S_{3}\).

The line intersects the edges for channel \((v, u)\) at a single edge
and that edge has label "red token" and so the state of the \((v, u)\)
in \(S_{3}\) is a sequence of messages consisting of a single message
-- the red token.

The line does not intersect an edge for the channel \((u, v)\), and so
the state of this channel is the empty sequence of messages.

The states of other agents and channels are determined similarly.


<p>
The state \(S_{i}\) that occurs in a computation after events \(0,
\ldots, i\) are obtained similarly and are shown in figure 2.

The lower part of figure 2 shows the event graph and
the upper part shows the sequence of states in the
computation.

The dotted vertical lines show boundaries of event sets \(0,
\ldots, i\), for all \(i\).



<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.007.jpeg"
    alt="Fig6" style="width:100%"> 
    <figcaption>Fig.2: Example - System States in the Event Graph</figcaption>
</figure>




<!------------------------------------------------------------------>
<h3  class="w3-text-teal">State Transitions and Events</h3>
<!------------------------------------------------------------------>
<p  class="w3-text-teal">Theorem</p>

Let \(H\) and \(H'\) be input-closed subsets of events of an event graph, and
let \(H\) be a subset of \(H'\), where \(H'\) has exactly one more event
than \(H\) does.


 There exists a transition from the state of \(H\) to the state of
\(H'\).


<p  class="w3-text-teal">
Proof
</p>
The state associated with \(H\) is specified by the labels of
edges that cross the \(H\) boundary.

Because \(H'\) is input closed, the edges that cross the \(H\)
boundary include the inputs to \(e\).

So, event \(e\) can occur after events in \(H\).

Therefore there is a transition from the state associated with
\(H\) to the state associated with \(H'\).


<h5 style="color:red;">Example of State Transition</h5>
There is a transition from the states of 
\(\{0, 1, 2, 5\}\) to \( \{0, 1, 2, 5, 3\}\).

<p>
The edges that cross the boundary from the vertex set \(\{0, 1, 2,
5\}\) include the input edges to vertex \(3\), which are \((2, 3)\)
and \((1, 3)\).

So event \(3\) can occur after events \(\{0, 1, 2, 5\}\) have
occurred. 


<!------------------------------------------------------------------>
<h4 class="w3-text-teal">Topological Sort</h4>
<!------------------------------------------------------------------>

A topological sort of a directed acyclic graph is a sequence of
vertices in which a vertex appears after all vertices that can reach
it.

<h5 style="color:red;">Example of a Topological Sort</h5>
In figure 2 \([0, 2, 1, 3, 4, 5, 6, N]\) is an example of a
topological sort.

The sequence \([0, 1, 3, 2, 4, 5, 6, N]\) is not a topological sort
because vertex 3 appears before vertex 2 in the sequence and vertex 2
can reach vertex 3.

<!------------------------------------------------------------------>
<!------------------------------------------------------------------>
<h3 class="w3-text-teal">All Topological Sorts of
Event Graphs are Computations</h3>
<!------------------------------------------------------------------>
<!------------------------------------------------------------------>
<p class="w3-text-teal">Theorem</p>

All topological sorts of event graphs are computations. </p>

<p class="w3-text-teal">Proof</p>

The set consisting of the first \(i\) events of a topological
sort \(Q\) is input closed, for all \(i\). 

From the previous theorem there is a
transition from the state of the set consisting of the first
\(i\) events of \(Q\) to the state of the set consisting of the first
\(i+1\) events of \(Q\).


<!------------------------------------------------------------------>
<h4 style="color:red;">Example: Topological Sorts of Event
Graphs are Computations</h4> 
<!------------------------------------------------------------------>

The figure below shows system computations with the same event graph.

The agent computations of \(u\) and \(v\) are the same in both system
computations.


<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.010.jpeg"
    alt="Fig6" style="width:100%"> 
    <figcaption>Fig.2: Example - Computations with the same Event Graph</figcaption>
</figure>



<!------------------------------------------------------------------>
<h5 class="w3-text-teal">Corollary</h5>

For all input-closed event sets \(H, H'\) where \(H\) is a subset of
\(H'\) there exists a computation from \(H\) to \(H'\). 

An example of such a computation is the topological sort of \(H' -
H\).




<!------------------------------------------------------------------>
<p style="color:red;">Example of Computation from Set to Superset of
Events </p>
<!------------------------------------------------------------------>
The corollary tells us that there exists a computation from \(\{0, 2\}\)
to \(\{0, 1, 2, 5\}\). 



<!------------------------------------------------------------------>
<h4 class="w3-text-teal">System Computations with Identical Agent Computations</h4>
<!------------------------------------------------------------------>

In figure 2 we see that different system computations have
the same agent computations. 

The next theorem identifies the set of system computations with the
same agent computations.


<p class="w3-text-teal">Theorem</p>

Let \(Q\) be a sequence of events in a system computation.

A permutation \(R\) of \(Q\) is also a computation if
<ol>
  <li>
  all agent computations are the same \(R\) and \(Q\), and
  </li>
  <li>
  each message is received only after it is sent in \(R\).
  </li>
</ol>

<p class="w3-text-teal">Proof</p>
For all edges \(e, e'\) in the event graph of \(Q\), \(e\) appears
before \(e'\) in \(R\) if the edge is an event edge (follows from part
1), and if the edge is a message edge (from part 2).



<!------------------------------------------------------------------>
<h5 style="color:red;">Example System Computations with Identical Agent
Computations</h5>
<!------------------------------------------------------------------>

Given that the event sequence \(Q = [0, 1, 2,..]\) in the
top diagram is a computation, the theorem tells us that the
sequence \(Q' = [0, 2, 1, \ldots, ]\) of the lower diagram is also a
computation because the sequences of events at agent \(u\) (\([0, 1, 5, 6,
N]\)) and agent \(v\) \([0, 2, 3, 4, N]\) are the same in both
\(Q\) and\(Q'\), and every message is received after it is sent in \(Q'\).




<h3 class="w3-text-teal">Next</h3>
Next look at
<a href="Timelines.html">Timelines of Computations.</a>
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
