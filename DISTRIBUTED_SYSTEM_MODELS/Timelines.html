<title>Timelines.html</title>
<title>Timelines</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


  
<!--------------------------------------------------------->
<h1 class="w3-text-teal">Timelines</h1>
<!--------------------------------------------------------->

  <p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/DISTRIBUTED_SYSTEM_MODELS/DistributedSystemModels.html">
  Distributed System Models.</a>
  </p>

  <p class="w3-text-red">
  
  The concepts of a timeline and a cut of a computation form the
  foundation of a large number of distributed algorithms.
  
  </p>

  <!---------------------------------------------------------------->
  <h3 class="w3-text-teal">Historical and Computation Timelines</h3>
  <!---------------------------------------------------------------->
  
A <a href="https://en.wikipedia.org/wiki/Timeline">timeline</a> in
history and archaeology is a
display of a sequence of events at the times at which they occurred.
The length of the interval between events represents the time elapsed
between them.
You may find it helpful to think of a computation timeline in the same
way, with events displayed at the times at which they occur.  When we
work with systems in which message delays are arbitrary, the absolute
(i.e. "real" or "true") time is irrelevant --- only the
interdependence of events matters.

  <h4 style="color:red;">Example</h4>
  <figure>
    <img src="HistoricalTimeline.001.jpeg" alt="Fig001" style="width:100%">
    <figcaption>Fig.1: A Partial Historical Timeline of Microsoft and IBM</figcaption>
  </figure>

  The example shows an incomplete and selective timeline of IBM and
  Microsoft over a short interval.
  </p>

<p class="w3-text-teal">Agent Clocks</p>
Agents in many distributed systems have local clocks that are are
synchronized (though imperfectly) with the local clocks of
other agents. Later, we will describe algorithms that use protocols such as
<a href="https://en.wikipedia.org/wiki/Network_Time_Protocol"> the
Network Time Protocol (NTP)</a> and <a
href="https://en.wikipedia.org/wiki/Precision_Time_Protocol"> the
Precision Time Protocol (PTP)</a> to synchronize agent clocks.  The
timeline displays events at their true times; however, the time of an
event, as determined by an agent's local clock, may deviate from the
true time.

<p>
For the remainder of this section, the points at which events appear
in the timeline is irrelevant. All that matters is the order of
events. 

  
  <!--------------------------------------------------------->
  <h3 class="w3-text-teal">Timelines and Causality Graphs</h3>
  <!--------------------------------------------------------->
  <p>
  A computation is specified by an initial state and a sequence of
  events.  A <i>timeline</i> is a graph representation of a
  computation.  A timeline of a computation is a labeled directed
  acyclic graph, called a <i>causality graph</i>, and an ordering of
  vertices.  The vertices of the causality graph represent events, and
  the vertices are ordered in the order in which events occur in the
  computation.  The edges of the graph are as follows:
<ul>
  <li>
  <i>Agent timeline edges</i>:
  There is an edge directed from an
  event \(e\) at an agent \(A\) to the next event \(e'\) at \(A\).
  The edge is
  labeled with \(A\)'s state immediately after \(e\).
  </li>
  <li>
  <i>Message edges</i>
  A message \(m\) sent along a channel \(c\) at an event \(e\) and received at an event
    \(e'\) is represented by an edge directed from \(e\) to \(e'\),
  and the edge is labeled \(m, c\). In the examples, there is at most
  one channel from an agent \(A\) to an agent \(A'\), and so we drop
  the channel \(c\) from the label, and use just \(m\) as the label.
  </li>
</ul>

<h4 style="color:red;">Example</h4>
<figure>
    <img src="Timelines.001.jpeg" alt="Fig1" style="width:100%">
    <figcaption>Fig.1: A Timeline</figcaption>
</figure>
This example shows a timeline with two agents, \(A\) and
\(B\).  The vertices  A1, A2, A3 represent events at agent \(A\);
likewise vertices B1 B2, represent \(B\)'s events. Vertices A0 and B0
represent the start of the execution. The vertices representing the
end of the execution are not shown; instead edges from the last events
(A3, B2) on agents \(A, B\) are shown as dangling edges with no
terminal vertex. 

<p>
An edge along an agent's timeline is labeled with the state of that
agent at the point. For example, the edge from event A1 to event A2 is
labeled \(S[A1]\) which is agent \(A\)'s state after event
A1 and before event A2.

<p>
Event A1 is an example of an internal event in which an agent changes
state without receiving a message.
Event A2 is an example of an event in which an agent changes
state when it receives a message.

<p>
The diagram shows that
agent \(A\) sends message \(m_{0}\) in event A1 and this message is
received by agent \(B\) in event B1.


<h4 class="w3-text-teal">Initial state of the computation</h4>
For each agent \(A\), there is an initial event that represents the
  initiation of the computation. The initial state of agent \(A\) in
  the computation is
its state immediately after its initial event.

<p>
Let \(c\) be an outgoing channel of agent \(A\).
The initial state of \(c\)  is the sequence of messages
in transit along \(c\) when the computation starts.
This sequence of messages can be obtained from the timeline: It is the
sequence of outgoing messages along channel \(c\) from the initial
event at \(A\).

<p>
So, the initial global state of the system --- the initial states of
all agents and 
channels --- can be determined by the labels of edges from the initial
events.

<h4 class="w3-text-teal">Convention</h4>
We adopt the convention that time increases from left to right with
earlier events appearing to the left of later events.
Events at the same agent are shown on the same horizontal
line which we call the <i>agent's timeline.</i>
An instant in time
is represented by a vertical line that cuts through the
timeline at that instant. 

<h4 class="w3-text-teal">Channel States in System Timelines</h4>
The state of a channel \(c\) at point \(T\) in a computation is the sequence (in time
order) of messages that are sent along \(c\) before \(T\) and that are
received after \(T\). The state of \(c\) at \(T\) can be obtained from
the timeline as follows. Let \(T\)-line be the vertical line
at \(T\). The state of \(c\) at \(T\) is the sequence of labels of edges representing
messages along \(c\) cut by the \(T\)-line. 

<h4 style="color:red;">Example</h4>
<figure>
    <img src="Timelines.002.jpeg" alt="Fig2" style="width:100%">
    <figcaption>Fig.2: Global State from a System Timeline</figcaption>
</figure>
Figure 2 shows a system
timeline with agents \(A, B, D\). Agent \(A\) sends messages
\(m_{0}\) along a channel \(x\) and sends \(m_{1}\) along\(e\) is before \(e'\) in \(X\) a different
channel \(c\) at event A1.  When agent \(D\) receives \(m_{0}\) at
event D1 it sends message \(r_{0}\) to \(A\) along a channel \(y\).
When agent \(A\) receives \(r_{0}\) at event A2 it sends message
\(m_{2}\) to \(B\) along channel \(c\).  When agent \(B\) receives
message \(m_{1}\) at event B1 it sends message message \(u_{0}\) to
\(A\) along a channel \(v\).

<p>
The state of \(c\) at time \(T\) is the sequence of labels, \([m_{1},
m_{2}]\), of edges representing messages on \(c\) that are cut by the
\(T\)-line.  The state of an agent \(A\) at \(T\) is the label of the
edge on \(A\)'s timeline cut by the \(T\)-line.  So, the global state
of the system at T can be obtained from labels of edges cut by the
\(T\)-line.


<p class="w3-text-teal">Sequence of Global States in Timelines</p>
The sequence of <i>global</i> states in a computation can be 
obtained from the system timeline from the labels of edges cut by the
sequence of vertical lines between successive events.

<h4 style="color:red;">Example</h4>
<figure>
    <img src="Timelines.003.jpeg" alt="Fig3" style="width:100%">
    <figcaption>Fig.3: Global States in the Computation</figcaption>
</figure>
The sequence of global states in this computation correspond to the
states at the vertical lines in the figure. There are vertical lines
between successive events, and the states of agents and channels are
determined by the labels intersected by the vertical lines.
The initial global state of the computation corresponds to the agent
and channel states at the vertical line immediately after the initial
events A0, B0, D0.



<h3 class="w3-text-teal">Different Timelines with Identical Causality Graphs</h3>
A timeline represents a computation: the initial global state is specified by
the initial events, and the sequence of events is specified by the
timeline.
The edges of the graph are directed forwards in time, i.e. event \(e\)
appears before event \(e'\) in the computation if there is an
edge from \(e\) to \(e'\) in the causality graph.
<p>
What timelines have the same causality graph? Let's look at an example.

<h4 style="color:red;">Example: Different Timelines with Identical
Causality Graph</h4>
Figure 4 is a timeline for a computation that
has the same events as the one in figure 3.
The causality graphs are identical in figures 3 and 4; the difference in the
figures is the ordering of vertices. 
<figure>
    <img src="Timelines.004.jpeg" alt="Fig5" style="width:100%">
    <figcaption>Fig.4: Different Computations with Same Set of
Events</figcaption> 
</figure>
The computations start in the same state (represented by initial events
(A0, B0, D0)). The sequences of events in the figures are
[A1, D1, A2, B1, A3, B2] and
[A1, D1, B1, A2, A3, B2].
The sequence of global states are different in the two computations.
The global state after B1 and before A2 in the computation represented by
figure 4 is not visited in the computation represented by figure 3.


<h3  class="w3-text-teal">All Topological Sorts of Causality Graphs
 are Computations</h3>
A topological sort of a directed acyclic graph is a sequence of
vertices of the graph where for every edge from \(v'\) to \(v\) in the
graph, \(v'\) appears before \(v\) in the sequence.

<p style="color:red;">Example of topological sorts</p>
In a topological sort, all edges of the graph are directed forwards
--- from a vertex to a later vertex in the sort.
For example, [A1, D1, A2, B1, A3, B2] and [A1, D1, B1, A2, A3, B2] are
topological sorts of the causality graph shown in figures 3 and 4.
The sequence [D1, A1, A2, B1, A3, B2] is not a topological sort
 because the edge from A1 to D1 goes backwards --- D1 occurs before A1
 in the sequence.

<hr class="new2">
<h5 style="color:blue;">
Theorem: All topological sorts of the causality graph of a computation
that starts in a state \(S\) and ends in a state \(T\) are also
computations that start in \(S\) and end in \(T\).
</h5>
<hr class="new2">

<p class="w3-text-teal">Proof</p>
Let \(X\) be a computation that starts in state \(S\), and let \(Y\)
be a topological sort of the causality graph of the computation. Prove
by induction on \(k\) that for the first \(k\) events in \(Y\):
<ol>
  <li>
  the \(i\)-th event at an agent in \(Y\) is the same as \(i\)-th
  event at that agent in \(X\) , and
  </li>
  <li>
  the \(j\)-th message sent on a channel in \(Y\) is the same as the
  \(j\)-th message sent on that channel in \(X\), and
  </li>
  <li>
  the \(k\)-th message received on a channel in \(Y\) is the same as
  the \(k\)-th message received on that channel in \(X\), and
  </li>
  <li>
  a message is received in \(Y\) only after it is sent.
  </li>
</ol>
The induction step is straightforward.

<h4 style="color:red;">Example: Topological Sorts of Causality Graphs</h4>
The timeline of an agent \(A\) in a computation is 
the initial state of \(A\) and the sequence of events at \(A\)
in the computation.
An agent's timeline is represented by the horizontal line
corresponding to that agent in a system timeline.
In figures 3 and 4, the timelines of agents \(A, B, D\) are given by 
[A0, A1, A2, A3, A3], [B0, B1, B2], and [D0, D1] respectively.
Though the agent timelines are identical in both figures the system
timelines are different because the sequences of events (after the
initial events) in figures 3 and 4 are, respectively:
[A1, D1, A2, B1, A3, B2] and [A1, D1, B1, A2, A3, B2].
Both these sequences are topological sorts of the causality graph.


<h3 class="w3-text-teal">System Timelines with Identical Agent
Timelines</h3>
<hr class="new2">
<h5 style="color:blue;">
Theorem: Let \(X\) be the event sequence in a computation that starts in a
state \(S\) and ends in a state \(T\).
Any permutation \(Y\) of \(X\) is also a 
computation that starts at \(S\) and ends at \(T\) if:
<ol>
  <li>
  agent computations in \(X\) and \(Y\) are identical, and
  </li>
  <li>
  messages are received only after they are sent in \(Y\).
  </li>
</ol>
</h5>
<hr class="new2">


<p class="w3-text-teal">Proof</p>
System timelines with identical agent
computations have identical causality graphs. If messages are
received only after they are sent in the permutation then the
permutation is a topological 
sort of the causality graph, and therefore is a computation.


<h2 class="w3-text-teal">Cuts of Computations</h2>
<p>
A <i>cut of a computation</i> is a subset of events in the computation. We
call this subset <i>the past</i>. The subset of events in the computation
that are not in the past are called <i>the future</i>.  A
<i>consistent cut of a computation</i> is a cut in which where there are
all edges in the causality graph to events in the past are from events in
the past.

<h4 style="color:red;">Example</h4>
The figure below shows consistent cuts across two system computations
where past events are colored black and future events are green.
<figure>
    <img src="Timelines.007.jpeg" alt="Fig7" style="width:100%">
    <figcaption>Fig.7: Consistent Cuts of Computations</figcaption>
</figure>
An instant \(T\) in the
lower timeline is represented by the vertical purple line which separates
past events shown in black (A0, A1, B0, B1, D0, D1) from future events
shown in green.  The states of agents A, B, D are their states
immediately after events A1, B1, and D1, respectively. The states of
channels are the sequences of message lines from the past to the
future. For example, at \(T\), message \(u_{0}\) has been sent in past
event B1, and has yet to be received.

<p>
The upper timeline shows the same sets of past and future events in
black and green, respectively. The vertical line representing the
instant \(T\) in the lower timeline corresponds to a curvilinear line
in the upper timeline. 

<p>
The proof of the following statement is straightforward. A cut is
consistent if and only if there are no edges to past events from future
events; or equivalently, all edges from future events are to future
events.  

<hr class="new2">
<h5 style="color:blue;">
Consistent Cuts Theorem:
A cut of a computation that starts in a state \(S\) and ends in a
state \(T\) is consistent if and only if there exists a computation
that also starts in \(S\) and ends in \(T\), and in which
<i>all past events occur before all future events.</i>
</h5>
<hr class="new2">

<p class="w3-text-teal">Proof</p>
For all consistent cuts there exists
a topological sort in which 
all events in the past appear before all events in the future.
And, all topological sorts of the
causality graph are computations.

<h4 style="color:red;">Example</h4>
The cut in the diagram on the top of figure 7 is consistent.
Therefore, there exists a system timeline diagram, shown at the bottom of the
figure, in which all past events occur before all
future events.
<p>
This result is helpful in developing algorithms that detect properties
of the states of computations.


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
