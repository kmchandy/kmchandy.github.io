<title>Timelines.html</title>
<title>Timelines</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


  
<!--------------------------------------------------------->
<h1 class="w3-text-teal">Timelines</h1>
<!--------------------------------------------------------->

  <p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/DISTRIBUTED_SYSTEM_MODELS/DistributedSystemModels.html">
  Distributed System Models.</a>
  </p>

  <p class="w3-text-red">
  A timeline is a familiar concept in
  history. Timelines of computations help us 
  understand distributed algorithms.
  </p>

  <!--------------------------------------------------------->
  <h3 class="w3-text-teal">Timelines and Causality Graphs</h3>
  <!--------------------------------------------------------->
  <p>
  A computation is specified by
  an initial state and a
  sequence of events.
  A <i>timeline</i> is a graph representation of a computation.
  A timeline of a computation is a labeled
  directed acyclic graph, called a <i>causality graph</i>, and an ordering
  of vertices.  The vertices of the causality graph represent events,
  and the vertices are ordered in the order in which events occur in the computation.
  The edges of the graph are as follows:
<ul>
  <li>
  <i>Agent timeline edges</i>:
  There is an edge directed from an
  event \(e\) at an agent \(A\) to the next event \(e'\) at \(A\).
  The edge is
  labeled with \(A\)'s state immediately after \(e\).
  </li>
  <li>
  <i>Message edges</i>
  A message \(m\) sent along a channel \(c\) at an event \(e\) and received at an event
    \(e'\) is represented by an edge directed from \(e\) to \(e'\),
  and the edge is labeled \(m, c\). In the examples, there is at most
  one channel from an agent \(A\) to an agent \(A'\), and so we drop
  the channel \(c\) from the label, and use just \(m\) as the label.
  </li>
</ul>

<h4 style="color:red;">Example</h4>
<figure>
    <img src="Timelines.001.jpeg" alt="Fig1" style="width:100%">
    <figcaption>Fig.1: A Timeline</figcaption>
</figure>
This example shows a timeline with two agents, \(A\) and
\(B\).  The vertices  A1, A2, A3 represent events at agent \(A\);
likewise vertices B1 B2, represent \(B\)'s events. Vertices A0 and B0
represent the start of the execution. The vertices representing the
end of the execution are not shown; instead edges from the last events
(A3, B2) on agents \(A, B\) are shown as dangling edges with no
terminal vertex. 

<p>
An edge along an agent's timeline is labeled with the state of that
agent at the point. For example, the edge from event A1 to event A2 is
labeled \(S[A1]\) which is agent \(A\)'s state after event
A1 and before event A2.

<p>
Event A1 is an example of an internal event in which an agent changes
state without receiving a message.
Event A2 is an example of an event in which an agent changes
state when it receives a message.

<p>
The diagram shows that
agent \(A\) sends message \(m_{0}\) in event A1 and this message is
received by agent \(B\) in event B1.


<h4 class="w3-text-teal">Initial state of the computation</h4>
For each agent \(A\), there is an initial event that represents the
  initiation of the computation. The initial state of agent \(A\) in
  the computation is
its state immediately after its initial event.

<p>
Let \(c\) be an outgoing channel of agent \(A\).
The initial state of \(c\)  is the sequence of messages
in transit along \(c\) when the computation starts.
This sequence of messages can be obtained from the timeline: It is the
sequence of outgoing messages along channel \(c\) from the initial
event at \(A\).

<p>
So, the initial global state of the system --- the initial states of
all agents and 
channels --- can be determined by the labels of edges from the initial
events.

<h4 class="w3-text-teal">Convention</h4>
We adopt the convention that time increases from left to right with
earlier events appearing to the left of later events.
Events at the same agent are shown on the same horizontal
line which we call the <i>agent's timeline.</i>
An instant in time
is represented by a vertical line that cuts through the
timeline at that instant. 

<h4 class="w3-text-teal">Channel States in System Timelines</h4>
The state of a channel \(c\) at point \(T\) in a computation is the sequence (in time
order) of messages that are sent along \(c\) before \(T\) and that are
received after \(T\). The state of \(c\) at \(T\) can be obtained from
the timeline as follows. Let \(T\)-line be the vertical line
at \(T\). The state of \(c\) at \(T\) is the sequence of labels of edges representing
messages along \(c\) cut by the \(T\)-line. 

<h4 style="color:red;">Example</h4>
<figure>
    <img src="Timelines.002.jpeg" alt="Fig2" style="width:100%">
    <figcaption>Fig.2: Global State from a System Timeline</figcaption>
</figure>
Figure 2 shows a system
timeline with agents \(A, B, D\). Agent \(A\) sends messages
\(m_{0}\) along a channel \(x\) and sends \(m_{1}\) along\(e\) is before \(e'\) in \(X\) a different
channel \(c\) at event A1.  When agent \(D\) receives \(m_{0}\) at
event D1 it sends message \(r_{0}\) to \(A\) along a channel \(y\).
When agent \(A\) receives \(r_{0}\) at event A2 it sends message
\(m_{2}\) to \(B\) along channel \(c\).  When agent \(B\) receives
message \(m_{1}\) at event B1 it sends message message \(u_{0}\) to
\(A\) along a channel \(v\).

<p>
The state of \(c\) at time \(T\) is the sequence of labels, \([m_{1},
m_{2}]\), of edges representing messages on \(c\) that are cut by the
\(T\)-line.  The state of an agent \(A\) at \(T\) is the label of the
edge on \(A\)'s timeline cut by the \(T\)-line.  So, the global state
of the system at T can be obtained from labels of edges cut by the
\(T\)-line.


<p class="w3-text-teal">Sequence of Global States in Timelines</p>
The sequence of <i>global</i> states in a computation can be 
obtained from the system timeline from the labels of edges cut by the
sequence of vertical lines between successive events.

<h4 style="color:red;">Example</h4>
<figure>
    <img src="Timelines.003.jpeg" alt="Fig3" style="width:100%">
    <figcaption>Fig.3: Global States in the Computation</figcaption>
</figure>
The sequence of global states in this computation correspond to the
states at the vertical lines in the figure. There are vertical lines
between successive events, and the states of agents and channels are
determined by the labels intersected by the vertical lines.
The initial global state of the computation corresponds to the agent
and channel states at the vertical line immediately after the initial
events A0, B0, D0.


<h3 class="w3-text-teal">Timelines with Identical Causality Graphs</h3>
A timeline represents a computation: the initial global state is specified by
the initial events, and the sequence of events is specified by the
timeline.
The edges of the graph are directed forwards in time, i.e. event \(e\)
appears before event \(e'\) in the computation if there is an
edge from \(e\) to \(e'\) in the causality graph.
<p>
What timelines have the same causality graph? Let's look at an example.

<h4 style="color:red;">Example: Different Timeline with the same
Causality Graph</h4>
Figure 4 is a timeline for a computation that
has the same events as the one in figure 3.
The causality graphs are identical in figures 3 and 4; the difference in the
figures is the ordering of vertices. 
<figure>
    <img src="Timelines.004.jpeg" alt="Fig5" style="width:100%">
    <figcaption>Fig.4: Different Computations with Same Set of
Events</figcaption> 
</figure>
The computations start in the same state (represented by initial events
(A0, B0, D0)). The sequences of events in the figures are
[A1, D1, A2, B1, A3, B2] and
[A1, D1, B1, A2, A3, B2].
The sequence of global states are different in the two computations.
The global state after B1 and before A2 in the computation represented by
figure 4 is not visited in the computation represented by figure 3.


<h3  class="w3-text-teal"">Topological Sorts of Causality Graphs
 are Computations</h3>
A topological sort of a directed acyclic graph is a sequence of
vertices of the graph where for every edge from \(v'\) to \(v\) in the
graph, \(v'\) appears before \(v\) in the sequence.
<p>
In a topological sort, all edges of the graph are directed forwards
--- from a vertex to a later vertex in the sort.
For example, [A1, D1, A2, B1, A3, B2] and [A1, D1, B1, A2, A3, B2] are
topological sorts of the causality graph shown in figures 3 and 4.
The sequence [D1, A1, A2, B1, A3, B2] is not a topological sort
 because the edge from A1 to D1 goes backwards --- D1 occurs before A1
 in the sequence.

<hr class="new2">
<p style="color:blue;">
Theorem: Let \(G\) be the causality graph of a computation \(X\). Let \(Y\) be any
topological sort of \(G\). The initial global state specified by
\(G\) and the event sequence corresponding to the vertex sequence in
\(Y\) is a computation.
</p>
<hr class="new2">

<p class="w3-text-teal">Proof</p>
We will prove by induction on \(k\) that there exists a computation
with the same initial state as \(X\) and the event sequence consisting
of the first \(k\) events of \(Y\).
The base case is \(k = 0\).
We assume that the result holds for \(k < n\) and prove that it holds for
\(k = n\).

<p>
<p>
Let the \(n\)-th event of \(Y\) be event \(e\) at an agent
\(A\)
and let \(e'\) be the event immediately preceding \(e\) at agent \(A\).
Because \(Y\) is a topological sort of \(G\), event \(e'\) occurs
before \(e\) in \(Y\), and \(e'\) is the event 
immediately preceding \(e\) at \(A\) in \(X\).
Therefore the state of \(A\) immediately preceding \(e\) is the same
in \(X\) and \(Y\).

<p>
Consider the case where a message \(m\) along a
channel \(c\) is received in event \(e\) in \(X\).
Let \(m\) be the \(i\)-th message received along \(c\) in \(X\). 
Because \(Y\) is a topological sort of \(G\), in \(Y\) the event that sends the \(j\)-th
message along channel \(c\) appears before the event that receives the
\(j\)-th message along \(c\), for all \(j\).
Therefore, at least \(i\) messages are sent along \(c\) and exactly \(i-1\)
messages are received before \(e\) in \(Y\).
So, the state of channel \(c\) before event \(e\) in \(Y\) has the \(i\)-th
message, i.e., \(m\), at its head.
Therefore the messages, if any, received in \(e\) are the same in
\(X\) and \(Y\).

<p>
Because the state of the agent on which \(e\) occurs is the same in
\(X\) and \(Y\), and the messages received in \(e\) are the same in
\(X\) and \(Y\), it follows that \(e\) can be the \(n\)-th event in \(Y\).


<h3 class="w3-text-teal">System Timelines with Identical Agent
Timelines</h3>
<p class="w3-text-teal">Messages must be sent before they are received</p>
The timeline of an agent \(A\) in a computation is 
the initial state of \(A\) and the sequence of events at \(A\)
in the computation.
An agent's timeline is represented by the horizontal line
corresponding to that agent in a system timeline.
In figures 3 and 4, the timelines of agents \(A, B, D\) are given by 
[A0, A1, A2, A3, A3], [B0, B1, B2], and [D0, D1] respectively.
Though the agent timelines are identical in both figures the system
timelines are different because the sequences of events (after the
initial events) in figures 3 and 4 are, respectively:
[A1, D1, A2, B1, A3, B2] and [A1, D1, B1, A2, A3, B2].
The ordering of events on different agents is different in these
system timelines: A2 appears before B1 in figure 3 whereas A2 appears
after B1 in figure 4.
Are there even more system timelines with the same agent timelines?


<hr class="new2">
<p style="color:blue;">Theorem</p>
<p style="color:blue;">
Given a computation specified by an initial state \(S\) and event
sequence \(X\),
let \(Y\) be a permutation of \(X\) where the computation of each
agent is the same in \(X\) and \(Y\).
There exists a computation with initial state \(S\) and event
sequence \(Y\) if
<i>Every message is sent before it is received in \(Y\).</i>
<hr class="new2">
<h5 class="w3-text-teal">Proof</h5>
System timelines with identical agent
computations have identical causality graphs. If messages are
received only after they are sent in \(Y\) then \(Y\) is a topological
sort of the causality graph, and therefore is a computation.




<h2 class="w3-text-teal">Cuts of Timelines</h2>
An instant \(T\) in a timeline separates events
executed at or before \(T\) from events executed after \(T\).
We call events executed before \(T\), <i>past</i> events
at \(T\), and we call events executed after \(T\),  <i>future</i> events
at \(T\). We will not consider instances \(T\) where an event occurs
exactly at \(T\).

<p>
The figure below shows two timelines. An instant \(T\) in the
lower timeline is represented by the vertical purple line which separates
past events shown in black (A0, A1, B0, B1, D0, D1) from future events
shown in green.  The states of agents A, B, D are their states
immediately after events A1, B1, and D1, respectively. The states of
channels are the sequences of message lines from the past to the
future. For example, at \(T\), message \(u_{0}\) has been sent in past
event B1, and has yet to be received.

<p>
The upper timeline shows the same sets of past and future events in
black and green, respectively. The vertical line representing \(T\) in
the lower timeline is curvilinear in the upper timeline --- both these
lines partition the set of events into a past and future, where edges
that cross the lines are from the past to the future.

<p>
<i>A cut of a timeline</i> is a partition of the events in
the timeline into two subsets called <i>past</i> and <i>future</i>.


<hr class="new2">
    <h5 style="color:blue;">
A <i>consistent cut</i> is a cut in which there are no edges in the
    causality graph from
    future events to past events. 
</h5>
Equivalently a consistent cut is a cut in which all edges in the
    causality graph to past
    events are from past events, or equivalently all edges
    from future events are
    to future events.
<hr class="new2">


<h4 style="color:red;">Example</h4>
The figure below shows cuts across two system timelines
where past events are colored black and future events are green.
<figure>
    <img src="Timelines.007.jpeg" alt="Fig7" style="width:100%">
    <figcaption>Fig.7: Cuts of Timelines</figcaption>
</figure>

The cuts in both diagrams are identical: past events are A0, A1, B0,
D0, D1, and future events are A2, A3, B2.
The cuts are consistent because there is no edge from the
future to the past.
<p>
A purple vertical line, representing an instant in time, separates past from
future in the lower diagram.
By contrast, a curved line separates past from future in the upper
diagram. There is no vertical line that separates past (defined as A0,
A1, B0, D0, D1) from future in
the upper diagram because a past event (B1) appears after a future
event (A2).

<h3 class="w3-text-teal">Theorem about Consistent Cuts</h3>
<hr class="new2">
    <h5 style="color:blue;">
For any consistent cut, \([past, future]\), of a timeline \(X\)
there exists a timeline \(Y\) in which the sequence of events is a
permutation of of the sequence of events in \(X\), and
where <i>all \(past\) events occur <str>before</str> all
\(future\) events</i>.
</h5>
<hr class="new2">
<p>
The proof follows from the theorem that all topological sorts of the
causality graph are computations. There is a topological sort in which
all events in the past appear before all events in the future.

<h4 style="color:red;">Example</h4>
The cut in the diagram on the top of figure 7 is consistent.
Therefore, there exists a system timeline diagram, shown at the bottom of the
figure, in which all past events occur before all
future events.


<h4 class="w3-text-teal">Corollary: Computation from Initial State to
Consistent Cut to Final State</h4> 
Consider an algorithm that computes the state at a consistent
cut. Let \(s_{init}\) and \(s_{fini}\) be the states in which the
algorithm starts and finishes (respectively), and let \(s_{snap}\) be
the state at the consistent cut. The following result follows from the
theorem that all topological sorts of causality graphs are computations.
<hr class="new2">
<h5 style="color:blue;">
There exists a computation from
\(s_{init}\) that visits \(s_{snap}\) and later visits \(s_{fini}\).
</h5>
<hr class="new2">

<p>
For example, an algorithm in the top diagram of figure 7 determines
the global state \(s_{snap}\) along the curved consistent cut during a
computation. Let \(s_{init}\) and \(s_{fini}\) be the states before the
algorithm starts and after it finishes, i.e. at the left and
right-hand ends of the system timeline diagram. Then, the diagram in the
lower diagram of figure 7 also represents a computation 
from \(s_{init}\) to \(s_{snap}\) and then to \(s_{fini}\).

<p>
This result is helpful in developing algorithms that detect properties
of the states of computations.


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
