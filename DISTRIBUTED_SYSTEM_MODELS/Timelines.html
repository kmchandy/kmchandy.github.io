<title>DistributedSystemModels/Timelines.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

  <!--------------------------------------------------------------->
  <h2 class="w3-text-teal">Topological Sorts of Dataflow are Computations</h2>

  </p>

  <p class="w3-text-red">
  This page discusses a property of dataflow graphs.

  A sequence of events of a dataflow graph is a computation if for all
  edges \((e, e')\) of the graph, \(e'\) appears after \(e\) in the
  sequence.

  This is equivalent to: All topological sorts of dataflow graphs are
  computations. 

  </p>


  <!---------------------------------------------------------->
  <h3 class="w3-text-teal">Directed Acyclic Graphs: Review</h4> 
  <!---------------------------------------------------------->

We begin with a review of a few basic properties of directed acyclic
  graphs and dataflow.


  The figure below is an example of a
  <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">
  directed acyclic graph
  </a>,
  abbreviated to dag.

  <figure>
    <img src="DistributedSystemModels/DistributedSystemModels.014.jpeg"
    alt="Fig14" style="width:75%"> 
    <figcaption>Fig.1: Example of a Directed Acyclic Graph</figcaption>
  </figure>

  

  <!-------------------------------------------------------->  
  <h5 class="w3-text-teal">Topological Sort</h5>
  <!-------------------------------------------------------->

     A vertex \(v\) in a directed acyclic graph precedes a vertex \(w\)
  exactly when there is a path from \(v\) to \(w\).
  
<a
  href="https://en.wikipedia.org/wiki/Topological_sorting">
  A topological sort
  </a>
  of a dag
  is a sequence of vertices of the dag in which each vertex appears in
  the sequence after all vertices that precede it.
  
  Examples of topological sorts of the dag shown in figure 1 are \([0,
  1, 2, 3, 4, 5, 6, 7]\) and \([0, 2, 1, 5, 3, 4, 6, 7]\).


  <!-------------------------------------------------------->
   <h5 class="w3-text-teal">Input-Closed Set of Vertices</h5>
  <!-------------------------------------------------------->  
  A subset \(H\) of vertices of a dag is <i>input
  closed</i> exactly when every edge to every vertex in \(H\) is from a
  vertex in \(H\).

  There is no path to a vertex in an input-closed vertex set from a
  vertex outside it.
  
  There may, however, be paths from vertices inside an input-closed
  set to vertices outside it.

<p>
Examples of vertex sets that are input closed are \(\{0, 1, 2\}\),
and  \(\{0, 1, 2, 5\}\).

An example of a vertex set that is not input closed is \(\{0, 1,
3\}\) because there is an edge to vertex \(3\) from vertex \(2\) which
is not in the subgraph.


  <!-------------------------------------------------------->
<h5 class="w3-text-teal">Observation</h5>
  <!-------------------------------------------------------->
For any input-closed subsets \(H, H'\) of vertices of a dag, where \(H
\subseteq H'\) the sequence of vertices consisting of a topological
sort of \(H\) followed by a topological sort of \(H' - H\) followed by
a topological sort of the complement of \(H'\) is a topological sort
of the dag.

<p>
In figure 1, \(H = \{0, 1, 2, 5\}\)
and \(H' = \{0, 1, 2, 3, 4, 5\}\)
are input closed, and the sequence
\([0, 2, 1, 5]\) followed by \([3, 4]\) followed by
\([6, 7]\) is a topological sort of the dag.



  <!---------------------------------------------------------->
  <h3 class="w3-text-teal">Dataflow: Review</h4> 
<!---------------------------------------------------------->

Next we review properties of
<a href="https://en.wikipedia.org/wiki/Dataflow_programming">
dataflow
</a>
that help in understanding distributed computing algorithms.

<p>
  A vertex of a dataflow graph is an operation on variables of a
  computation. 

  A directed edge connects the output of an operation to the input
  of another operation.

  An edge is labeled with the data that is transferred between
  operations.

  We restrict attention to acyclic dataflow graphs.

<p>
  A computation of a dataflow graph is an execution (possibly a
  parallel execution) of operations of the graph where:
  <p>
  <i>
  an operation is executed after all
  operations that precede it.
  </i>

<!---------------------------------------------------------------->
<h4 style="color:red;">Example of Dataflow</h4>
<!---------------------------------------------------------------->
The figure 2 is an example of a dataflow graph.

The vertices are operations, \(+. *, -\), and the edges show the
formula of the data on the edge.

The initial vertex generates the variables of the dataflow.

  <figure>
    <img src="DistributedSystemModels/DistributedSystemModels.016.jpeg"
    alt="Fig16" style="width:75%"> 
    <figcaption>Fig.2: Example of Dataflow</figcaption>
  </figure>


  
<!---------------------------------------------------------------->  
<h3 class="w3-text-teal">Properties of Dataflow</h3>
<!---------------------------------------------------------------->

The following observations follow directly from properties of directed
acyclic graphs.

<hr class="new2">
<p style="color:blue;">
<ol>
  <li>
  <h6 style="color:blue;">
  All <a href="https://en.wikipedia.org/wiki/Topological_sorting">
  topological sorts</a> of dataflow graphs are computations.
  </p>
  </li>
  <li>
  <h6 style="color:blue;">
  For all input-closed sets \(H, H'\) of operations where \(H
\subseteq H'\) there exists a computation that executes all operations
in \(H\), then executes operations in \(H' - H\), and then executes
  operations that are not in \(H'\).
  </h6>
  </li>
</ol>
<hr class="new2">




<!------------------------------------------------------------------>
<h5 style="color:red;">
Example: Topological Sorts of Dataflow Graphs are Computations
</h5>
<!------------------------------------------------------------------>
Examples of topological sorts of the operations in figure 2 are \([-,
+, *]\), \([+, -, *]\), and \([+, *, -]\).
All these sequences of operations have the property that an operation
is executed only after all operations that precede it.

<p>
An example of a sequence which is not a topological sort is \([*, +,
-]\). 


<!------------------------------------------------------------------>
<h5 style="color:red;">
Example: Topological Sorts of Dataflow Graphs are Computations
</h5>
<!------------------------------------------------------------------>


Figure 3 shows different computations with the same dataflow
graph.

The two diagrams of the figure show two topological sorts of the same
dataflow graph.

Events of the same graph are laid
out from left to right in the order in which they occur in the
computations. 

<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.010.jpeg"
    alt="Fig3" style="width:100%"> 
    <figcaption>Fig.3: Example - Computations with the same Dataflow</figcaption>
</figure>


<!------------------------------------------------------------------>
<h4 style="color:red;">Example: Computations between Sets of
Events</h4>
<!------------------------------------------------------------------>
There exists a computation that first executes events in \(H = \{0,
2\}\) and then the events in \(H' - H\) where \(H' = \{0, 1, 2,
5\}\) and then the remaining events.



<!----------------------------------------------------------------->
<h4 class="w3-text-teal">The State at an Input Closed Set of Events</h4>
<!----------------------------------------------------------------->

The state \(S\) at an input-closed set \(H\) of events of the
dataflow of a computation is the state after executing
all events in \(H\) and before executing events any event that is not
in \(H\).

\(S\) is obtained from the graph as follows. 

<ol>
  <li>
The state of an agent \(u\) in \(S\) is the label of the agent \(u\)
  edge from a vertex inside \(H\) to a vertex outside \(H\).
  </li>
  <li>

The state of a channel \((u, v)\) in \(S\) is the sequence of labels
of \((u, v)\) edges from vertices inside \(H\) to vertices outside
  \(H\).
  </li>
</ol>

<p>
From observation 2,
for input-closed event sets \(H, H'\) where \(H \subset H'\):
<p>
there is a computation from the state at \(H\) to the state at \(H'\).
</p>



<!------------------------------------------------------------------>
<h5 style="color:red;">Example: State at an Input-Closed Set of Events</h5>
<!------------------------------------------------------------------>

<p>
Let's look state \(S_{3}\) of the
input-closed event set \(H = \{0, 1, 2, 3\}\) in figure 1.

A vertical line between events 3 and 4 is a boundary between vertices
in \(H\) and vertices outside it.

\(S_{3}\) is determined by the labels of edges that cross the
boundary.

<p>
The boundary line intersects the agent edge for
\(u\) at an edge with label "e" signifying empty; so, \(u\) holds no tokens in
\(S_{3}\).

The line intersects the edges for channel \((v, u)\) at a single edge
and that edge has label "red token" and so the state of the \((v, u)\)
in \(S_{3}\) is a sequence of messages consisting of a single message
-- the red token.

<p>

The boundary line does not intersect an edge for the channel \((u, v)\), and so
the state of this channel is the empty sequence of messages.

The line intersects message edges for messages on channel \((v, v)\)
at a single edge; this edge is labeled with the wakeup message.

So, the state of channel \((v, v)\) is a sequence consisting of a single
message -- the wakeup message.

<p>
The states of other agents and channels are determined similarly.


<p>
The state \(S_{i}\) that occurs in a computation after events \(0,
\ldots, i\) are obtained similarly and are shown in figure 3.

The lower part of figure 3 shows the event graph and
the upper part shows the sequence of states in the
computation.

The dotted vertical lines show boundaries of event sets \(0,
\ldots, i\), for all \(i\).



<figure>
    <img src="DistributedSystemModels/DistributedSystemModels.007.jpeg"
    alt="Fig3" style="width:100%"> 
<figcaption>
Fig.3: Example: States at Input-Closed Event Sets
</figcaption>
</figure>




<!------------------------------------------------------------------>
<h5 style="color:red;">Example: State at an Input-Closed Set of Events</h5>
<!------------------------------------------------------------------>
Let's look at the state at the event set \(\{0, 1, 2, 5\}\).
The state of \(u\) is the label of the edge from event 5 to 6 -- holds
red token.
The state of \(v\) is the label of the edge from event 2 to 3 -- holds
no token.
The boundary line cuts the message edge from 1 to 3.
This edge is labeled with blue token; so the state of channel \((u,
v)\) is blue token.
The boundary does not intersect with other edges, and so that states
of the remaining channels are empty sequences.



<!----------------------------------------------------------------->
<h3 class="w3-text-teal">Event Sets specified by Points in Agent
Computations </h3>
<!----------------------------------------------------------------->
A point in an agent's computation is an integer \(i\).

The <i>past</i> at point \(i\) on an agent's computation is the set of the
first \(i\) events at the agent, and the <i>future</i> is the set of
events at the agent that are not in the past.

<p>
A point \(i\) in an agent's computation is shown as a location on the
edge from the \(i\)-th event to the \(i+1\)-th event.


<p>
All agent edges to past events are past events.
And, all agent edges to future events are from future events.


<!------------------------------------------------------------------>
<h5 style="color:red;">Example: Points, Past, and Future</h5>
<!------------------------------------------------------------------>
The figure below shows a dataflow graph for a computation with events
\([0, 1, 2, \ldots]\).
Points on the agents' computations are shown as yellow circles.
For example, the point on agent \(X\) is 3 because it is the edge from
the 3rd event (event number 6) to the 4th event (event number 8) at
the agent.

<figure>
    <img src="../ChannelSnapshots/ChannelSnapshots/ChannelSnapshots.009.jpeg"
    alt="Fig4" style="width:100%"> 
<figcaption>
Fig.4: Example: Past and Future
</figcaption>
</figure>

The set of past events are colored black and the set of future events
are colored green.
The purple line connecting the points separates the past from the future.

<p>
All horizontal edges to black vertices are from black vertices.
And, all horizontal edges to green vertices are from green vertices.


<!------------------------------------------------------------------>
<h5 style="color:red;">Example: Points, Past, and Future</h5>
<!------------------------------------------------------------------>
The next figure shows a set of points on agent computations in which
the past is not input closed.


<figure>
    <img src="../ChannelSnapshots/ChannelSnapshots/ChannelSnapshots.010.jpeg"
    alt="Fig5" style="width:100%"> 
<figcaption>
Fig.5: Example: Past is not Input Closed
</figcaption>
</figure>

The past is not input closed because there is a message sent in the future
(a green vertex) that is received in the past.

<!----------------------------------------------------------------->
<h3 class="w3-text-teal">Theorem about Past and Future</h3>
<!----------------------------------------------------------------->
The following result is self-evident from the definition of
input-closed sets.
<hr class="new2">
<p style="color:blue;">
Given a point on each agent's computations, the set of past events at
these points is input-closed if any only if one of the following conditions holds.
<ol>
  <li>
  <p style="color:blue;">
Each message received in a past event is sent in a past event.
  </li>
  <li>
<p style="color:blue;">
Each message sent in a future event is received in a future event.
  </li>
  <li>
  <p style="color:blue;">
  For all channels \(C\),  \(\; C_{s} \geq C_{r}\), where \(C_{s}, C_{r}\)
  are the numbers of messages 
  sent and received (respectively) on the channel in the past
  events.
  </li>
  <li>
  <p style="color:blue;">
  In graphical terms, all edges that cross the boundary separating
  past and future events in the dataflow graph are directed
  from the past to the future.
  </li>
</ol>
</p>
<hr class="new2">

The next four webpages describe important -- though straightforward --
applications of the theorem.


<!------------------------------------------------------------------>
<h3 class="w3-text-teal">Next</h3>
<a href="../ChannelSnapshots/ChannelSnapshots.html">
Global Snapshots.
</a>


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
