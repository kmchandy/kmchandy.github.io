<!--------------------------------------------------------->
<h1 class="w3-text-teal">Termination Detection</h1>

<h4 class="w3-text-teal">
This module shows how the
algorithm to detect stable properties is specialized to detect termination of a computation.
</h4>
Consistent cuts and global snapshots are used to
<a href="./StablePredicates.html"> detect when stable
predicates hold.</a>
"Computation has terminated" is a stable predicate: computation has
terminated then it remains terminated.
This module shows how the general algorithm for detecting stable
properties is specialized to obtain a simple algorithm to detect termination.

<h2 class="w3-text-teal">The Problem</h2>

    <h4 class="w3-text-teal">Active and Idle States of Agents</h4>
    An agent is either <i>idle</i> or <i>active</i>. An idle agent
    remains idle until it receives a message at which point it becomes
active. An idle agent does not send messages.

<p>An active agent may send messages. An active agent
may become idle at any point.

<p>
    Initially all agents are active and all channels are empty.

    <h4 class="w3-text-teal">Terminated State</h4>
    A <i>terminated</i> state of the system is one in which all agents
are idle and all channels are empty. A
    system may or may not enter a terminated state.

<p>
<i>terminated</i> is stable:
    a system in a terminated state remains terminated thereafter. 

<p>
    The problem is to develop an algorithm that detects that the system has
entered a terminated state.
The detection algorithm may use messages and agents that are not part of the
underlying computation.
The detection algorithm is part of the distributed operating system whereas the
    underlying computation is part of a user application which isn't
affected by the execution of the operating system.

<h4 class="w3-text-teal">Specification of the Algorithm</h4>
The algorithm returns a Boolean variable where:
<ol>
  <li>
  If the algorithm starts after the system has terminated then
  the algorithm returns True.
  </li>
  <li>
  If the algorithm returns True then the system has terminated when
    the algorithm terminates
  </li>
</ol>
  

    <h4 class="w3-text-teal">Agent's Local Variables: Counts of Messages in Channels</h4>

<p>
Each agent has a local variable \(C_{nsent}\) for each outgoing
channel \(C\), and a local variable \(C_{nrcvd}\) for each incoming
channel \(C\).
Initially, for all channels \(C\):  \(C_{nsent} = C_{nrcvd} = 0\)

At each point in a computation, the number of messages in transit
along a channel \(C\) is \(C_{nsent} - C_{nrcvd}\).
    

<hr class="new2">
<h4 style="color:blue;">
    The system has terminated if and only if:
      All agents are idle, and
      for each channel \(C\): \(C_{nsent} = C_{nrcvd}\)
</h4>
<hr class="new2">


    <h2 class="w3-text-teal">The Detector Agent</h2>
    The detection algorithm uses an agent, which is part of the
    operating system and is not part of the underlying computation. We call this agent <i>the
    detector</i>. 

    <p>
    When an agent transits from active to idle it sends a message to
    the detector containing copies of its local variables, \(C_{nsent}\)
    for every outgoing channel of the agent, and \(C_{nrcvd}\) for every
    incoming channel of the agent. 

<h4 class="w3-text-teal">The Detector's Local Variables</h4>
The detector has its own local variables \(C_{s}\) and \(C_{r}\) for every
channel \(C\) in the system.
The initial values of these local variables are arbitrary.
When a detector gets a message from an
agent it sets the values of its local variables \(C_{s}\) and \(C_{r}\) to the
values of \(C_{nsent}\) and \(C_{nrcvd}\), respectively, in the message for the
corresponding channels \(C\).

<hr class="new2">
<h4 style="color:blue;">The detector detects termination when the
detector has received a message from each agent in the
computation, and
for all channels \(C\): 
\(
C_{s} = C_{r}
\)
</h4>
<hr class="new2">



<h4 class="w3-text-teal">Proof</h4>
When the detector detects termination it has received a message from
each agent. An agent sends a message only when it transits to idle.
So, 
the values of the detector's local variables, \(C_{s}, C_{r}\) for
each channel \(C\) are the values \(C_{nsent}, C_{nrcvd}\) sent by idle agents
at some cut. From the theorem on consistent cuts, this cut
is consistent if and only if, for all channels \(C\): 
<p>
\(C_{s} \geq C_{r}\)
<p>
Therefore the detector detects termination based on a consistent
cut. The result follows because termination is stable.

<h4  class="w3-text-teal">Next</h4>
Look at
<a href="./TerminationDetectionExample.html">the detailed example</a>
and
<a href="./TerminationDetectionVideo.mp4">the video</a>.

<h4 style="color:blue;">Review</h4>
<ol>
  <li>
  The messages that the detector gets are sent in the past: \(C_{s}\)
  may be less than \(C_{nsent}\), and \(C_{r}\) may be less than
  \(C_{nrcvd}\). We know that computation has terminated and the
  <i>instantaneous</i> counts match, i.e., \(C_{nsent} = C_{nrcvd}\)
  for all channels \(C\). But the <i>detector uses out-of-date
  counts</i>. Assume that you are explaining the algorithm to somebody
  who hasn't taken the course. Explain why the algorithm works with
  out-of-data information.
  </li>
  <li>
  Can detector agents for all other detection applications use out-of-date
  information? Why or why not?
  </li>
</ol>