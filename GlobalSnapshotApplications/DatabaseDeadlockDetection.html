<title>GlobalSnapshotApplications/DatabaseDeadlockDetection.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>
<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>

<nav
class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5
w3-animate-left" 
id="mySidebar">

<a href="javascript:void(0)"
onclick="w3_close()"
class="w3-right w3-xlarge w3-padding-large w3-hover-black
w3-hide-large"
title="Close Menu">
<i class="fa fa-remove"></i>
</a>

<!--END Heading  ---------------------------->
 
<!-- Start Sidebar----------> 
 
<a class="w3-bar-item w3-button w3-hover-black "
href="../GlobalSnapshotApplications/StablePredicates.html" > 
Detection Algorithms
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="../GlobalSnapshotApplications/TerminationDetection.html" > 
Detecting Termination
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="../GlobalSnapshotApplications/DatabaseDeadlockDetection.html" > 
Detecting Database deadlock
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="../GlobalSnapshotApplications/TerminationDetectionVideo.mp4" > 
Detecting Termination: Video
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="../GlobalSnapshotApplications/TerminationDetectionExample.html" > 
Detecting Termination: Example 
</a>

</nav>
<!-- End Sidebar---------->
 
<!-- Start overlay ---------------------------------->

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large"
  onclick="w3_close()"
  style="cursor:pointer"
  title="close side menu"
  id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

<!-- End overlay ---------------------------------->
    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">Detecting Database Deadlocks</h1>

    <h4 class="w3-text-teal">
This module shows how consistent cuts of timelines are
used to develop algorithms to detect deadlocks that can arise
in databases.
</h4>
"Computation is deadlocked" is an example of a stable property; a
deadlocked computation remains deadlocked. A generalization of the
deadlock detection problem is to break a deadlock after it is detected
by aborting or rolling back the computation of some agents; the
generalization is straightforward and we don't discuss it here.

    <h2 class="w3-text-teal">The Problem</h3>
    The problem of database deadlock detection is similar to that of
    <a
    href="../GlobalSnapshotApplications/GlobalSnapshotApplications.html">
    termination detection discussed in an earlier module</a>.
    A system consists of
    <a href="../Channels/Channels.html">a set of agents and a set of message-passing
    channels.</a>

    <p>
    Agents in the system share a set of files.
    Each shared file is represented as an
    indivisible colored token, with each file having its own
    unique color. The system has at most one token of a given color.

    Tokens can be sent from agent to agent. Tokens are
    not duplicated or destroyed. Let \(u_{holds}\) be the set of tokens
    that agent \(u\) holds.

    <p>
    An agent \(u\) is in one of the following states:
    <ol>
      <li>
      <i>State 1: Executing without needing tokens.</i> This state may persist
      for an arbitrary amount of time.
      Let \(u_{needs}\) be the set of tokens that \(u\) needs to
    continue execution; in
      this state \(u_{needs}\) is the empty set.
      An agent may transit from this state
    to the next state --- state 2 <i>waiting</i>--- at any point.
      </li>
      <li>
      <i>State 2: Waiting</i>: Waiting to hold <i>all</i> tokens in a nonempty set \(u_{needs}\) of
      tokens. In this state there is at least one token in
      \(u_{needs}\) which is not in \(u_{holds}\).
      If \(u_{needs}\) becomes a subset of \(u_{holds}\) because \(u\)
    receives a token that it is waiting for then \(u\) transits from
    state 2 to state 3. In the <i>waiting</i> state \(u\) is waiting to acquire
    tokens so that \(u\) can transit from waiting state to the next
    state --- state 3.
      </li>
      <li>
      <i>State 3: Executing while holding all tokens in
      \(u_{needs}\).</i> In this case \(u_{holds}\) is a subset of
    \(u_{needs}\). This state persists only for finite time after
    which the agent transits to state 1: executing without needing tokens.
      </li>
    </ol>
    <p>
    If an agent \(u\) gets a request for a token in \(u_{holds}\)
    which is not in \(u_{needs}\) then \(u\) sends the requested token
    to the requester and that token is removed from \(u_{holds}\).
    If  \(u\) gets a request for a token in \(u_{holds}\)
    which is in \(u_{needs}\) then \(u\) does not send the requested
    token while \(u\) continues to be in waiting state.

    
    
    <figure>
    <img src="DeadlockDetection_And_1.jpg" alt="Fig1" style="width:100%">
    <figcaption>Fig.1 - The Life Cycle of an Agent</figcaption>
    </figure>
    An agent executes while holding files --- state 3 --- for only a finite
    time. However, agents may wait forever to acquire files if they
    form a deadlock cycle. Agents may remain in state 1
    forever. Computations may or may not deadlock. Our task is to
    design an algorithm by which an agent determines that it is
    deadlocked if it is indeed deadlocked.

<h3 class="w3-text-teal">Deadlock</h3>
A cycle of waiting agents is in a deadlock if each agent is waiting to
acquire a token that is needed by the next agent in the cycle. Our task is to
design an algorithm by which an agent detects if is part of a
deadlocked cycle.

<h3  style="color:red;">Example</h3>
A system has one red, one blue and one green token.
Agents \(x\), \(y\) and \(z\) are deadlocked in the following state.
Agent \(x\) holds the red token and is
to acquire the blue token because \(x\) needs both red and blue tokens
    to continue execution; agent \(y\) holds the blue token and is waiting
to acquire the green token because \(y\) needs both blue and green
    tokens to continue execution; and agent \(z\) holds the green token and is waiting
    to acquire the red token because \(z\) needs both green and red
    tokens to continue execution.
    
    <figure>
  <img src="DeadlockDetection_And_2.jpg" alt="Fig1" style="width:100%">
  <figcaption>Fig.1 - An Example of a Deadlock</figcaption>
</figure>

    <h2 class="w3-text-teal">An Algorithm</h2>
    A general approach to detecting stable properties has two phases
    (1) obtain a global snapshot, and (2) analyze the global
    snapshot. The 
    first phase reduces analysis of a dynamic system
    into the analysis of static snapshot. The second step
    analyzes <i>static</i> date structures such as graphs.

    <p>This module describes an algorithm consisting of a single phase
    that is an optimization of the two-phase algorithm.

    <p>
The definition of a deadlocked cycle depends only on the local states
of agents and is independent of the states of message channels.
So, we use a simpler version of the global snapshot algorithm which
does not record states of channels.

<p>
For an agent \(u\), define \(u_{waits}\) as:
<p>
\(
u_{waits} = u_{needs} - u_{holds}
\)
<p>
and for sets \(S\) and \(S'\), \(S -
S'\) is the set consisting of elements that are in \(S\) and not in
\(S'\).
So, \(u\) is in <i>waiting</i> state exactly when \(u_{waits}\) is nonempty.

<h4 class="w3-text-teal">Initiating the Algorithm</h4>
A waiting agent \(x\) initiates the algorithm by sending a message, called a
<i>marker</i> on each outgoing channel. We call \(x\) <i>the
initiator</i>. Assume that there is only one initiator. (Multiple
initiators can be handled by tagging messages with the identity of the
initiator.)
<p>
The marker \(m\)
has a field \(m_{waits}\) that identifies the set
of tokens for which the sender is waiting; this is the set of tokens
that the sender has to hold to continue executing, i.e.,
<p>
\(m_{waits} = x_{waits}\)
<p>
where \(x\) is the initiator, 



<h4 class="w3-text-teal">Propagating Markers</h4>
When \(y\) receives a marker \(m\), then if:
<ol>
  <li> \(y\) is waiting to receive tokens, i.e.,  \(y_{waits}\) is a
  nonempty set, and
  </li>
  <li>
  \(y\) needs a token that the sender of marker \(m\) needs as
  well, i.e., the intersection of \(m_{waits}\) and
  \(y_{needs}\) is nonempty
  </li>
</ol>
then
\(y\) sends a marker \(m'\) on each of its outgoing channels where 
\(m'_{waits} = y_{waits}\) if \(y\) hasn't already sent markers.



<h4 class="w3-text-teal">Termination Detection</h4>
When the initiator \(x\) receives a marker \(m*\), the initiator
detects that it is in a deadlocked cycle if (1) there is a token common to 
\(m*_{waits}\) and \(x_{needs}\), and (2) \(x\) is in waiting state, i.e. \(x_{waits}\) is nonempty.

<h3  style="color:red;">Example</h3>
Let's look at the steps of the algorithm for the example given
earlier.
<p style="color:red;">Initiation</p>
Agent \(x\) initiates the algorithm by sending markers
requesting the blue token.

<p style="color:red;">Marker Propagation</p>
When agent \(y\) receives the marker, it
holds the blue token, and it needs the blue token as well as
the green token; so, it sends markers requesting the green token. When
agent \(z\) receives the marker, it
holds the green token, and it needs the green token as well as
the red token; so, it sends markers requesting the green token.

<p style="color:red;">Termination Detection</p>
At the point the initiator \(x\) gets the marker, it holds the red
token, and and it needs the red token as well as
additional tokens; so, it detects termination.

<h3 class="w3-text-teal">Correctnes of the Algorithm</h3>
The algorithm is the global snapshot algorithm, and we
proved the correctness of the algorithm earlier.

<h4 style="color:blue;">Review</h4>
<ol>
  <li>
  Give an example of database deadlock with two agents and two files.
  </li>
  <li>
  Describe how the algorithm detects deadlock in your example.
  </li>
  <li>
  How is the algorithm related to the global snapshot algorithm?
  </li>
</ol>
  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
