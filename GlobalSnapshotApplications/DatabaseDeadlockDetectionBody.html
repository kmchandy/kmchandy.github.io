    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">Detecting Database Deadlocks</h1>

    <h4 class="w3-text-teal">
This module shows how consistent cuts of timelines are
used to develop algorithms to detect deadlocks that can arise
in databases.
</h4>
"Computation is deadlocked" is an example of a stable property; a
deadlocked computation remains deadlocked. A generalization of the
deadlock detection problem is to break a deadlock after it is detected
by aborting or rolling back the computation of some agents; the
generalization is straightforward and we don't discuss it here.

    <h2 class="w3-text-teal">The Problem</h3>
    The problem of database deadlock detection is similar to that of
    <a
    href="../GlobalSnapshotApplications/GlobalSnapshotApplications.html">
    termination detection discussed in an earlier module</a>.
    A system consists of
    <a href="../Channels/Channels.html">a set of agents and a set of message-passing
    channels.</a>

    <p>
    Agents in the system share a set of files.
    Each shared file is represented as an
    indivisible colored token, with each file having its own
    unique color. The system has at most one token of a given color.

    Tokens can be sent from agent to agent. Tokens are
    not duplicated or destroyed. Let \(u_{holds}\) be the set of tokens
    that agent \(u\) holds.

    <p>
    An agent \(u\) is in one of the following states:
    <ol>
      <li>
      <i>State 1: Executing without needing tokens.</i> This state may persist
      for an arbitrary amount of time.
      Let \(u_{needs}\) be the set of tokens that \(u\) needs to
    continue execution; in
      this state \(u_{needs}\) is the empty set.
      An agent may transit from this state
    to the next state --- state 2 <i>waiting</i>--- at any point.
      </li>
      <li>
      <i>State 2: Waiting</i>: Waiting to hold <i>all</i> tokens in a nonempty set \(u_{needs}\) of
      tokens. In this state there is at least one token in
      \(u_{needs}\) which is not in \(u_{holds}\).
      If \(u_{needs}\) becomes a subset of \(u_{holds}\) because \(u\)
    receives a token that it is waiting for then \(u\) transits from
    state 2 to state 3. In the <i>waiting</i> state \(u\) is waiting to acquire
    tokens so that \(u\) can transit from waiting state to the next
    state --- state 3.
      </li>
      <li>
      <i>State 3: Executing while holding all tokens in
      \(u_{needs}\).</i> In this case \(u_{holds}\) is a subset of
    \(u_{needs}\). This state persists only for finite time after
    which the agent transits to state 1: executing without needing tokens.
      </li>
    </ol>
    <p>
    If an agent \(u\) gets a request for a token in \(u_{holds}\)
    which is not in \(u_{needs}\) then \(u\) sends the requested token
    to the requester and that token is removed from \(u_{holds}\).
    If  \(u\) gets a request for a token in \(u_{holds}\)
    which is in \(u_{needs}\) then \(u\) does not send the requested
    token while \(u\) continues to be in waiting state.
    
    <figure>
    <img src="DeadlockDetection_And_1.jpg" alt="Fig1" style="width:100%">
    <figcaption>Fig.1 - The Life Cycle of an Agent</figcaption>
    </figure>
    An agent executes while holding files --- state 3 --- for only a finite
    time. However, agents may wait forever to acquire files if they
    form a deadlock cycle. Agents may remain in state 1
    forever. Computations may or may not deadlock. Our task is to
    design an algorithm by which an agent determines that it is
    deadlocked if it is indeed deadlocked.

<h3 class="w3-text-teal">Deadlock</h3>
A cycle of waiting agents is in a deadlock if each agent is waiting to
acquire a token that is needed by the next agent in the cycle. Our task is to
design an algorithm by which an agent detects if is part of a
deadlocked cycle.

<h3  style="color:red;">Example</h3>
A system has one red, one blue and one green token.
Agents \(x\), \(y\) and \(z\) are deadlocked in the following state.
Agent \(x\) holds the red token and is
to acquire the blue token because \(x\) needs both red and blue tokens
    to continue execution; agent \(y\) holds the blue token and is waiting
to acquire the green token because \(y\) needs both blue and green
    tokens to continue execution; and agent \(z\) holds the green token and is waiting
    to acquire the red token because \(z\) needs both green and red
    tokens to continue execution.

    <p>
    The diagram below shows agents \(u, v, w, x\) in a deadlock. \(u\)
    blocks \(w\) because \(u\) and \(w\) are both waiting and both
    need the same token to continue execution. Likewise, \(v\) blocks
    \(u\) and \(w\) blocks both \(v\) and \(x\). The blocking cycle
    \(u, w, v, u\) causes \(u, v, w\) to be deadlocked. Agent \(x\) is
    also deadlocked because it is blocked by a deadlocked agent. Our
    algorithm only allows agents in a blocking cycle to determine that
    it is deadlocked. So, if \(u\), or \(v\) or \(w\) initiate the
    detection algorithm while they are in this blocking cycle, the
    algorithm will determine that they are deadlocked; however, \(x\)
    will not determine that it is deadlocked if it is not part of a
    blocking cycle. When an agent in a deadlocked cycle detects that
    it is deadlocked, it breaks the deadlock by aborting its
    computation and restarting; this breaks deadlocks for agents that
    are blocked by it.
    <figure>
  <img src="DeadlockDetection_And_2.jpg" alt="Fig1" style="width:100%">
  <figcaption>Fig.1 - An Example of a Deadlock</figcaption>
</figure>

    <h2 class="w3-text-teal">An Algorithm</h2>
    A general approach to detecting stable properties has two phases
    (1) obtain a global snapshot, and (2) analyze the global
    snapshot. The 
    first phase reduces analysis of a dynamic system
    into the analysis of static snapshot. The second step
    analyzes <i>static</i> date structures such as graphs.

    <p>This module describes an algorithm consisting of a single phase
    that is an optimization of the two-phase algorithm.

    <p>
The definition of a deadlocked cycle depends only on the local states
of agents and is independent of the states of message channels.
So, we use a simpler version of the global snapshot algorithm which
does not record states of channels.

<p>
For an agent \(u\), define \(u_{waits}\) as:
<p>
\(
u_{waits} = u_{needs} - u_{holds}
\)
<p>
and for sets \(S\) and \(S'\), \(S -
S'\) is the set consisting of elements that are in \(S\) and not in
\(S'\).
So, \(u\) is in <i>waiting</i> state exactly when \(u_{waits}\) is nonempty.

<h4 class="w3-text-teal">Initiating the Algorithm</h4>
A waiting agent \(x\) initiates the algorithm by sending a message, called a
<i>marker</i> on each outgoing channel. We call \(x\) <i>the
initiator</i>. Assume that there is only one initiator. (Multiple
initiators can be handled by tagging messages with the identity of the
initiator.)
<p>
The marker \(m\)
has a field \(m_{waits}\) that identifies the set
of tokens for which the sender is waiting; this is the set of tokens
that the sender has to hold to continue executing, i.e.,
<p>
\(m_{waits} = x_{waits}\)
<p>
where \(x\) is the initiator, 



<h4 class="w3-text-teal">Propagating Markers</h4>
When \(y\) receives a marker \(m\), then if:
<ol>
  <li> \(y\) is waiting to receive tokens, i.e.,  \(y_{waits}\) is a
  nonempty set, and
  </li>
  <li>
  \(y\) needs a token that the sender of marker \(m\) needs as
  well, i.e., the intersection of \(m_{waits}\) and
  \(y_{needs}\) is nonempty
  </li>
</ol>
then
\(y\) sends a marker \(m'\) on each of its outgoing channels where 
\(m'_{waits} = y_{waits}\) if \(y\) hasn't already sent markers.



<h4 class="w3-text-teal">Termination Detection</h4>
When the initiator \(x\) receives a marker \(m*\), the initiator
detects that it is in a deadlocked cycle if (1) there is a token common to 
\(m*_{waits}\) and \(x_{needs}\), and (2) \(x\) is in waiting state, i.e. \(x_{waits}\) is nonempty.

<h3  style="color:red;">Example</h3>
Let's look at the steps of the algorithm for the example given
earlier.
<p style="color:red;">Initiation</p>
Agent \(x\) initiates the algorithm by sending markers
requesting the blue token.

<p style="color:red;">Marker Propagation</p>
When agent \(y\) receives the marker, it
holds the blue token, and it needs the blue token as well as
the green token; so, it sends markers requesting the green token. When
agent \(z\) receives the marker, it
holds the green token, and it needs the green token as well as
the red token; so, it sends markers requesting the green token.

<p style="color:red;">Termination Detection</p>
At the point the initiator \(x\) gets the marker, it holds the red
token, and and it needs the red token as well as
additional tokens; so, it detects termination.

<h3 class="w3-text-teal">Correctnes of the Algorithm</h3>
The algorithm is the global snapshot algorithm, and we
proved the correctness of the algorithm earlier.

<h4 style="color:blue;">Review</h4>
<ol>
  <li>
  Give an example of database deadlock with two agents and two files.
  </li>
  <li>
  Describe how the algorithm detects deadlock in your example.
  </li>
  <li>
  How is the algorithm related to the global snapshot algorithm?
  </li>
</ol>
  