<!DOCTYPE html>
<html lang="en">
<title>CryptoCurrencyIntroduction</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new4 {
  border: 5px solid blue;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}

</style>

<body>

<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()"><i class="fa fa-bars"></i></a>
    <a href="../index.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">About the Course</a>
    <a href="../table_of_contents.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">Table of Contents</a>
    <a href="../cross_reference.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Index</a>
  </div>
  </div>
 

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left" id="mySidebar">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="Close Menu">
    <i class="fa fa-remove"></i>
  </a>
  
  <h3 class="w3-bar-item"><b>An Introduction to Distributed
  Algorithms</h3>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="CryptoCurrencyIntroduction.html">Cryptocurrency: Introduction</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="../BitCoin/BitCoin.html">Next: Bitcoin</a> 
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="../Byzantine_Oral/Byzantine.html">
  Previous: Byzantine Consensus: Oral</a> 
  
</nav>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
  <div class="w3-row w3-padding-64">
  <div class="w3-twothird w3-container">
    
    <h2 class="w3-text-teal">Introduction to Cryptography for
    Cryptocurrency</h3>
    
    <a href="https://www.lopp.net/pdf/princeton_bitcoin_book.pdf">
    This Princeton University book is a superb description of
    Bitcoin.</a> If you have the time, read the book and skip this
    module. 

    <p>
    This module contains a review of elementary cryptographic
    operations. It also introduces a simple
    cryptocurrency managed by a trusted agent. The next module
    discusses the algorithm underlying BitCoin; the BitCoin algorithm doesn't
    require agents to be trusted.


    
    <h1 class="w3-text-teal">Review: Cryptographic Hash Function</h1>
    A  hash function, \(H\), maps input strings of
    arbitrary size to outputs of fixed size.

    <h2 class="w3-text-teal">Collision Resistance</h2>
    Input values \(x, y\) of a hash function \(H\)
    are said to <i>collide</i> when \(H(x) = H(y)\).

    <p>
    Let's look at the following problem: Given \(H\), find any
    colliding pair \(x, y\).

    <p>
    Consider a hash function \(H\) that outputs \(n\)-bit numbers and
    whose input is \(m\) bit strings. As a specific example lets
    assume \(m = 20\) and \(n = 4\). We can
    find a collision in the following way.
    <p>
    Let \(D\) be an
    array of size \(2^{n} = 16\). Initially \(D\) contains null values. Repeat the following
    iteration until a collision is found.
    <p>
    Pick a random input \(x\).
    If \(D[H(x)]\) is not null then there is a collision between
    \(D[H(x)]\) and \(x\). If \(D[H(x)]\) is null then set \(D[H(x)] =
    x\)

    <p>
    By the pigeon-hole principle, we will find a collision in at most
    \(2^{n} + 1 = 17\) iterations.

    This  brute-force algorithm uses space \(2^{n}\) and finds a
    collision in at most  \(2^{n} + 1\) steps.

From the <a href="https://en.wikipedia.org/wiki/Birthday_problem">
Birthday Paradox</a> a collision will be found with high probability
in \(2^{n/2}\) iterations though
the worse-case time is \(2^{n}+1\). If \(n = 256\) then 
executing even \(2^{128}\) steps is still intractable.

<p>
    A hash function \(H\) is said to be <i>collision resistant</i> if 
    the only known ways of
    finding collisions in the hash functions are intractable. Of
    course, for \(H\) to be collision resistant the output of \(H\)
    must be \(n\)-bits for large \(n\). For example \(n = 256\) in the
    SHA-256 hash function. 
    

    <h2 class="w3-text-teal">Commitment using Hashes</h2>
    You bet that your soccer friend, Megan, cannot predict the winner
    of the 2022 World Cup. Megan puts the name of the predicted
    winner, \(W\), in an envelope and
    gives it to a trusted third party. After the World Cup is over,
    the third party reveals Megan's prediction, and at that point you
    can find out whether Megan's prediction was accurate.
    <p>
    The trusted third party provides two services:
<ol>
  <li>
  <i>Hiding</i>: You can't find out what \(W\) is until the third party reveals it.
  </li>
  <li>
  <i>Binding</i>: Megan can't change her prediction after giving it to the third
  party.
  </li>
</ol>

<p>
Can we use a hash function instead of a trusted third party?

<h3 class="w3-text-teal">Hiding</h3>

Let's try the following idea. Megan commits to \(W\) in the following
way. She announces a hash function, \(H\),
and the hash, \(y\), where \(y = H(W)\).
After the World Cup is over, she reveals her prediction, \(W\). At
this point you can verify that \(y = H(W)\).
    <p>
Does the hash function hide Megan's prediction?
Can you discover Megan's prediction before she reveals it?


    <p>
It's easy. There are only 210 teams playing. Compute \(H(x)\) where
    \(x\) runs over each of the 210 teams. One of those teams has to be
\(W\). You can discover her prediction in at most 210 steps.

<p>
Let's try another algorithm.  Megan selects a secret value \(r\) which
she keeps to herself. Instead
of giving you \(H(W)\), she gives you \(y\) where \(y = H(r + W)\) and
where \(+\) indicates concatenation of strings. Can
you discover \(W\) from \(H\) and \(H(r + W)\) without knowing \(r\)?

<p>
A brute-force solution is to try every combination of \(r\) and
\(W\). If \(r\) is obtained from a distribution that is spread out,
then finding \(W\) without knowing \(r\)  take so
much time that it is practically impossible.

<h3 class="w3-text-teal">Binding</h3>
<p>
Does the hash function \(H\) and the secret \(r\) provide both
services of the trusted third party? Is Megan bound to her prediction
or can she change her "prediction" after knowing the winner of the
World Cup? 

<p>
Suppose Megan has values \(r\) and \(r'\) such that H(r + 'Brazil') =
H(r' + 'Italy'). After the World Cup is over, she can announce that
her secret is \(r\) if Brazil wins, and announce that it is \(r'\) if
Italy wins.

<p>
A hash function is <i>binding</i> if there is no known tractable algorithm that finds
  pairs \(x, y\) and \(x', y'\) where \(x \neq x'\) such that \(H(x, y)
= H(x', y')\).
<p>
If Megan uses a hash function that is binding then she cannot find
  (in reasonable time) values \(r_{j}\) to match country \(C_{j}\)
such that
<p>
\(H(r_{0} + C_{0}) = H(r_{1} + C_{1})  = H(r_{2} + C_{2})  = \ldots\).
<p>
and so she can't wait for the winner \(C_{j}\) to be announced before announcing
her secret \(r_{j}\).
<p>
In summary, we can use a hash function that is hiding and binding to
play the role of a trusted third party in a commitment.

    <h2 class="w3-text-teal">Puzzle Friendly</h2>
Let \(r\) be a value picked from a spread-out distribution. Let
\(H\) map arbitrary length string to \(n\)-bit strings.
Consider the following problem:
    Given \(H\), \(r\), and an \(n\)-bit value \(y\), compute any \(x\) such that
\(H(r+x) = y\).
<p>
The hash function \(H\) is said to be <i>puzzle friendly</i>
    exactly when any algorithm to solve this problem is about as slow
as a brute-force algorithm which checks \(H(r+x) = y\) for random values
of \(x\).
The number of steps taken by any
algorithm that solves this problem is not significantly lower than
\(2^{n}\).

<p>
Now, let's look at the following related problem.  Given \(H\), \(r\),
and a set \(Y\) of \(n\)-bit strings, compute any \(x\) such that
\(H(r+x) \in Y\).  If \(Y\) consists of a single element \(y\) then
this problem is the same as that in the previous paragraph.  If \(Y\)
is a set of all \(n\)-bit strings then this problem is trivial because
any \(x\) solves the problem.  The probability that a random value
hashes to an element of \(Y\) is proportional to the cardinality of
\(Y\).  So, the cardinality of \(Y\) controls the expected time to
solve the puzzle.

<h3 class="w3-text-teal">A Cryptographic Hash Function</h3>
<i>A cryptographic hash function is one that is collision resistant,
hiding and puzzle-friendly.
</i>

<h3 class="w3-text-teal">Hashing Inputs of Arbitrary Length</h3>
Let \(f\) be a function that operates on input strings
of fixed length and produces output strings of fixed length. Let the
input and output strings of \(f\) have lengths \(M + N\) and \(M\),
respectively. We look at functions where \(N > 0\), and since the
output is smaller than the input, \(f\) is called a <i>compression
function.</i>

<p>
We can use function \(f\) to define a function \(g\) whose inputs are strings of arbitrary
lengths and whose outputs are strings of length \(M\).
Example code for \(g\) is given below where <code>InitialValue</code>
is a given constant string of length \(M\).

<pre>
def g(y):
    output = InitialValue

    // pad y so that it's length is a multiple of N
    if len(y)%N > 0:  y = y + "0"*(N - len(y)%N)

    // partition y into blocks of size N
    blocks = [y[i: i+N] for i in range(0, len(y), N)]

    // Apply function f to the concatenation of the
    // previous output (length M) with each block
    // (length N) to get the next output (length M).
    for block in blocks: output = f(output+block)
    return output
</pre>

<h3 class="w3-text-teal">Hash Pointers</h3>
A hash pointer is a pair \((ptr, y)\) where \(ptr\) is a pointer that
points to an item of data, and \(y\) is a cryptographic hash of that
item of data. Any data structure with pointers can be converted into a
data structure with hash pointers: merely replace each pointer \(ptr\)
by \((ptr, y)\).

<h2 class="w3-text-teal">Tamper-Evident Data Structures</h2>
<p  class="w3-text-teal">Single Block</p>
A simple example of a tamper-evident structure is a single block of
data D which is pointed to by a hash pointer consisting of a regular
pointer and a hash H(D).

    <figure>
    <img src="CryptoCurrencyIntroduction/Slide1.jpg" alt="Fig1" style="width:100%">
    <figcaption>Fig.1: Hash Pointer points to a Tamper-Evident Block
    of Data</figcaption>
    </figure>
If a malicious agent cannot modify the hash pointer and the agent
    changes D to D' then the tampering can be discovered because the
    hash pointer won't match the data that it is pointing to:
    \(H(D') \neq H(D)\).

<p  class="w3-text-teal">Linked List</p>
Let's look at linear linked list to which elements can be appended but
not deleted. The \(i\)-th element appended to the list points to the
\((i-1)\)-th element. 
Let's replace the pointers in the list by hashed
pointers.

    <figure>
    <img src="CryptoCurrencyIntroduction/Slide2.jpg" alt="Fig1" style="width:100%">
    <figcaption>Fig.2: Hash Pointer points to a Tamper-Evident List
    of Data</figcaption>
    </figure>

<p>
An element of the list consists of a block of data and a hash pointer
to the previous block. The hash pointer consists of a regular pointer
and the value obtained by hashing the previous element of the list.
For the \(j\)-th element let's call the data block, the regular
pointer, and the hashed value, \(D_{j}\), \(ptr_{j}\) and \(HA_{j}\)
respectively.
<p>
Note that
\(HA_{j}\) is not \(H(D_{j-1})\); it is
the value obtained by applying the hash function \(H\)
to the entire  \(j-1\)th element of the list which consists of
\(D_{j-1}\), \(ptr_{j-1}\) and \(HA_{j-1}\).
The \(0\)-th
element is called the <i>genesis</i> element and has default values.

<p>
Suppose a malicious agent modifies \(D[j]\), \(ptr[j]\) or
\(HA[j]\). Any agent can detect this tampering because the
hash value \(HA[j+1]\) will no longer match the \(j\)-th element of
the list. If
the malicious agent also modifies \(HA[j+1]\) then 
hash value \(HA[j+2]\) will no longer match the \(j+1\)-th element.

<p>By induction on \(j\), any agent can detect tampering with the list
provided malicious agents do not also modify the hash pointer to the
last element of the last.


<h5 class="w3-text-teal">Tamper-Evident Acyclic Graphs and Merkle
Trees</h5>
The idea described in the previous paragraph to convert linear linked
lists can be used to convert directed acyclic graphs, in which nodes are
connected by pointers, into tamper-evident graphs. A specific case of
a directed acyclic graph is a rooted tree.

<p>
A <i>Merkle tree</i> is a special case of a binary balanced tree in which
data items are stored only in the leaves.
Nodes that are not leaves 
contain only hash pointers to nodes in the next level down.
To prove that an element at the leaf is a member of the tree we need only the
\(log_{2}(n)\) hash pointers on the path from the root to that
leaf. By contrast, to prove that an element is a member of a linear
list we need to inspect \(O(n)\) elements, on average.

<h3 class="w3-text-teal">Keys and Signed Messages</h3>
You can create a random public-key, private-key pair 
<a href="https://en.wikipedia.org/wiki/Ssh-keygen">
by calling a function on your computer.</a>
With high probability, nobody else has this
specific pair of keys. Each individual's private key is a secret held
by that individual. Public keys are accessible by everybody.

<p class="w3-text-teal">Sending messages securely</p>
Keys are used to send messages securely.
Kamala sends a secure message to Joe by encrypting the message with
Joe's public key; Joe decrypts the message using Joe's private key.
An agent cannot decrypt the encrypted message without Joe's private key.

<p class="w3-text-teal">Signing messages</p>
Suppose Kamala needs to send a signed message to Joe while
ensuring that nobody can forge her signature. She encrypts the message
<i>M</i> with her private key to get an encrypted message <i>M'</i>,
and sends the pair <i>(M, M')</i> securely to Joe. When Joe receives
<i>(M, M')</i>, Joe decrypts
<i>M'</i> using Kamala's public key to get the decrypted message
<i>M''</i>. If <i>M'' = M</i> then Joe knows that Kamala sent
<i>M</i> because only an agent with Kamala's private signature could
have sent that message.

<h2 class="w3-text-teal">Cryptocurrency Managed by a Trusted
Agent</h2>
Let's start with a digital currency managed by a trusted agent that we will
call a bank. Later, we will
look at a consensus algorithm --- very different from Paxos and Byzantine
Generals --- which will allow us to do without a trusted
agent. Cryptocurrencies use consensus algorithms without trusted agents.


<p>
The bank maintains a tamper-resistant linear list
<code>L</code> of transactions. Let's call this list a
tamper-resistant <i>ledger</i>. 
Any agent can get a copy of the ledger.

<p>
A transaction is one of
two types: <i>create</i> or <i>pay</i>.
In a pay transaction, <i>payers</i> give coins that they possess to
<i>payees</i>. An agent can be both a 
payer and payee of the same transaction.
In a create transaction the bank creates coins that it gives to
agents --- the payees of the transaction; the bank acts as the payer.
We won't discuss the permissions that a bank needs to create coins.

<p>
A pay transaction is signed by all payers of the transaction.
A create transaction is signed by the bank.

<p>
Each element of the tamper-resistant ledger has:
<ol>
  <li>
  a unique id;
  </li>
  <li>
  the type of the transaction, either create or pay;
  </li>
  <li>
  <i>list of payers</i>: only for pay transactions --- a list
  indicating the agents who pay coins into the transaction and the
  amounts that they put in;
  </li>
  <li>
  <i>array of value-payee pairs</i>: for both create and pay transactions --- an
  array of pairs <code>(value, payee public key)</code>, where each
  pair in the array indicates that coins of the specified value are
  given to the payee with the specified public key.
  </li>
</ol>

<h3 style="color:red;">Example of a create transaction</h3>
 An example of the specification of a create transaction is:
<pre>
(3146, create,  [(2.1, 7xxxx...), (3.2, 8xxxx)]).
</pre>
The id of this transaction is 3146, the type of the transaction is
create, and the array of value-payee pairs is
<pre>[(2.1, 7xxxx...), (3.2, 8xxx)]
</pre>

In this transaction the bank creates a coin of value 2.1 and gives it
to the agent with public key 7xxxx..., and the bank also
creates a coin of value 3.2 and gives it
to the agent with public key 8xxxx...

<p>
The pair:
<pre>
(transaction id, index into array of value-payee pairs)
</pre>
uniquely identifies a (value, payee) tuple.
<p>
For example (3146, 0) --- 
transaction id 3146, and array index 0 --- identifies value-payee[0] of
transaction 3146 which is specified by the 2-tuple (2.1, 7xxxx...). So, the
transaction id and index, (3146, 0), tells everybody that the agent
with public key 7xxxx received 2.1 units of coin. When this
transaction is in a tamper-resistant ledger, every agent from that point
onwards knows that agent 7xxxx received 2.1 coins. This information is
in a permanent record. 
<p>
Likewise, (3146, 1) --- 
transaction id 3146, and array index 1 --- identifies value-payee[1] which
is the 2-tuple (3.2, 8xxxx...).
<p>
(Strictly speaking, the transactions aren't in a 
permanent record --- they are in a tamper-evident data structure. But, we'll see
that tamper-evidence is sufficient for many practical purposes.)

<h3 class="w3-text-teal">Pay transaction</h3>
Coins are transferred from payers to payees in a pay transaction.
The payers are identified by a list of 2-tuples, where each 2-tuple is

<pre>
(transaction id, index into array of value-payee pairs)
</pre>

where <code>transaction id</code> is the id of the transaction in the
tamper-resistant ledger. As we said earlier, this pair uniquely identifies an agent and a
value that this agent acquired in this transaction.
For example the pair --- transaction id, index --- such as (3146, 0)
identifies the 2-tuple (2.1, 7xxxx...); this 2-tuple asserts
that the agent
with public key 7xxxx received 2.1 units of coin in 
transaction 3146. The <i>entire amount</i> specified in the 2-tuple (2.1 in our
example) is value that flows into the transaction.


    <figure>
    <img src="CryptoCurrencyIntroduction/Slide3.jpg" alt="Fig1" style="width:100%">
    <figcaption>Fig.3: Hash Pointer points to a Tamper-Evident Ledger
    of Data</figcaption>
</figure>

The outflow of coins is specified by an array of value-payee pairs,
exactly as in a create transaction. 

<h5 class="w3-text-teal">Managing amounts spent in a transaction</h5>
A transaction-id, index pair --- such as (3146, 0)
identifies a 2-tuple such as (2.1, 7xxxx...); this 2-tuple asserts
that the agent
with public key 7xxxx received 2.1 units of coin in 
transaction 3146. The <i>entire amount</i> specified in the 2-tuple (2.1 in our
example) is value that flows into the transaction. What should this
agent do if it
wants to put in more than 2.1 coins into the transaction? Or less than
2.1 coins?

<p>
To put in more value, the bank identifies other transaction-id, index
pairs in which this agent received coins. For example, say that (4539, 2)
identifies a 2-tuple (3.2, 7xxxx), and assume that the payers in this transaction
are specified by the pairs (3146, 0) and (4539, 2). The pair (3146, 0)
asserts that agent (7xxxx) received 2.1 coins and the pair (4539, 2)
asserts that the same agent received 3.2 coins. So the total amount of 
coins flowing into this
transaction from this agent (7xxxx) includes 2.1 + 3.2.

<p>
To put in less value, the agent acts as both payer and payee; the net
value that this agent pays out to other agents is the difference
between the amount that this agent puts in and takes out. For example,
if agent with public key 7xxxx wants to put in 1.9 coins into this
transaction its payer information can be given by the transaction-id,
index pair (3146, 0) which asserts that the agent received 2.1 coins
and the same agent is a payee that withdraws 0.2 coins.


<h5 class="w3-text-teal">Preventing Double Spending</h5>
How does the system prevent an agent from using the
same coin twice? 

The bank checks that the agent hasn't already spent the coin that it
is putting into a transaction. For example, the transaction id, index pair
(3146, 0) identifies the 2-tuple (2.1, 7xxxx...); this tuple
asserts that the agent
with public key 7xxxx received 2.1 units of coin in 
transaction 3146. The bank inspects the tamper-resistant ledger
for all transactions after transaction 3146 and before the current
transaction to ensure that the agent (7xxxx) hasn't already spent the
2.1 coins that it got in transaction 3146.

Every agent that has the bank's hash pointer to the end of the
tamper-evident ledger can inspect the ledger to check that
double-spending hasn't occurred.

<p>
The bank signs a valid transaction and appends it to the
tamper-resistant ledger. All agents can see the bank's signature and
verify that nobody (not even the bank) has tampered with the
tamper-resistant ledger.

<h4 style="color:red;">Example of a pay transaction</h4>
 An example of the specification of a pay transaction is:
<pre>
(9431, pay,
  [(3146, 0), (4731, 2)],
  [(0.7, 7xxxx...), (4.6, 9xxxx...)]
).
</pre>
The id of this transaction is 9431; the type of the transaction is
pay; the payers into the transaction are identified by the pairs of
(transaction-id, index): (3146, 0), and (4731, 2); and the
payee array is [(0.7, 7xxxx...), (4.6, 9xxxx...)].

<h3 class="w3-text-teal">Transaction validity</h3>

The bank appends a transaction to <code>L</code> if and only if the
transaction is valid. The bank checks for validity by carrying out the
following steps:
<ol>
  <li>
  The bank verifies that the payers into the transaction signed the
  transaction.
  </li>
  <li>
  The bank checks that the total value of coins paid out from the
  transaction does not
  exceed the total value paid in to the transaction. (If the value paid
  in exceeds the value paid out then the bank takes the difference as
  a transaction fee. More about fees later.)
  </li>
  <li>
  The bank verifies that the payers' claims to have received coins in
  previous transactions is genuine. For example,
  if the agent with
  public key 7xxxx... claims to have received coins worth 2.1 in the
  transaction with id 10, and payee array index 0, then the bank
  verifies this claim by that transaction.
  </li>
  <li>
  The bank ensures that coins paid into the transaction haven't
  already been spent.
  </li>
</ol>

<h3 class="w3-text-teal">Optimizations: Blocks and Block Chain</h3>
Verifying large numbers of small transactions requires more
computation than verify smaller numbers of blocks of transactions.
A <i>block chain</i> is a tamper-evident ledger in which
each element of the ledger is a block of transactions.
A block of transactions can be aggregated into a single large
transaction by aggregating all the payers and payees of the smaller
transactions. 

<h3 class="w3-text-teal">Checking the Trusted Agent</h3>
Consider a system in which the trusted agent broadcasts its current
copy of the tamper-evident ledger to all agents.
Every agent can inspect its copy of the tamper-evident ledger to determine whether the
ledger has been tampered with. So, every agent can validate its trust
in the trusted agent; however, this validation
suffers from a crucial problem: Agents may only
have copies of <i>old, stale</i> versions of the ledger.
By the time that an agent receives a copy of the ledger, the trusted
agent may have added more transactions to the ledger.


    <figure>
    <img src="CryptoCurrencyIntroduction/Slide4.jpg" alt="Fig4" style="width:100%">
    <figcaption>Fig.4: Old Copy is a Prefix of the Block Chain</figcaption>
</figure>

<p>
An old copy of the ledger can differ from the current copy in only one
way: the current copy may have transactions appended to the end
of the old copy. So all agents can validate <i>past</i> behavior of the
trusted agent. An agent cannot, however, treat its copy of the ledger
as the master copy because the agent may not have the transactions
added most recently to the ledger.

<p>
In the next module we will see how the BitCoin algorithm addresses
this problem.



<h3 class="w3-text-teal">Advantages of this cryptocurrency</h3>
Any agent can get a copy of the tamper-resistant ledger and verify that all
transactions in the ledger are valid. Any agent can verify that
the only way in which the ledger is modified is that elements are
append to its tail; all that the agent needs to do is to check that
the pointer to the tail is modified only by appending
elements. Because the ledger is tamper-evident, an agent can check
that the ledger doesn't change while the hash pointer to the end
of the ledger doesn't change.

<p>
The bank can't forge a transaction because all payers sign the
transaction. Agents can remain anonymous because an agent's only
public information is the agent's public key, and an agent can create
multiple public keys. Every agent can verify the correctness of every
transaction.

<h3 class="w3-text-teal">Disadvantages of this cryptocurrency</h3>
Users may not trust the bank. Transactions are not private because the
bank has a record of all transactions. And the bank is a single point
of failure.

<p>
Next we'll look at BitCoin's algorithms for
implementing a cryptocurrency without trusted agents.


  <footer id="myFooter">

    <div class="w3-container w3-theme-l1">
      <h4>An Introduction to Distributed Algorithms by K. Mani Chandy,
      <br>
      Simon Ramo Professor, Emeritus, California Institute of Technology</h4>
    </div>
  </footer>


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
