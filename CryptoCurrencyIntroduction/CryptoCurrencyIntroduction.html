<!DOCTYPE html>
<html lang="en">
<title>CryptoCurrencyIntroduction</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new4 {
  border: 5px solid blue;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}

</style>

<body>

<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()"><i class="fa fa-bars"></i></a>
    <a href="../index.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">About the Course</a>
    <a href="../table_of_contents.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">Table of Contents</a>
    <a href="../cross_reference.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Index</a>
  </div>
  </div>
 

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left" id="mySidebar">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="Close Menu">
    <i class="fa fa-remove"></i>
  </a>
  
  <h3 class="w3-bar-item"><b>An Introduction to Distributed
  Algorithms</h3>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="LabeledGraph.html">Labeled Graphs and System Progress</a>
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="LabeledGraphExample.html">Examples</a>
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="LabeledGraphSelfTest.html">Self Tests</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="LabeledGraphExercises.html">Exercises</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="LabeledGraphExplorations.html">Explorations</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="../BitCoin/BitCoin.html">Next: Bitcoin</a> 
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="../Byzantine_Oral/Byzantine.html">
  Previous: Byzantine Consensus: Oral</a> 
  
</nav>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
  <div class="w3-row w3-padding-64">
  <div class="w3-twothird w3-container">
    
    <h2 class="w3-text-teal">Introduction to Cryptography for
    Cryptocurrency</h3>
    
    <a href="https://www.lopp.net/pdf/princeton_bitcoin_book.pdf">
    This Princeton University book is a superb description of
    Bitcoin.</a> The book is longer than 
    this module. If you have the time, read the book and skip this
    module. 

    <p>
    This module contains a review of elementary cryptographic
    operations that you may know already. It also introduces a simple
    cryptocurrency managed by a trusted agent. The next module
    discusses the algorithm underlying BitCoin; this algorithm doesn't
    require agents to be trusted.


    
    <h3 class="w3-text-teal">Review: Cryptographic Hash Function</h3>
    A  hash function, \(H\), maps input strings of
    arbitrary size to outputs of 
    fixed size, does so efficiently. Let \(n\) be the number of output
    bits of \(H\).

    <h4 class="w3-text-teal">Collision Resistance</h4>
    Input values \(x, y\) are said to <i>collide</i> when \(H(x) = H(y)\).

    <p>
    Let's look at the following problem: Given \(H\), find any
    colliding pair \(x, y\).
    
    Let's look at a brute-force algorithm to solve this
    problem. Suppose \(n\) is \(3\). We could compute hash values for
    all \(8\) input strings of length \(3\) and one input string of
    length \(4\). From the pigeon-hole principle, if \(9\) inputs are
    mapped to \(8\) possible outputs then at least two of the inputs
    must have the same output. So, we can solve the problem in at most
    \(9\) steps.

    <p>
    We can find collisions, using this brute-force algorithm, for any
    \(n\); however, the computation time is of the order of
    \(2^{n}\). Are there fast ways of finding collisions where the
    computation time is polynomial rather than exponential in \(n\)?
    That depends on the hash function.

    <p>
    A hash functions is said to be <i>collision resistant</i> if 
    the only known ways of
    finding collisions in the hash functions are about as slow as
    the brute force algorithm. 
    

    <h4 class="w3-text-teal">Hiding</h4>
    Your soccer friend predicts the winner, \(W\), of the 2022 World
    Cup. She tells you the hash function, \(H\), and gives you the
    hash, \(y\), where \(y = H(W)\).
     After the World Cup is over, she
    reveals her prediction, \(W\), by showing that \(H(W)\) is indeed
    \(y\). That's one way of making a commitment and revealing it
    later. 

    <p>
    Can you discover her prediction before she reveals it?

    <p>
It's easy. There are only 32 teams playing. Compute \(H(x)\) where
    \(x\) runs over each of the 32 teams. One of those teams has to be
    \(W\). You can discover her prediction in at most 32 steps.

    <p>
    If you believe that she will pick Brazil with high
    probability, then your expected time to discover her prediction
    will be even faster if you begin by checking: \(H(Brazil) \stackrel{?}{=} y\). 

<p>
Let's modify the problem.  She selects a secret value \(r\). Instead
of giving you \(H(W)\), she gives you \(y\) where \(y = H(r + W)\) and
where \(+\) indicates concatenation of strings. But, she doesn't give you \(r\). Can
you discover \(W\) from \(H\) and \(H(r + W)\)?

<p>
Let's modify the problem further.Suppose that you are certain that she predicted the
winner to be Brazil. All you have to do to prove that she predicted
Brazil is to find an \(r\) such that \(H(r + Brazil) = y\).
How easy is finding such an \(r\)?

<p>
That depends on the distribution from which \(r\) is picked. If \(r\)
is the string "password" with probability 0.999 then you are likely to
find \(r\) with high probability.
If, however, the distribution from which \(r\) is picked is
spread out, then \(r\) is unpredictable, and finding \(r\) is
infeasible. 

<p>
A hash function, \(H\) is said to be <i>hiding</i> exactly when all
algorithms to compute \(x\), given only \(H(r+x)\) and \(H\), take so
much time that solving the problem is practically impossible ---
provided that \(r\) is picked from a spread-out distribution.
    

    <h4 class="w3-text-teal">Puzzle Friendly</h4>
Let \(r\) be a value picked from a spread-out distribution. Let \(Y\)
    be a set of \(n\)-bit values. Consider the following problem:
    Given \(H\), and \(Y\), compute any \(x\) such that \(H(r+x) \in
Y\).

<p>
The hash function, \(H\), is said to be <i>puzzle friendly</i>
    exactly when any algorithm to solve this problem is not much
    better than the brute force algorithm that tries every possible
    value of \(x\). In other words, the number of steps taken by any
algorithm that solves this problem is not significantly lower than \(2^{n}\).

<p>
The number of tests of a random number \(x\) before finding a value
that satisfies \(H(r+x) \in Y\) is a random variable.

<p>
Consider three
puzzles: In the first puzzle \(Y\) consists of a single value,
\(K_{1}\); in the first puzzle \(Y\) consists of a different single value,
\(K_{2}\); and in the third puzzle \(Y\) consists of a both
\(K_{1}\) and \(K_{2}\). Let the times to solve these three puzzles be
\(t_{1}, t_{2}, t_{3}\) respectively. These times are random
variables, and
<p>
\(
t_{3} = \textrm{min} \: (t_{1}, t_{2})
\)
<p>
because puzzle 3 is solved when the first of puzzle 1 or
puzzle 2 is solved. So, we can control the expected time to solve a
puzzle by changing the cardinality of \(Y\)

<h5 class="w3-text-teal">A cryptographic hash function</h5>
<i>A cryptographic hash function is one that is collision resistant,
hiding and puzzle-friendly.
</i>

<h3 class="w3-text-teal">Hashing Inputs of Arbitrary Length</h3>
Let \(f\) be a function that operates on input strings
of fixed length and produces output strings of fixed length. Let the
input and output strings of \(f\) have lengths \(M + N\) and \(M\),
respectively. We look at functions where \(N > 0\), and since the
output is smaller than the input, \(f\) is called a <i>compression
function.</i>

<p>
Let \(g\) be a function that operates on input strings of arbitrary
lengths. Example code is given below where <code>InitialValue</code>
is a given constant string.

<pre>
def g(y):
    output = InitialValue

    // pad y so that it's length is a multiple of N
    if len(y)%N > 0:  y = y + "0"*(N - len(y)%N)

    // partition y into blocks of size N
    blocks = [y[i: i+N] for i in range(0, len(y), N)]

    for block in blocks: output = f(output+block)
    return output
</pre>

<h3 class="w3-text-teal">Hash Pointers</h3>
A hash pointer is a pair \(ptr, y\) where \(ptr\) is a pointer that
points to an item of data, and \(y\) is a cryptographic hash of that
item of data. Any data structure with pointers can be converted into a
data structure with hash pointers replacing pointers.

<h3 class="w3-text-teal">Tamper-Evident Data Structures</h3>
Let's look at the familiar linear linked list.
Each element of the linear linked list contains two parts: data and
a pointer to the next element of the linked list. Consider a linked
list to which elements can be appended but not deleted. Let's call the
very first element in the list the <i>genesis</i> element, or the \(0\)-th
element, when the list is not empty.
Let's call the element whose pointer points to the \(i\)-th element, 
the \(i+1\)-th element.
When we replace the pointer part of the familiar list by a hashed
pointer we get a <i>tamper-evident linear list.</i>

<p>
The \(i+1\)-th element consists of (1) data, \(D[i+1]\), (2) a pointer
\(ptr[i+1]\) to the location of the \(i\)-th element and (3) a hash
\(H[i+1]\) of the \(i\)-th element.  The pointer of the \(0\)-th
element is <code>None</code> or some symbol that indicates empty.

<p>
If \(D[i]\), \(ptr[i]\) or
\(H[i]\) are changed then the changed values will not match
\(H[i+1]\). This is because collisions are
 unlikely, and so the hashes of the original and modified
values are unlikely to be identical.

<p>
Suppose a malicious agent modifies \(D[i]\), \(ptr[i]\) or
\(H[i]\). Then another agent can detect this tampering because the
hash pointer \(H[i+1]\) will no longer match the \(i\)-th data.

<p>By induction on \(i\), any agent can detect
changes to any \(D[i]\), \(ptr[i]\) or \(H[i]\), unless \(H[j]\)
<i>for all \(j > i\)</i> are also modified to match the changes.
So any agent with the hash function \(H\) can detect any change to
the list provided that \(H[n]\) --- the pointer
to the last element --- cannot be changed.


<h5 class="w3-text-teal">Tamper-Evident Acyclic Graphs and Merkle
Trees</h5>
The idea described in the previous paragraph to convert linear linked
lists can be used to convert directed acyclic graphs, in which nodes are
connected by pointers, into tamper-evident graphs. A specific case of
a directed acyclic graph is a rooted tree.

<p>
A <i>Merkle tree</i> is a special case of a binary balanced tree in
data items are stored only in the leaves, while the other nodes of the
tree contain only hash pointers to nodes in the next level down.
To prove that an element at the leaf is a member of the tree we need only the
\(log_{2}(n)\) hash pointers on the path from the root to that
leaf. By contrast, to prove that an element is a member of a linear
list we need to inspect \(O(n)\) elements, on average.

<h3 class="w3-text-teal">Keys and Signed Messages</h3>
You can create a random public-key, private-key pair 
<a href="https://en.wikipedia.org/wiki/Ssh-keygen">
by calling a function on your computer.</a>
With high probability, nobody else has this
specific pair of keys. Each individual's private key is a secret held
by that individual. Public keys are accessible by everybody.

<p class="w3-text-teal">Sending messages securely</p>
Keys are used to send messages securely.
Kamala sends a secure message to Joe by encrypting the message with
Joe's public key; Joe decrypts the message using Joe's private key.
An agent cannot decrypt the encrypted message without Joe's private key.

<p class="w3-text-teal">Signing messages</p>
Suppose Kamala needs to send a signed message to Joe while
ensuring that nobody can forge her signature. She encrypts the message
<i>M</i> with her private key to get an encrypted message <i>M'</i>,
and sends the pair <i>(M, M')</i> securely to Joe. When Joe receives
<i>(M, M')</i>, Joe decrypts
<i>M'</i> using Kamala's public key to get the decrypted message
<i>M''</i>. If <i>M'' = M</i> then Joe knows that Kamala sent
<i>M</i> because only an agent with Kamala's private signature could
have sent that message.

<h2 class="w3-text-teal">Cryptocurrency managed by a trusted
agent</h2>
Let's start with a currency managed by a trusted agent that we will
call a bank. Later, we will
look at a consensus algorithm, very different from Paxos and Byzantine
Generals, which will allow us to do without the trusted agent.

<p>
The bank maintains a tamper-evident linear list
<code>L</code> of transactions.
Any agent can get a copy of <code>L</code> at any point, and there may
be mechanisms for broadcasting updates of <code>L</code> to 
agents.

<p>
A transaction is one of
two types: <i>create</i> or <i>pay</i>.
In a pay transaction, payers --- i.e. agents, other than the bank
--- give coins that they possess to payees. An agent can be both a
payer and payee of the same transaction.
In a create transaction the bank creates coins that it gives to
agents --- the payees of the transaction; the bank acts as the payer.
We won't discuss the permissions that a bank needs to create coins.

<p>
A pay transaction is signed by all payers of the transaction.
A create transaction is signed by the bank.

<p>
Each element of <code>L</code> has (1) a unique id; (2) the type of
the transaction, either create or pay;
(3) <i>payers</i>: only for pay transactions --- 
a list indicating the agents who pay coins into the transaction and
the amounts that they put in.
(4) <i>payees</i>: for both create and pay transactions --- an
array indicating agents who receive coins in the transaction and the
amounts that they receive.

<p>
The payees in a transaction are specified by an array of 2-tuples:
<pre>
(value, payee public key).
</pre>
Each element of the array indicates that a coin
of the specified value is given to the agent
with the specified public key.

<p>
Later, we will describe how payers are specified.

<h4 style="color:red;">Example of a create transaction</h4>
 An example of the specification of a create transaction is:
<pre>
(10, create,  [(2.1, 7xxxx...), (3.2, 8xxx)]).
</pre>
The id of this transaction is 10, the type of the transaction is
 create, and the payees of the transaction are specified by the array
of 2-tuples:
<pre>
[(2.1, 7xxxx...), (3.2, 8xxx)]
</pre>

In this transaction the bank creates a coin of value 2.1 and gives it
to the agent with public key 7xxxx..., and the bank also
creates a coin of value 3.2 and gives it
to the agent with public key 8xxxx...

<p>
The pair: (transaction id, payee array index) identifies 
the payee public key and the amount that the payee receives in the
transaction. 
For example (10, 0) --- 
transaction id 10, and array index 0 --- identifies the 2-tuple
(2.1, 7xxxx...).

<h3 class="w3-text-teal">Pay transaction</h3>
The payers in a pay transaction are specified by a list of 2-tuples, 
(transaction id, payee array index). For example, (10, 0), specifies
that the agent with public key 7xxxx was given a coin worth 2.1 in the
transaction with id 10; this agent is now a payer in the current
transaction and this agent pays a coin worth 2.1 into the current
transaction.

<p>
The bank checks that the agent hasn't already spent the coin after
receiving it in transaction with id 10 and before the current
transaction. To do so, it inspects the transactions in <code>L</code>
between the transaction at which the agent receives a coin and the
transaction in which the agent spends the coin.

<p>
Consider a transaction in which an agent with public key 7xxxx, who
received a coin worth 2.1 in an earlier transaction, gives a coin
of value 1.4 to an agent with public key 8xxxx and keeps a coin worth
0.7 for itself. The payee array for this transaction includes the
elements (1.4, 8xxxx), (0.7, 7xxxx).

<h4 style="color:red;">Example of a pay transaction</h4>
 An example of the specification of a pay transaction is:
<pre>
(12, pay,
  [(10, 0), (10, 1)],
  [(0.7, 7xxxx...), (4.6, 9xxxx...)]
).
</pre>
The id of this transaction is 12; the type of the transaction is
pay; the payers into the transaction are identified by the pairs of
transaction id and payee array index: (10, 0), and (10, 1); and the
payee array is [(0.7, 7xxxx...), (4.6, 9xxxx...)].

<p>
Who are the payers into this transaction? The transaction id 10, and
payee array index 0, identifies the pair (2.1, 7xxxx...): the agent
wth public key 7xxxx... who received a coin worth 2.1 in the
transaction with id 10. Likewise,
transaction id 10, and
payee array index 1, identifies the pair (3.2, 8xxxx...): the agent
wth public key 8xxxx... who received a coin worth 3.2 in the
transaction with id 10.
So, the payers into this transaction are the agents with id
7xxxx... and 8xxxx..., and the total value of coins paid into the
transaction is 2.1+3.2 = 5.3. The payers sign this transaction.

<p>
The payees in this transaction are the agents with public keys
7xxxx... and 9xxxx... who receive coins worth 0.7 and 4.6,
respectively.

<h3 class="w3-text-teal">Transaction validity</h3>
The bank appends a transaction to <code>L</code> if and only if the
transaction is valid. The bank checks for validity by carrying out the
following steps:
<ol>
  <li>
  The bank verifies that the payers into the transaction signed the
  transaction.
  </li>
  <li>
  The bank checks that the total value of coins paid out from the
  transaction does not
  exceed the total value paid in to the transaction. (If the value paid
  in exceeds the value paid out then the bank takes the difference as
  a transaction fee. More about fees later.)
  </li>
  <li>
  The bank verifies that the payers' claims to have received coins in
  previous transactions is genuine. For example,
  if the agent with
  public key 7xxxx... claims to have received coins worth 2.1 in the
  transaction with id 10, and payee array index 0, then the bank
  verifies this claim by that transaction.
  </li>
  <li>
  The bank ensures that coins paid into the transaction haven't
  already been spent.
  </li>
</ol>

<h4 class="w3-text-teal">Optimizations: Blocks</h4>
Verifying large numbers of small transactions, with a concommitant long
ledger <code>L</code> is more expensive than verify small numbers of
large transactions with a shorter ledger. Some payers in a large transaction
may pay to some payees, while other payers pay to other payees,
and we can make a transaction as big as we want. The disadvantage of
requiring large transactions is that the system may have to wait for
enough small transactions to arrive. In the next module we will show
how transactions are put into blocks and we refer to the ledger as a
<i>block chain</i>.


<h4 class="w3-text-teal">Advantages of this cryptocurrency</h4>
Any agent can get a copy of <code>L</code> and verify that all
transactions in <code>L</code> are valid. Any agent can verify that
the only way in which <code>L</code> is modified is that elements are
append to its tail; all that the agent needs to do is to check that
the pointer to the tail is modified only by appending
elements. Because <code>L</code> is tamper-evident, an agent knows
that <code>L</code> doesn't change while the hash pointer to the end
of <code>L</code> doesn't change.

<p>
The bank can't forge a transaction because all payers sign the
transaction. Agents can remain anonymous because an agent's only
public information is the agent's public key, and an agent can create
multiple public keys. Every agent can verify the correctness of every
transaction.

<p>
The problem with this cryptocurrency arises if the
bank is not trusted.Next we'll look at BitCoin's algorithms for
implementing a cryptocurrency without trusted agents.


  <footer id="myFooter">

    <div class="w3-container w3-theme-l1">
      <h4>An Introduction to Distributed Algorithms by K. Mani Chandy,
      <br>
      Simon Ramo Professor, Emeritus, California Institute of Technology</h4>
    </div>
  </footer>


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
