<!DOCTYPE html>
<html lang="en">
<title>Example</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
</style>
<body>


<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()"><i class="fa fa-bars"></i></a>
    <a href="../index.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">About the Course</a>
    <a href="../table_of_contents.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">Table of Contents</a>
    <a href="../cross_reference.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Index</a>
  </div>
  </div>
 

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left" id="mySidebar">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="Close Menu">
    <i class="fa fa-remove"></i>
  </a>

  <!-------------------------->
  <h3 class="w3-bar-item"><b>An Introduction to Distributed
  Algorithms</h3>
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="Overview.html">Chapter: Common Proof Patterns</a>
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="ProofsOfSafety.html">How to Prove Safety</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="ProofsOfProgress.html">How to Prove Progresss</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="ProofPattern.html">ProofPattern</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="Examples.html">Examples</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="SelfTest.html">Self Test</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="../Chapter_6/Overview.html">
  Next Chapter: Diffusing Computations</a> 
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="../Chapter_4/Overview.html">Previous Chapter:
  State Transition Systems</a>
  
</nav>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
  <div class="w3-row w3-padding-64">
  <div class="w3-twothird w3-container">

    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">An Example of a Proof Pattern</h1>

    <p>
    This module has examples of a class of algorithms that can be
    proved by using the proof pattern described in earlier
    modules. Later, we will study other classes of algorithms with
    different patterns of proof.
    </p>

    <h2 class="w3-text-teal">A Class of Algorithms</h2>

    <p>The class of algorithms that we explore now is specified as:
    </p>

    <p>
    \(
    init \leadsto goal
    \)
    </p>

    <p>
    and
    <p>
    \(
    stable(goal)
    \)
    </p>

    <p>
    where \(init\) is the initial condition, and \(goal\) is the
    desired outcome. As for the earliest meeting time example, we want
    the goal to be stable to simplify methods for detecting whether
    the goal has been reached.
    <p>
    </p>

    <p>
    In the earliest meeting time example, \(init\) is \(t =
    \emptyset\), and \(goal\) is \(t = M\), where \(t\) is a tuple in
    which \(t_{i}\) is a variable of agent \(i\).



    <!------------------------------------------------->
    <h2 class="w3-text-teal">A Proof Pattern</h2>
    
    <p>
    A proof pattern is given in the previous module. Next, we repeat
    the pattern. We also add structure to the pattern, where the
    structure is specific for this class of algorithms. There are many
    variations of this pattern, and you should develop variations that
    best fit the classes of problems that you face.
    </p>

    <p>
    Let \(t\) be the tuple of variables of the system, and so the
    state of the system is given by the value of \(t\).
    </p>


    <p>
    The pattern consists of the following steps:
    </p>

    <h3 class="w3-text-teal">Step 1: Safety Properties. </h3>

    <h4 class="w3-text-teal"> Prove that every state change takes
    the system towards the goal.</h4> 
    
    <p class="w3-text-teal">
    Step 1a: Prove that initial states are safe.
</p>

<p>
Prove:
    \(
    (init \Rightarrow safe)
    \)
    </p>
    
    <p class="w3-text-teal"> Step 1b: Find variant function
    </p>

    <p>
    Find a function \(f\) from states that satisfy \(safe\) to the integers or tuple of
    integers where \(f\) is bounded below. More generally, find \(f\) where the image of \(f\)
    is a well-founded set. 
    </p>

<p class="w3-text-teal">
Step 1c: Prove that state changes take the system safely towards the goal.
</p>

<p>
Prove that:
</p>

<p>
\(
safe \wedge (\neg goal) \wedge (t = T)
\; \rightarrow \;
(t = T) \vee goal \vee (safe \wedge (f(t) < f(T))
\)
</p>

<p>
This formula says that every transition from a safe, non-goal state is
to one of the following:
<ol>
  <li>
  the same state
  </li>
  <li>
  a goal state
  </li>
  <li>
  a safe state that is closer to the goal, i.e. \(f(t) < f(T)\).
  </li>
</ol>
<p>

<p>
We prove this formula by using the
<a href="ProofsOfSafety.html">key safety definition.</a>

<h3 class="w3-text-teal">Step 2: Atomic Properties</h3>
<h4 class="w3-text-teal">Prove that the system leaves non-goal states.</h4>

<p>
The second step is to prove that:
</p>
\(
    safe \wedge (\neg goal) \wedge (t = T) \; \leadsto \; t \neq T
\)
</p>

<p>
This step proves that the system transits out of all safe, non-goal
states, eventually. We prove this step by using the atomic property and the
<a href = "../Formulae.html">property of disjunction of the left-hand
sides of \(\leadsto\)</a>.



<h3 class="w3-text-teal">Step 3: Basic Properties</h3>
<h4 class="w3-text-teal"> Prove that the system
moves from non-goal states towards the goal.</h4>

<p>
The third step uses the <a href = "ProofsOfProgress.html">basic
property</a>
to combine the results of
the first two steps to prove that every trajectory from a safe
non-goal state reaches a goal state or a safe state that is closer to
the goal.
</p>

    <p class="w3-text-teal">
    \(
safe \wedge (\neg goal) \wedge (t = T)
\; \leadsto \;
goal \vee (safe \wedge (f(t) < f(T)))
\)
</p>


<h3 class="w3-text-teal">Step 4: Transitivity</h3>

<h4 class="w3-text-teal">Prove that the system
moves from safe states to the goal.</h4>
<p>
From the variant function, \(f\), and the corollary of the
transitivity of \(\leadsto\):
</p>

<p>
\(
safe \; \leadsto \; goal
\)
</p>

<p>
Strengthening the left-hand side of this formula gives the desired
result:
</p>

<p>
\(
init \; \leadsto \; goal
\)
</p>


<!------------------------------------------->
<h3 class="w3-text-teal">Summary: Proof Obligations in the
Pattern</h3>
<p>
The proof obligations consist primarily of steps 1 and 2: proving
safety properties from Hoare triples of actions, and using atomic
properties with other forumulae to prove that the system does not
remain forever in a non-goal state.
Step 3 follows directly from the basic property. Step 4 follows
directly from the variant function. 
</p>

<!------------------------------------------->
<h2 class="w3-text-teal">Example 1: Minimum Value across Agents</h2>
<p>
We carry out the proof of this trivial example in excruciating detail,
and we carry out all four steps to illustrate the proof pattern. We
will skip obvious steps in later examples. 
</p>

<p>
The system consists of a set of \(N > 0\) agents. Each agent has a local
constant, and the goal of the algorithm is for every agent to compute
the minimum of the constants.
</p>

<p>
Let \(D\) and \(t\) be \(N\)-vectors where \(D[i]\) is a 
constant, and \(t[i]\) is a variable, of agent \(i\).  Let
\(m\) be the maximum element of \(D\), and let \(M\) be an
\(N\)-vector all of whose elements are \(m\). The specification of the
algorithm is:
</p>

<p>
\(
t = D \; \leadsto \; t = M
\)
</p>
<p>
and
</p>
<p>
\(stable(t = M)\)
</p>

<h3 class="w3-text-teal"> An Algorithm</h3>
<p>
Let's look at an algorithm with an infinitely-often action \(a_{i,j}\)
for every ordered pair \(i, j\). The action, specified as a command,
is:
</p>
<p>
<code>
t[j] = min(t[i], t[j])
</code>
</p>

<h3 class="w3-text-teal">Proof of Correctness</h3>
Next, we carry out the steps of the proof pattern.

 <h3 class="w3-text-teal">Step 1: Safety Properties. </h3>

    <h4 class="w3-text-teal"> Prove that every state change takes
the system towards the goal.</h4>

<p>Steps 1a, 1b</p>


<p>
    \(
    safe = (M \leq t \leq D)
    \)
</p>
<p>
    \(
    f(t) = (t - M)
    \)
</p>

<p class="w3-text-teal">
Step 1c: Prove that state changes take the system safely towards the goal.
</p>

<p>
The proof obligation in this step can be simplified to:
</p>

<p>
\(
(M < t \leq D) \wedge (t = T) \; \rightarrow \;
 (M \leq t \leq T)
\)
</p>
<p>
which follows directly from the Hoare triples for all the actions.
</p>



<h3 class="w3-text-teal">Step 2: Atomic Properties</h3>
<h4 class="w3-text-teal">Prove that the system leaves non-goal states.</h4>

<p>
The proof obligation in the second step simplifies to:
<p>
\(
(M < t \leq D) \wedge (t = T) \; \leadsto \; ( t \neq T)
\)
</p>

<p>
The proof is as follows. From the atomic property, since action
\(a_{i,j}\) is executed infinitely often:
<p>
\(
(M < t \leq D) \wedge (t = T) \wedge (t[i] < t[j]) \; \leadsto \; ( t \neq T)
\)
</p>

<p>
The result follows by taking the disjunction of the left-hand sides
over all \(i, j\), and using \(M < t \Rightarrow (\exists i, j: t[i] <
t[j])\).
</p>

<p> Applying the basic property and transitivity with the variant
function proves \(t = D \; \leadsto \; t = M\). The proof that \(t=M\)
is stable follows directly from the Hoare logic for all actions
\(a_{i,j}\). 
</p>

<h2 class="w3-text-teal">Example 1b: A Variation of the Algorithm</h2>
In this variation, the 
action \(a_{i,j}\) is nondeterministic and is specified by the
following Hoare triple: 
</p>

<p>
\(
\{(t[j] > t[i]) \wedge (t = T) \} a_{i,j} \; \{T[i] \leq t[j] < T[j]\}
\)
</p>

<p>
The action decreases the larger value, \(t_{j}\), to any value up to
\(T_{i}\). 
</p>

<p>
It's easy to check that the proof for the previous algorithm works.
</p>


<!--------------------------------------------------------->
<h2 class="w3-text-teal">Example 2: Concurrent Sorting</h2>
Let \(D\) be a constant vector of length \(N\). Let \(M\) be the vector
obtained by sorting \(D\) in ascending order, i.e., \(M\) is a
permutation of \(D\), and \(M\) is in ascending order. Let \(t\) be a
vector of length \(N\) where \(t\) is a variable and where the state
of the system is given by \(t\).
</p>

<p>
The problem specification is:
</p>

<p>
\(
t = D \; \leadsto \; t = M
\)
</p>
<p>
and
</p>
<p>
\(stable(t = M)\)
</p>

<h3 class="w3-text-teal">An Algorithm</h3>
Associated with each action \(a\) is a pair of integers \(l_{a}\) and
\(h_{a}\) where \(l_{a} < h_{a}\). Action \(a\) sorts \(t[l_{a},
\ldots , h_{a}]\). So, a Hoare triple is:
</p>

<p>
\(
\{t=T\} \; a \; \{t = T'\}
\)
</p>

<p>
where \(T'\) is a permutation of \(T\) and \(T'[l_{a}, \ldots ,
h_{a}]\) is in ascending order.
</p>


<p>
For all \(i\), there exists an action \(a\) that is executed
infinitely often and whose span covers \([i, i+1]\), i.e.
</p>

<p>
\(l_{a} \leq i < h_{a}\)
</p>

<p>
<i>Example</i>:  \(t\) has 100 elements, and the system has actions \(a,
b, c, d\)
that sort the intervals \([0, \ldots , 60]\), \([20, \ldots , 80]\), \([70,
\ldots , 99]\), and \([25, \ldots , 75]\) respectively.
Actions \(a\), \(b\), and \(c\) are executed infinitely often,
while action \(d\) is executed an arbitrary number of times.
Note that every adjacent pair of elements in \(t\) is
spanned by the intervals sorted by \(a\), \(b\), or \(c\). 
</p>

<h3 class="w3-text-teal">Proof of Correctness</h3>
<p class="w3-text-teal">Step 1</p>

<p>
\(safe\) is: \(t\) is a permutation of \(D\).
</p>

<p>
The variant function \(f\) is the number of out-of-order pairs
\((i,j)\) in \(t\) where a pair is out of order when \((i < j) \wedge
(t[i] > t[j)\).
</p>

<p>
Using Hoare triples for each action, it is straightforward to prove
that every state transition is either back to the same state or
to a safe state closer to the goal.
</p>

<p class="w3-text-teal">Step 2</p>
Since there exists an action, executed infinitely often, that orders
\(t[i, i+1]\) in ascending order, it follows that:
</p>

<p>
\(
(t = T) \wedge (t[i] > t[i+1]) \; \leadsto \; (t \neq T)
\)
</p>

<p>
Taking the disjunction of the left-hand sides and simplifying gives
the desired result:
</p>

<p>
\(
(t = T) \wedge (\neg goal) \; \leadsto \; (t \neq T)
\)
</p>

<p>
The proof of the algorithm now follows by applying steps 3 and 4.
</p>



  <footer id="myFooter">

    <div class="w3-container w3-theme-l1">
      <h4>An Introduction to Distributed Algorithms by K. Mani Chandy,
      <br>
      Simon Ramo Professor, Emeritus, California Institute of Technology</h4>
    </div>
  </footer>


      


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
