  <!--------------------------------------------------------->
<h2 class="w3-text-teal">Proving Safety</h2>
This module reviews methods used to prove safety of sequential
programs. 

<p>
  We represent the states and state transitions of a system by a <a
  href="https://en.wikipedia.org/wiki/Directed_graph">directed
  graph</a> in which vertices represent states and edges represent
  transitions.

  A <i>computation</i> (also called <i>trajectory</i>) is a path
through the graph.
An empty path is also a computation.
In this module the following are equivalent:
vertex and state; edges and state transitions; trajectories,
computations and paths.

<!----------------------------------------------->
<h3 class="w3-text-teal">Stable Sets of Vertices</h3>
A set of states is stable exactly when every transition from a state in
the set is to a state in the set.
<p>
Because there are no transitions from inside a stable set to outside the
set, there are also no paths from states inside a stable set to
states outside the set.
There may, however, be paths from outside a stable set into the set.
</p>



<figure>
  <img src="StablePaths.jpg" alt="Fig1" style="width:50%">>
  <figcaption>Fig.1 - Paths from a stable set remain in the set</figcaption>
</figure>


  <h3 class="w3-text-teal">Safety Proof Obligation</h3>
  Let \(init\) be the set of initial states of the system.
  The system can start in any state in \(init\).
  We assume that \(init\) is not empty.

  <p>
  Let  \(safe\) be a set of states where we want to prove that all
  paths that start in states in \(init\) remain in
  \(safe\).
    Our safety proof obligation is to show that every state on every path
    from every state in \(init\) is in \(safe\).
</p>

<hr class="new2">
<h5 style="color:blue;">
We prove safety
by finding a stable vertex set \(I\) such that:
</p>

<p>
\(
init \subseteq I \subseteq safe \quad
\)
</h5>
<hr class="new2">

<figure>
  <img src="Invariant_Slide1.jpg" alt="Fig2" style="width:50%">>
  <figcaption>Fig.2 - Illustration of Invariant I</figcaption>
</figure>

<p>
Because \(I\) is stable, all paths from \(I\) remain within
\(I\).  Because \(init\) is a subset of \(I\), all paths from \(init\)
remain within \(I\). 
All paths from \(init\) remain within \(safe\) because \(I\)
is in \(safe\).

<h3  class="w3-text-teal">Invariant</h3>
An invariant set of states is a stable set that includes \(init\),
the initial set of states.

<!----------------------------------->
<h3  class="w3-text-teal">Definition in Terms of Predicates</h3>
The concepts defined in terms of sets of states extend to definitions in terms
of
<a href="../Predicates/Predicates.html">predicates</a> on states in
the obvious way:
The extension of a predicate \(P\) is the set of states for which the
predicate holds.
<p>
A predicate \(P\) is stable exactly when all transitions from
states in which \(P\) holds terminate in states in which \(P\) holds.
So, \(P\) is stable exactly when execution of all commands in states
in which \(P\) holds terminate in states in which \(P\) holds.
In the terms of Hoare triples, \(P\) is stable exactly when, for all
commands \(c\):
<bf>
\(
\{P\} \: c \: \{P\}
\)
<p>
We use the following method to prove that a predicate \(safe\) holds
for all states in all paths starting from \(init\): Find an invariant
\(I\) such that:
\(
[I \Rightarrow safe]
\)

<!----------------------------------->
<h3  class="w3-text-teal">Summary</h3>
This module reviews key concepts used to prove safety in this
course.