<!DOCTYPE html>
<html lang="en">
<title>Byzantine</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
</style>
<body>


<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()"><i class="fa fa-bars"></i></a>
    <a href="../index.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">About the Course</a>
    <a href="../table_of_contents.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">Table of Contents</a>
    <a href="../cross_reference.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Index</a>
  </div>
  </div>
 

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left" id="mySidebar">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="Close Menu">
    <i class="fa fa-remove"></i>
  </a>

  <!-------------------------->
  <h3 class="w3-bar-item"><b>An Introduction to Distributed
  Algorithms</h3>
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="Byzantine.html">Consensus with Byzantine Faults</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="ByzantineExample.html">Examples</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="ByzantineSelfTest.html">Self Test</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="PropertiesOfTimelinesExercises.html">Exercises</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="Byzantine.html">Explorations</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="../Byzantine/Byzantine.html">
  Next: Byzantine Consensus</a> 
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="../SelfStabilization/SelfStabilization.html">
  Previous: Self Stabilizing Systems
  </a>
  
</nav>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
  <div class="w3-row w3-padding-64">
  <div class="w3-twothird w3-container">

    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">Consensus with Byzantine Faults</h1>
    In this module we study algorithms by which a collection of agents
    reach a consensus among alternative values.
    <a href="../Paxos/Paxos.html">The Paxos algorithm</a> is
    an example of how agents reach consensus.
    <a
    href="https://en.wikipedia.org/wiki/Consensus_(computer_science)">
    Agents cannot reach consensus if message delays or agent
    operations are arbitrarily slow.</a>
    Next, we study a
    consensus algorithm in which agents are guaranteed to come to a
    consensus. The algorithm requires message delays and agent
    operations to complete in bounded time.

    <p>
    The
    algorithm operates in a sequence of steps called <i>rounds</i>.
    All messages sent in a round are delivered in the same round, and
    all agents execute actions in each round after receiving
    messages sent in that round. So, the Byzantine algorithm that we
    describe next is synchronous.

    <p>
    The Byzantine generals problem is an important problem with
    applications in various domains including that of maintaining a
    distributed ledger.
    

    We describe the problem by means of an apocryphal story of the
    fall of the Byzantine empire which is attributed, in part, to
    disloyal leaders. The choice of the name "Byzantine Generals"
    for a problem in computer science is
    curious and interesting, but not relevant to the algorithm.

    <p>
    A general has \(N\) army units each of which
    is led by a lieutenant general, herafter referred to merely as
    lieutenant. We refer to the general and the lieutenants,
    collectively, as agents. An agent may be either loyal or
    disloyal. 

    <h4 class="w3-text-teal">Byzantine Generals Problem: Specification</h4>
    The general gives a command which is either
    attack or retreat.
    <ol>
      <li><i>Validity</i>: Loyal lieutenants must obey a loyal general. If a loyal general
    gives the command to attack then all loyal lieutenants must
    attack. Likewise, if a loyal general
    gives the command to retreat then all loyal lieutenants must
    retreat.</li>
      <li><i>Consensus</i>: Loyal lieutenants come to a consensus: either all of them
    attack or all of them retreat.</li>
    </ol>
    The specification does not require that traitors be discovered.

    <p>
    The algorithm proceeds as follows. A loyal general gives the same
    command to all lieutenants. A disloyal general may give
    different commands to different lieutenants and may give no
    commands to some. Then the lieutenants communicate among
    themselves and reach a consensus after a specified number of
    rounds.

    <figure>
    <img src="Slide01.jpg" alt="Fig1" style="width:100%">
    <figcaption>Fig.1: Loyal and disloyal general behavior</figcaption>
    </figure>

    <p>
    A loyal lieutenant sends the same message to all
    lieutenants in a round. A traitor may send different messages to
    different lieutenants and may send no messages to some.
    A lieutenant who receives a message knows which lieutenant sent
    it.

    <p>
    If the only requirement is validity, and consensus isn't
    required, then the solution is trivial: all loyal lieutenants obey
    the general whether the general is loyal or disloyal. If the only
    requirement is consensus, and validity isn't required, then the
    solution is trivial: all loyal lieutenants agree on a predefined
    value, say retreat, regardless of the command issued by the
    general. The conjunction of both requirements, validity and
    consensus, makes the problem interesting.

    
    <h4 class="w3-text-teal">Oral and Written Messages</h4>
    We begin by looking at two versions of the problem. In the first
    version a lieutenant sends copies of messages to other
    lieutenants but cannot modify the copies. Also, a lieutenant
    cannot forge signatures. If a lieutenant \(B\) gets a copy of a message
    \(M\) signed by \(Y\), where the message is forwarded to \(B\) by
    \(X\), then \(B\) knows 
    that \(M\) was sent by \(Y\), even if \(X\) is a traitor.

    <p>
    In the
    second version, messages can be modified and signatures can be
    forged.
    If a lieutenant \(B\) gets a copy of a message
    \(M\) signed by \(Y\), where the message is forwarded to \(B\) by
    \(X\), then \(B\) does not know 
    that \(M\) was sent by \(Y\), because a traitor \(X\) may have
    modified the message and forged \(Y\)'s signature.

    <p>
    In the literature, the two versions are referred to as the 
    with <i>written</i> and <i>oral message</i> versions, respectively. This is
    because when lieutenants speak to each other, a lieutenant \(X\)
    can tell a lieutenant \(B\) that 
    another lieutenant \(C\)  told \(B\) that \(C\) is going to attack when
    \(C\) said no such thing. When they send written messages, the
    receiver of a message can detect modified messages and forged
    signatures. 

    <h2 class="w3-text-teal">Algorithm with Written Messages</h2>
    Next, let's look at an algorithm for the case where messages
cannot be modified and signatures cannot be forged. 

<p>
Let the number of disloyal agents be \(t\). The problem is trivial if
there are no loyal agents. Likewise the solution is obvious if
there is only one loyal agent because the requirement of consensus is
vaccuous; there is no other loyal agent with which to reach consensus.
So we now assume \(N \geq t + 2\).

<p  class="w3-text-teal">Initially</p>
Initially no messages have been sent and all lieutenants are
uncomitted: they have not committed to attack or to retreat.

<p class="w3-text-teal">Round \(t + 1 \geq j \geq 0\)</p>
If a lieutenant \(B\) who has not committed to attack on previous
rounds receives an
attack message signed by the general and \(j\) attack messages signed
by \(j\) distinct lieutenants other than \(B\) , then:
<ol>
  <li>\(B\) commits to attack at the end of the round regardless
  of messages that it may receive on subsequent rounds, and
  </li>
  <li>
  \(B\) broadcasts a copy of the attack message signed by the general and
  copies of
  the attack messages signed by \(j\) distinct lieutenants.
  In addition \(B\) broadcasts a copy of an attack message
  signed by \(B\) itself. Thus \(B\) broadcasts an attack message
  signed by the general and \(j+1\) attack messages signed by \(j+1\) distinct
  lieutenants.
  </li>
</ol>
The algorithm terminates at the end of round \(t+1\) where \(t\) is
the maximum number of disloyal agents.

    <figure>
    <img src="Slide02.jpg" alt="Fig2" style="width:100%">
    <figcaption>Fig.2: Example of a lieutenant committing to attack</figcaption>
</figure>

The figure illustrates a situation in which a loyal lieutenant C commits to
attack on round 2, if it hasn't already committed to attack by then.
The figure shows C
getting attack messages (red boxes) signed by the general and lieutenants A and B on
round 2. The general and lieutenants A and B may be disloyal or
loyal. 

<p>
 Because C is loyal it follows the algorithm, and C
commits to attack at the end of round 2 because C receives a signed attack
 message from the general and signed attack messages from two
 different lieutenants.
So, at the end of round 2, C broadcasts attack messages
signed by the general and (copies of) attack
messages signed by A and B and attack messages signed by C. All loyal
lieutenants commit to attack by the end round 3 because they receive
messages signed by the general and 3 different lieutenants (A, B, C).

<p>
The algorithm works because messages cannot be forged. Loyal
lieutenant C doesn't know whether the general and lieutenants A and B
are loyal. But C has proof that they send attack messages to C because
C got signed messages from them, and these messages couldn't have come
from anybody else. And C passes on that proof to other lieutenants
by copying and forwarding the messages that it received.

<p>
A loyal
lieutenant D receives messages from the general and A, B, and C on
round 3. Again, lieutenant D doesn't know whether the senders of the
messages that it received are loyal; but, it doesn't matter because D
has proof that they sent those messages. So, D commits to attack on
round 3.

<h3  class="w3-text-teal">Proof of Correctness</h3>
<h4  class="w3-text-teal">Proof: loyal lieutenants obey a loyal
general.</h4> 

<p>
If the general broadcasts attack
messages on round 0 then all loyal lieutenants commit to attack at the
end of round 0.
If the general never sends attack messages then lieutenants never
receive copies of attack messages signed by the general; so,
loyal lieutenants never commit to attack.
Therefore, when the general is loyal, consensus among loyal
lieutenants is reached by the end of round 0.


<h4  class="w3-text-teal">Proof: loyal lieutenants come to a consensus
even if the general is disloyal.</h4>
We will prove that:
<ol>
  <li>
  <i>Case 1</i>: if any loyal lieutenant commits to attack on any round \(j \leq t\)
  then all loyal lieutenants commit to attack by the end of round \(t +
  1\).
  </li>
  <li>
  <i>Case 2</i> if no loyal lieutenant commits to attack on
  any round \(j \leq t\) then no loyal lieutenant commits to
  attack by the end of round \(t + 1\).
  </li>
</ol>
Therefore, either (case 1) all loyal lieutenants commit to attack by
the end of round \(t + 1\) or (case 2) no loyal lieutenant 
commits to attack by the end of round \(t + 1\).  So, consensus is
reached by the end of round \(t + 1\).

<p  class="w3-text-teal">Case 1: When the consensus is to attack</p>
If any loyal lieutenant commits to attack on round \(j\) then it broadcasts an attack
message signed by the general and also broadcasts \(j + 1\) messages
signed by \(j + 1\) different lieutenants in
that round. So on round \(j + 1\) all loyal lieutenants, who have not
yet committed to attack, receive an
attack message signed by the general and \(j + 1\) messages
signed by \(j + 1\) different lieutenants; and so they too
commit to attack by round \(j + 1\). So
if any loyal lieutenant commits to attack on any round \(j\) then
all loyal lieutenants commit to attack by the end of round \(j +
1\). Therefore, if 
if any loyal lieutenant commits to attack on any round \(j \leq t\) then
all loyal lieutenants commit to attack by the end of round \(t +
1\). 

<p  class="w3-text-teal">Case 2: When the consensus is to retreat</p>
If no loyal lieutenant commits to attack on any round \(j \leq t\)
then no loyal lieutenant commits to attack on round \(t + 1\).  This
is because a loyal lieutenant commits to attack on round \(t + 1\)
only if it receives \(t + 1\) attack messages signed by \(t + 1\)
different lieutenants. On round \(t + 1\), a loyal lieutenant can
receive at most \(t\) attack messages signed by \(t\) different
lieutenants --- these are the \(t\) traitors --- because, by
assumption, loyal lieutenants sent no attack messages on the first
\(t\) rounds. Therefore, if no loyal lieutenant commits to attack on
any round \(j \leq t\) then a consensus to retreat is reached by the
end of round \(t + 1\).


<h1 class="w3-text-teal">Algorithm with Oral Messages</h1>
Next, let's look at an algorithm for the case where messages can be
modified and signatures can be forged. Later we will show that there
is no solution for the case where the number of loyal agents is at
most twice the number of disloyal agents. So we restrict attention to
systems with at least \(2.t + 1\) loyal agents. By contrast, in the
case where signatures and messages cannot be forged, the algorithm
works with any number of loyal agents.

<p>
We describe an algorithm, \(Byz(t)\) which solves the
Byzantine Generals problem when there are at most \(t\) disloyal agents and at
least \(3.t + 1\) total agents.  \(Byz(t)\) also solves the problem
where there are more than \(t\) disloyal agents provided that the
general is loyal. We illustrate the algorithm
with examples and then prove that the algorithm is correct.

<p>
Messages in the algorithm are either <i>attack</i> or <i>retreat</i>
messages. The absence of a 
message in a round is treated the same as way as receiving a
<i>retreat</i> message. We will ignore rounds, synchronization, and
message loss for
the remainder of this section and restrict attention to messages which
are received on every round where a message is either attack or retreat.

 
<p>
Let's call the lieutenants \(v_{j}\) for \(0 < j <
N\), and let's call the general \(v_{0}\).


<p class="w3-text-teal">\(Byz(0)\): Algorithm when all agents are loyal.</p>
All agents obey the general.

<p>The proof that the algorithm is correct, when all agents are loyal,
is obvious. 


<h3 class="w3-text-teal">\(Byz(k)\) when \(k > 0\)</h3>
At the termination of a \(Byz(k)\) algorithm with \(v_{0}\) as the general, each lieutenant \(v_{i}\)
will have computed a consensus value \(c_{0,i}\). We will prove that
these values satisfy the specification.
<ol>
  <li>
  <i>Validity</i>: If the general is loyal then for all loyal lieutenants \(v_{i}\):
  <p>
  \(
  c_{0,i} = m_{0}
  \)
  where \(m_{0}\) is the message broadcast by the general.
  </li>
  <li>
  <i>Consensus</i>: For all loyal lieutenants \(v_{i}, v_{j}\):
  <p>
  \(
  c_{0,i} = c_{0,j}
  \)
</ol>
  
  

<h4 class="w3-text-teal">Step 1. Initialize: General sends messages</h4>
The general sends a message to each of the \(N-1\)
lieutenants. Thereafter the general remains idle.

Let \(m_{0, j}\) be the message that the general, \(v_{0}\), sends to \(v_{j}\). A
loyal general broadcasts the same message \(m_{0}\) to all 
lieutenants, and so \(m_{0, j} = m_{0}\) for all loyal lieutenants
\(j\).
Therefore, if the general is loyal then \(m_{0, j} = m_{0, k}\) for
all loyal lieutenants \(j, k\).
A disloyal general may send different messages to different 
lieutenants.


<h4 class="w3-text-teal">Step 2. Recursion: Run \(N-1\) separate
\(Byz(k-1)\) algorithms</h4>

For each \(j\) where \(0 < j < N\) run a separate \(Byz(k-1)\)
algorithm, with lieutenant \(v_{j}\) playing the role of the general and each
of the other \(N-2\) lieutenants, \(v_{i}\), playing the role of
lieutenant where \(0 < i < N\) and \(i \neq j\).
When \(v_{j}\) plays the role of the general, \(v_{j}\) sends message
\(m_{0, j, k}\) to each of the other \(N-2\) lieutenants \(v_{k}\).
\(m_{0, j, k}\) is the message that \(v_{j}\) tells \(v_{k}\) that
\(v_{j}\) claims to have received from \(v_{0}\). If \(v_{j}\) is
loyal then \(m_{0, j, k} = m_{0, j}\).
If  \(v_{j}\) is disloyal then \(m_{0, j, k}\) can be any value.


<p>
Let \(c_{i, j}\) be the consensus value 
obtained by \(v_{j}\) when \(v_{i}\) plays the role of general and
\(v_{j}\) plays the role of lieutenant.
Each \(v_{j}\) plays the role of general once and plays the role of
lieutenant \(N-2\) times in these \(Byz(k-1)\) algorithms.
So, for each \(v_{j}\) there are \(N-2\) values \(c_{i, j}\), with \(i
\neq j\).

<p>
Define \(c_{j, j}\) as \(c_{j, j} = m_{0, j}\), i.e., \(c_{j, j}\) is
defined as the message that
\(v_{j}\) got from \(v_{0}\) in the \(Byz(k)\) algorithm.
With the inclusion of \(c_{j, j}\)
there are \(N-1\) values \(c_{i, j}\), with \(0 < i < N\).

<h4 class="w3-text-teal">Step 3. Aggregate results of \(N-1\) separate
consensus values</h4> 
Each agent \(v_{j}\), for \(0 < j < N\) sets its consensus value, \(c_{0,j}\),  for the algorithm,
\(Byz(k)\) with \(v_{0}\) as the general, to be the
majority of the \(N-1\) values \(c_{i, j}\) where \(0 < i < N\).
<p>
In the case of a tie, a default value is used. Let's assume that the
default is <i>retreat</i>.
So, for each \(v_{j}\), where \(0 < j < N\):

<p>
\(
c_{0,j} = \; \textrm{majority} \; \{c_{i, j} \:| \: 0 < i < N\}
\)

<h2  style="color:red;">Example: 2 disloyal and 5 loyal agents</h2>
We show what each loyal agent does for the case of 2 disloyal agents
and 5 loyal agents, \(t = 2, \: N = 7\). After that we will 
give examples of two specific cases: (1) the general, \(v_{0}\), and agent \(v_{1}\) are
disloyal, and (2) agents \(v_{5}\) and \(v_{6}\) are disloyal.

<p>
The algorithm, \(Byz(2)\) for the case where \(t = 2\) begins with the
general, \(v_{0}\),  sending message \(m_{0, j}\) to lieutenant \(v_{j}\) where \(1
\leq j \leq 6\).  A loyal general broadcasts the same message
\(m_{0}\) to all lieutenants in which case \(m_{0, j} = m_{0}\).  A
disloyal general may send any message to any lieutenant, and in this
case \(m_{0, j}\) is arbitrary. After sending
a message to each lieutenant, \(v_{0}\) takes no further action.

<h5 style="color:red;">Six separate \(Byz(1)\) algorithms: Broadcast step</h5>
Six separate \(Byz(1)\) algorithms are run. In each algorithm one of the six
lieutenants, \(v_{1}, \ldots, v_{6}\) plays the role of general and the other five act as
lieutenants. In the figure, the role of general is shown by a red
vertex and the role of lieutenant by blue. The figure shows the first
two steps of the algorithm: 
initialization and recursion.

<p>
Though we run a \(Byz(1)\) algorithm on the set \(v_{1}, \ldots,
v_{6}\) there may be more than 1 disloyal agent in the set. This
happens, for example, when
\(v_{0}\) is loyal and there are 2 disloyal agents, say \(v_{5}\) and
\(v_{6}\). 

<figure>
    <img src="Slide03.jpg" alt="Fig3" style="width:110%">
    <figcaption>Fig.3: Run six separate \(Byz(1)\) Algorithms</figcaption>
</figure>

 
Next, lets look at the \(Byz(1)\) algorithm where \(v_{1}\) plays the role of
general and \(v_{2}, \ldots , v_{6}\) act as lieutenants.
Agent \(v_{1}\) --- playing the role of general --- sends
message \(m_{0,1,j}\) to each \(v_{j}\) for \(j\) in \(2, \ldots , 6\).
Message \(m_{0,1,j}\) is the message that \(v_{1}\) tells \(v_{j}\)
that \(v_{1}\) claims to have
received from \(v_{0}\). If \(v_{1}\) is loyal then it broadcasts
the message \(m_{0,1}\) that it received from \(v_{0}\), and so \(m_{0,1,j} =
m_{0,1}\) for all \(j\). If \(v_{1}\) is disloyal then \(m_{0,1,j}\)
can be any value.

<p>
Similarly, in the \(Byz(1)\) algorithm where lieutenant \(v_{k}\) plays the role of
general, \(v_{k}\) sends \(m_{0,k,j}\) to \(v_{j}\) where \(j \neq
k\).

<figure>
    <img src="Slide04.jpg" alt="Fig4" style="width:100%">
    <figcaption>Fig.4: Run six separate \(Byz(1)\) Algorithms</figcaption>
</figure>


<h5 style="color:red;">Thirty separate \(Byz(0)\)
algorithms. Broadcast step</h5>
There are six separate \(Byz(1)\) algorithms with \(v_{k}\) as general
for \(k\) in \(1, \ldots, 6\). For each \(Byz(1)\) algorithm with
\(v_{k}\) as general there are 5 separate \(Byz(0)\) algorithms with
\(v_{j}\) as general where \(j \neq k\). This gives a total of 30
\(Byz(0)\) algorithms.

<p>
Let's look in detail at the \(Byz(1)\) algorithm with
\(v_{1}\) as general which calls the \(Byz(0)\) algorithm with
\(v_{2}\) as general and \(v_{3}, \ldots, v_{6}\) as lieutenants.
In this \(Byz(0)\) algorithm, \(v_{2}\) sends \(m_{0,1,2,j}\) to
\(v_{j}\); this is the message that \(v_{2}\) tells \(v_{j}\) is the
message that \(v_{2}\) claims to have received
from \(v_{1}\), which is the message that \(v_{1}\) claims to have received
from \(v_{0}\).
If \(v_{0}, v_{1}, v_{2}\) are all loyal then all of
them tell the truth and so:
\(m_{0,1,2,j} = m_{0,1,2} = m_{0,1} = m_{0}\).

<p>
Similarly, when the  the \(Byz(1)\) algorithm with
\(v_{i}\) as general calls the \(Byz(0)\) algorithm with \(v_{k}\) as
general, where \(i \neq k\), agent \(v_{k}\) sends \(m_{0,i,k,j}\) to
\(v_{j}\) where \(j \neq i\) and \(j \neq k\).
The figure below shows the five separate \(Byz(0)\) algorithms with
\(v_{k}\), \(2 \leq k \leq 6\), as general where the general is shown
as a red vertex.

<figure>
    <img src="Slide05.jpg" alt="Fig5" style="width:100%">
    <figcaption>Fig.5: Run five separate \(Byz(0)\) Algorithms</figcaption>
</figure>


<h5 style="color:red;">Thirty separate \(Byz(0)\)
algorithms. Consensus step</h5>
Let's look at the \(Byz(1)\) algorithm in which \(v_{1}\) is the
general which calls the \(Byz(0)\) algorithm in which \(v_{2}\) is the
general.
In this \(Byz(0)\) algorithm, the consensus \(c_{0,1,2,3}\) determined by 
lieutenant \(v_{3}\), if \(v_{3}\) is loyal, is \(m_{0,1,2,3}\).
This is because
in a \(Byz(0)\) algorithm the consensus determined by a loyal
lieutenant, \(v_{3}\), 
is the message \(m_{0,1,2,3}\) that lieutenant \(v_{3}\) received from
the general, \(v_{2}\).
<p>
We define \(c_{0,1,3,3}\) as \(m_{0,1,3}\). So we have 5 values of
\(c_{0,1,k,3}\) for \(k = 2, 3, 4, 5, 6\). 
<p>
Similarly, for distinct \(0, i, j, k\) and a loyal lieutenant
\(v_{k}\):
<p>
\(c_{0,i,j,k} = m_{0,i,j,k}\)
and
<p>
\(c_{0,i,k,k} = m_{0,i,k}\).


<h5 style="color:red;">Six separate \(Byz(1)\)
algorithms. Consensus step</h5>
In the \(Byz(1)\) algorithm where  \(v_{1}\) is the general and \(v_{2}, \ldots, v_{6}\) are
lieutenants, each of the five lieutenants \(v_{j}\) computes a consensus value
\(c_{0,1,j}\). 

Let's look at \(c_{0, 1, 2}\) when \(v_{2}\) is loyal

<p>
\(c_{0,1,2} = \textrm{majority} \: \{c_{0,1,2,2}, c_{0,1,3,2}, c_{0,1,4,2},
c_{0,1,5,2}, c_{0,1,6,2}\} \)



<p>
Similarly, for distinct \(i, j\), and loyal \(j\).
<p>
\(c_{0,i,j} = \textrm{majority} \: \{c_{0,i,k,j} | (k \notin \{0, i\} \} \)
<p>
Recall that \(c_{0,j,j}\) is defined as \(m_{0,j}\).


<p>
We can think of \(c_{0, i, j}\) as the consensus that a loyal agent \(v_{j}\)
computes for what \(v_{i}\) claims that \(v_{0}\) told \(v_{i}\). If
\(v_{j}\) is disloyal then \(c_{0, i, j}\) can be any value.

<h5 style="color:red;">Six separate \(Byz(1)\)
algorithms. Consensus step</h5>
In the \(Byz(2)\) algorithm where  \(v_{0}\) is the general and \(v_{1}, \ldots, v_{6}\) are
lieutenants, each of the six lieutenants \(v_{i}\) computes a consensus value
\(c_{0,i}\). For loyal \(v_{i}\):
<p>
\(c_{0,i} = \textrm{majority} \: \{c_{0,j,i} | j \neq 0 \} \)

<p>
For example, \(c_{0,1}\) is the majority of \(c_{0,1,1}, \ldots,
c_{0,6,1}\) where \(c_{0,j,1}\) is the consensus value that 
\(v_{1}\) computes for what \(v_{j}\) says \(v_{0}\) told
\(v_{j}\).

<p>
Next we will look at two examples that will give us the intuition that
will help us construct a proof of correctness.

<h3  style="color:red;">Example: Loyal generals and Two Disloyal
Lieutenants</h3>
Let's look at a case where \(v_{0}, \ldots, v_{4} \) are loyal while
\(v_{5}, v_{6}\) are disloyal. This example is chosen because it helps
us see that loyal lieutenants obey a loyal general.
<p>
A loyal agent \(v_{j}\), for \(1 \leq j \leq 4\), broadcasts the
message \(m_{0,j}\) that it receives from the general, \(v_{0}\). We
will show that the consensus value \(c_{0,j,k}\) determined by a loyal
agent \(v_{k}\) when \(v_{j}\) broadcasts \(m_{0,j}\) is \(m_{0,j}\).
Then we will see that the consensus value \(c_{0,j}\) determined by a loyal
agent \(v_{j}\) when \(v_{0}\) broadcasts \(m_{0}\) is \(m_{0}\).
The description that follows is detailed so that the steps of the
algorithm are clear.
<p>
The \(Byz(2)\) algorithm starts with
the general, \(v_{0}\), broadcasting \(m_{0}\) to \(v_{1}, \ldots,
v_{6} \). Next consider the \(Byz(1)\) algorithm where \(v_{1}\), broadcasts
\(m_{0,1}\) to \(v_{2}, \ldots, v_{6} \). And now consider the the
\(Byz(0)\) algorithm where \(v_{2}\), broadcasts 
\(m_{0,1,2}\) to \(v_{3}, \ldots, v_{6} \).

<p>
Loyal lieutenants \(v_{3}, v_{4}\) determine that the consensus for
this \(Byz(0)\) algorithm is \(m_{0,1,2,3}\) and \(m_{0,1,2,4}\)
respectively.This is because loyal lieutenants obey the general in a
\(Byz(0)\) algorithm.
<p>
\(
c_{0,1,2,3} = m_{0,1,2,3}\)
and 
\(
c_{0,1,2,4} = m_{0,1,2,4}
\)
and 
\(
c_{0,1,2,2} = m_{0,1,2}
\)
<p>
Because \(v_{2}\) is loyal it broadcasts the same message to all
lieutenants. Therefore
<p>
\(
m_{0,1,2,3} = m_{0,1,2,4} = m_{0,1,2}
\)
<p>
So we see that the consensus value \(c_{0,1,2,j}\), for loyal
\(v_{j}\) is the message \(m_{0,1,2}\) that the general \(v_{2}\)
broadcast in this \(Byz(0)\) algorithm. 
<p>
\(
c_{0,1,2,3} = c_{0,1,2,4} = c_{0,1,2,2} = m_{0,1,2}
\)
<p>
By the same argument, for loyal \(v_{j}, v_{k}\):
\(
c_{0,1,j,k} = m_{0,1,j}
\)

<p  style="color:red;">Aggregation Step</p>
Because \(v_{2}\) is loyal:
<p>
\(
c_{0,1,2} = \textrm{majority} \: \{c_{0,1,2,2}, c_{0,1,3,2},
c_{0,1,4,2}, c_{0,1,5,2}, c_{0,1,6,2}\} \)
<p>
\(
c_{0,1,2} = \textrm{majority} \: \{m_{0,1,2}, m_{0,1,3},
m_{0,1,4}, c_{0,1,5,2}, c_{0,1,6,2}\}\)
<p>
Because \(v_{1}\) is loyal, it broadcasts \(m_{0,1}\), and so:
<p>
\(
m_{0,1,2} = m_{0,1,3} = m_{0,1,4} = m_{0,1} \)
<p>
Therefore, 
<p>
\(
c_{0,1,2} = \textrm{majority} \: \{m_{0,1}, m_{0,1},
m_{0,1}, c_{0,1,5,2}, c_{0,1,6,2}\} = m_{0,1}\)
<p>
<p>
By the same argument, and because \(c_{0,1,1} = m_{0,1}\), we get:
<p>
\(
c_{0,1,1} = c_{0,1,2} = c_{0,1,3} = c_{0,1,4} = m_{0,1}
\)

<p>
So we see, once again, that the consensus value computed by each loyal
lieutenant is the message sent by the loyal general.


<p>
By the same argument, for \(1 \leq j,k \leq 4\):
\(c_{0,j,k} = m_{0,j} \) 
<p>
Next let's compute \(c_{0,1}\), the consensus value computed by
lieutenant \(v_{1}\) when \(v_{0}\) broadcasts \(m_{0}\).
<p>
\(
c_{0,1} = \textrm{majority} \: \{c_{0,1,1}, c_{0,2,1},
c_{0,3,1}, c_{0,4,1}, c_{0,5,1}, c_{0,6,1}\}
\)
<p>
Because \(c_{0,j,k} = m_{0,j} \) for \(1 \leq j,k \leq 4\):
<p>
\(
c_{0,1} = \textrm{majority} \: \{m_{0,1}, m_{0,2},
m_{0,3}, m_{0,4}, c_{0,5,1}, c_{0,6,1}\}
\)
<p>
Because \(v_{0}\) is loyal, \(m_{0,j} = m_{0}\) for \(1 \leq j,k \leq 4\):
<p>
and therefore 
\(
c_{0,1} = \textrm{majority} \: \{m_{0}, m_{0},
m_{0}, m_{0}, c_{0,5,1}, c_{0,6,1}\} = m_{0}
\)
<p>By the the same argument
<p>
\(
c_{0,1} =  c_{0,2} = c_{0,3} = c_{0,4} = m_{0}
\)
<p>
So we see, once again, that the consensus value computed by each loyal
lieutenant is the message sent by the loyal general.



<h3  style="color:red;">Example: Disloyal generals </h3>
Let's look at a case where \(v_{0}\) and \(v_{1}\) are disloyal while
\(v_{2}, \ldots, v_{6}\) are loyal.
This example is chosen because it helps us understand how loyal
lieutenants come to a consensus even when the general is disloyal.

<p>
The general, \(v_{0}\), sends message \(m_{0,1}\) to \(v_{1}\). Then
\(v_{1}\)  sends message \(m_{0,1,j}\) to \(v_{j}\), and because \(v_{1}\)
is disloyal, the message can have any value.
\(c_{0,1,i}\) is the consensus value that \(v_{i}\) determines in this
case. We will show that for loyal agents \(v_{i}, v_{j}\): \(c_{0,1,i}
= c_{0,1,j}\) even if \(m_{0,1,i}\) is different from \(m_{0,1,j}\).

<p>The \(Byz(2)\) algorithm starts with
the general, \(v_{0}\), sending message \(m_{0,j}\) to \(v_{j}\) for
\(j = 1, \ldots, 6\). Let's assume that \(v_{0}\) sends attack
messages to \(v_{2}\) and \(v_{3}\), and retreat 
messages to \(v_{4}\), \(v_{5}\) and \(v_{6}\). We will use 1 to
represent attack and 0 to represent retreat. In the diagram an attack
message is shown as a red edge while a retreat message is shown as a
green edge.
<p>
\(
m_{0,2} = m_{0,3} = 1
\)
<p>
\(
m_{0,4} = m_{0,5} = m_{0,6} = 0
\)

<p>
Let's look at the case in which disloyal agent \(v_{1}\) sends retreat
(0) to \(v_{2}\) and \(v_{3}\), 
while it sends attack (1) to \(v_{4}, v_{5}\) and \(v_{6}\). This is
shown in the top left diagram where edges from
\(v_{1}\) to \(v_{2}\) and \(v_{3}\) are green, while edges from
\(v_{1}\) to \(v_{4}, v_{5}\) and \(v_{6}\) are red.

<figure>
    <img src="Slide06.jpg" alt="Fig6" style="width:100%">
    <figcaption>Fig.6: Run six separate \(Byz(1)\) algorithms</figcaption>
</figure><p>

\(
m_{0,1,2} = m_{0,1,3} = 0
\)
<p>
\(
m_{0,1,4} = m_{0,1,5} = m_{0,1,6} = 1
\)
<p>
For the \(Byz(0)\) algorithms, because \(v_{2}, \ldots, v_{6}\) are
loyal, we get for \(2 \leq j,k \leq 6\) and \(j \neq k\):
<p>
\(
c_{0,2,j,k} = m_{0,2,j,k}  \quad j,k \neq 2
\)
<p>Because \(v_{j}\) is loyal: \(m_{0,2,j,k} = m_{0,2,j}\).
Because \(v_{2}\) is loyal: \(m_{0,2,j} = m_{0,2}\). Therefore:
<p>
\(
c_{0,2,j,k} = m_{0,2} = 1, \quad j,k \neq 2
\)
<p>
Similarly,
\(
c_{0,3,j,k} = m_{0,3,j,k} = 1, \quad j,k \neq 3
\)
<p>
Similarly, because \(v_{2}\) sends retreat messages to \(v_{4}, v_{5}, v_{6}\)
<p>
\(
c_{0,i,j,k} = m_{0,i,j,k} = m_{0,i,j} = m_{0,i} = 0, \quad j,k \neq
i, \; j,k = 4,5,6
\)
<p>
Agent \(v_{1}\) is disloyal; let's look at the messages that it
sends. Because \(v_{1}\) sends retreat messages to \(v_{2}\) and
\(v_{3}\), for \(j = 2, 3\):
<p>
\(
c_{0,1,j,k} = m_{0,1,j,k} = m_{0,1,j} = 0, \quad k \notin \{0,1,j\}
\)
<p>
Because \(v_{1}\) sends attack messages to \(v_{4}, v_{5}\) and
\(v_{6}\), for \(j = 4, 5, 6\):
<p>
\(
c_{0,1,j,k} = m_{0,1,j,k} = m_{0,1,j} = 1, \quad k \notin \{0,1,j\}
\)


<p  style="color:red;">Aggregation Step</p>
Because \(v_{2}\) is loyal:
<p>
\(
c_{0,1,2} = \textrm{majority} \: \{c_{0,1,2,2}, c_{0,1,3,2},
c_{0,1,4,2}, c_{0,1,5,2}, c_{0,1,6,2}\} \) 
<p>
and so:
<p>
\(
c_{0,1,2} = \textrm{majority} \: \{0, 0, 1, 1, 1\} = 1\) 
<p>
By the same argument,
\(c_{0,1,3} = 1 \)
<p>Because \(v_{4}\) is loyal:
<p>
\(
c_{0,1,4} = \textrm{majority} \: \{c_{0,1,2,4}, c_{0,1,3,4},
c_{0,1,4,4}, c_{0,1,5,4}, c_{0,1,6,4}\} \) 
<p>
and so:
<p>
\(
c_{0,1,4} = \textrm{majority} \: \{0, 0, 1, 1, 1\} = 1\) 
<p>
By the same argument,
\(c_{0,1,5} = c_{0,1,6} =  1 \)
<p>
<i>Therefore, all loyal agents, \(v_{2}, \ldots, v_{6}\) compute the
same consensus value: attack (1) for this \(Byz(1)\) algorithm.</i>

<p>
Similarly:
<p>
\(
c_{0,2,3} = \textrm{majority} \: \{c_{0,2,1,3}, c_{0,2,3,3},
c_{0,2,4,3}, c_{0,2,5,3}, c_{0,2,6,3}\} \) 
<p>
\(
c_{0,2,3} = \textrm{majority} \: \{c_{0,2,1,3}, 0,
0, 0, 0\} = 0 \) 
<p>
<i>By the same argument, for all loyal agents, \(j,k\) in \(v_{2}, \ldots,
v_{6}\):
\(
c_{0,j,k} = m_{0, j}
\)
.</i>

<p  style="color:red;">Aggregation Step</p>
<p>
\(
c_{0,2} = \textrm{majority} \: \{c_{0,1,2}, c_{0,2,2},
c_{0,3,2}, c_{0,4,2}, c_{0,5,2}, c_{0,6,2}\} \) 
<p>
\(
c_{0,2} = \textrm{majority} \: \{1, 0, 0, 1, 1, 1\} = 1 \)
<p>
By the same argument, \(c_{0,3} = 1\)
<p>
\(
c_{0,4} = \textrm{majority} \: \{c_{0,1,4}, c_{0,2,4},
c_{0,3,4}, c_{0,4,4}, c_{0,5,4}, c_{0,6,4}\} \) 
<p>
\(
c_{0,4} = \textrm{majority} \: \{1, 0, 0, 1, 1, 1\} = 1 \)
<p>
By the same argument, \(c_{0,5} = c_{0,6} = 1\)
<p>
<i>Therefore, all loyal agents, \(v_{2}, \ldots, v_{6}\) compute the
same consensus value: attack (1) for this \(Byz(2)\) algorithm.</i>


<h1>NEW</h1>
If \(t = 0\) - i.e. if the general and all lieutenants are loyal -
then the algorithm is straightforward: each lieutenant obeys the
general. So now let's consider the case where \(t > 0\).
<p>
Messages in the algorithm are pairs of the form \(m_{seq}, seq\) where
\(seq\) is a sequence of agent indices, starting with \(0\), and where
each index appears at most once in the sequence. If \(seq = (0, i_{1}, \ldots
i_{m})\) and agents \(0, i_{1}, \ldots i_{m}\) are loyal then
\(m_{seq}\) is the message that agent \(0\) sent to agent \(i_{1}\)
which forwarded the message to agent \(i_{2}\)... which forwarded the
message to agent \(i_{m}\).

<p>
A message \(m_{seq}, seq\) where \(seq = [0, i_{1}, \ldots i_{m-1},
i_{m}\]\) is a message sent by agent \(i_{m-1}\) to agent
\(i_{m}\). An agent other than agent \(i_{m-1}\) cannot send such a message.

<p>
If \(t > 0\) then the algorithm begins with the general, agent \(0\), sending message
\([m_{0,i},(0, i)]\) to agent \(i\), for \(0 < i < N\). If agent \(0\) is
loyal then \(m_{0,i} = m_{0,j}\) for all \(i, j\). If agent \(0\) is
disloyal then \(m_{0,i}\) is arbitary and so it is possible that
\(m_{0,i} \neq m_{0,j}\) for some \(i, j\).

<p>
If \(t > 1\) then
when an agent \(i\) gets message \([m_{0,i},(0, i)]\) it
sends message \([m_{0,i,j},(0, i, j)]\) to each agent
\(j\) where \(j \notin \{0,i,j\}\). If agent \(i\) is loyal then
\(m_{0,i,j} = m_{0,i}\), for all \(j\). If agent \(i\) is disloyal
then \(m_{0,i,j}\) is arbitrary.

<p>
If \(t > m\) then
when an agent \(i_{m}\) gets message
\([m_{0, i_{1}, \ldots, i_{m}}, (0, i_{1}, \ldots, i_{m})]\) 
\it sends message
\([m_{0, i_{1}, \ldots, i_{m}, j}, (0, i_{1}, \ldots, i_{m}, j)]\) to
each agent \(j\) where \(j \notin (0, i_{1}, \ldots, i_{m}).

<p>
The messages are shown in the following diagram for the case of at
most 2 disloyal agents and at least 5 loyal agents.
it
sends message \([m_{0,i,j},(0, i, j)]\) to each agent
\(j\) where \(j \notin \{0,i,j\}\). If agent \(i\) is loyal then
\(m_{0,i,j} = m_{0,i}\), for all \(j\). If agent \(i\) is disloyal
then \(m_{0,i,j}\) is arbitrary.

<figure>
    <img src="Slide08.jpg" alt="Fig8" style="width:100%">
    <figcaption>Fig.6: Messages Sent</figcaption>
</figure><p>



  <footer id="myFooter">

    <div class="w3-container w3-theme-l1">
      <h4>An Introduction to Distributed Algorithms by K. Mani Chandy,
      <br>
      Simon Ramo Professor, Emeritus, California Institute of Technology</h4>
    </div>
  </footer>


      


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>

