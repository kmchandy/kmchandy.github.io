<title>Paxos/ReadWriteLossyChannels.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

  
  <!--------------------------------------------------------->
  <h2 class="w3-text-teal">Shared Variables in Faulty Systems</h2>
  <!--------------------------------------------------------->
  
<p class="w3-text-teal">Shared Variables</p>
A distributed system has agents, called <i>clients</i> that send
  requests to agents, called <i>managers</i>, to read and
  write local variables of managers.

  Each manager <code>q</code> has a local variable <code>q.v</code>.

  A manager  <code>q</code> receives messages from clients to read or
  write <code>q.v</code>.

  When a manager <code>q</code> receives a read request from a client
  <code>p</code>, the manager sends a reply containing
  <code>q.v</code> to <code>p</code>.

  When <code>q</code> receives a write request, containing the value
  <code>w</code> to be written, <code>q</code> executes <code>q.v =
  w</code>. 

  The only actions of a manager are to respond to requests.

  <p>
  Associated with each client is a clock that sends the client
  a sequence of <i>clock tick</i> messages.
  
  The only actions of a client are to send requests to managers, receive
  replies from managers, and receive clock tick messages.

  <p>
  The interval between clock tick messages is irrelevant for the
  correctness of the algorithm; however, it plays a role in the algorithm's
  performance.



  <p class="w3-text-teal">Lossy Channels</p>
  In this page we design an algorithm for a system in which agents may
  halt and messages may be duplicated,
  lost, and delivered out of order.

  Requests by clients to managers, and replies from managers may be
  lost, and so a client may never receive a reply.

<p>
  Clients avoid waiting forever for a reply by taking the following
steps.

A client sends requests to
managers when the client receives a clock tick message.

A client only accepts replies that arrive before the client receives
its next clock tick.

  If the client receives the next clock tick before receiving a
reply from the manager then the client treats the request as lost.


  
  <p class="w3-text-teal">Transactions</p>
  A <i>transaction</i> is a sequence of operations on shared variables
by a single client.

We begin by considering a very simple type of transaction. 
General transactions are discussed in <a href="">worked-out examples.</a>

<p>
A transaction by a client <code>p</code> has two consecutive steps.
<ol>
  <li>
  <i><code>p</code> reads shared
  variables.</i> 
  <p>
  This step uses a constant <code>M</code> and is implemented as follows.
  When <code>p</code> receives a clock tick message it starts executing a
  new transaction by
  sending read requests to all managers of shared
  variables.
  If <code>p</code> receives replies from <code>M</code> or more
  managers before <code>p</code> receives its next clock tick message then <code>p</code>
  proceeds to step 2.
  If <code>p</code> receives the next clock tick message before it receives
  <code>M</code> replies then this transaction terminates without
  executing step 2.

  </li>
  <li>
  <i>
  <code>p</code> writes a subset of shared
  variables.</i> 
  <p>
  This step is implemented as follows.
  <code>p</code> sends write
  requests to managers of all shared variables.
  A subset
  <code>W</code> of them receive the requests and execute the write
  operation. <code>p</code> does not wait for replies to write requests.
  </li>
</ol>

<p>

  A transaction of a client <code>p</code> has a dataflow graph where
the vertices in the graph represent events at <code>p</code> and at managers.
The graph has edges that represent requests from <code>p</code> to
managers, and replies from managers to <code>p</code>.

<p>
The graph has an event representing the client getting a clock tick
that starts the transaction.

The diagram doesn't show events at the clock agent or clock tick
messages. 

  <p class="w3-text-teal">Serializable Executions</p>
A dataflow graph is <i>serializable</i> if it can be partitioned into
a sequence of subgraphs where each subgraph is the dataflow graph of a
single transaction.


<p>
There is a computation of a serializable dataflow in which all events of a
single transaction occur in sequence.

Each transaction is represented by the following steps.

  A single client <code>p</code> is selected to start a new
transaction. We discuss mechanisms for this selection later.
The selected client <code>p</code> carries out the following steps.

<ol>
  <li>
  <i>Read</i>:
  <code>p</code> sends read requests to all managers.
  <code>R</code> is the subset of managers of shared variables from
  which <code>p</code> receives replies to its read requests.
  For each <code>q</code> in <code>R</code>: <code>p</code>
  copies the shared variable, <code>q.v</code>, into 
  <code>p</code>'s local variable <code>p.copy[q]</code>.
  If <code>p.copy</code> has more than <code>M</code> elements then
  the client executes the next step.
  If <code>p.copy</code> has <code>M</code> or fewer elements then the
  transaction terminates without executing the next step.
  </li>
  <li>
  <code>p</code> requests each manager <code>q</code> to assign
  <code>p.f()</code> to <code>q.v</code> where <code>f()</code> is a
  function that depends on the transaction.
  The write requests are processed by a subset <code>W</code> of
  managers.
  </li>
</ol>

The sequence of transactions are represented by the following loop:
<pre>
p is an arbitrary client
R, W are arbitrary subsets of managers

p.copy = {}
for q in R: p.copy[q] = q.v
if len(p.copy) > M:
   for q in W: q.v = p.f()
</pre>

The problem is to design a distributed algorithm such that its
dataflow is serializable.


<!-------------------------------------------------->
<h3 class="w3-text-teal">How Should You Approach The Problem?</h3>
<!-------------------------------------------------->

What method comes to mind to partition a dataflow graph into dataflow
subgraphs? 

Logical time partitions dataflow into a past and future.

So we use a similar, but not identical, mechanism with transaction ids
playing the role of logical time.

<p>
Each transaction has a unique id called its <i>transaction id</i>.

The algorithm assigns a transaction id <code>t(e)</code> to each
event <code>e</code> and a transaction id <code>m.t</code> to each
message <code>m</code>, so that:
<ol>
  <li>
  All events and messages in a transaction have the id of the
  transaction, and
  </li>
  <li>
  events at an agent are in ascending order of transaction id,
  i.e. for events <code>e, e'</code> at an agent where <code>e'</code>
  occurs after <code>e</code>: <code>t(e)</code> \(\leq\)
  <code>t(e')</code>.
  </li>
</ol>

The dataflow graph can be partitioned into a sequence of subgraphs
where all events and messages in a subgraph have the same transaction
id.



<!-------------------------------------------------->
<h4 class="w3-text-teal">Algorithm for a Manager of Shared
Variables</h4>
<!-------------------------------------------------->

A manager <code>q</code> has two local variables:
<ol>
  <li>
  <code>q.t</code>,
called <code>q</code>'s transaction id,
which is the id of the transaction that the manager is currently
  processing.
  <code>q.t</code> is also the id of the most recent request that
  <code>q</code> has processed.
  </li>
  <li>
  <code>q.v</code> which is the value of the variable managed by
  <code>q</code>.
  </li>
</ol>

<p>
Initially <code>q.v</code> is a symbol <code>None</code> to indicate
that no value has been assigned, and <code>q.t</code> is <code>0</code>.

<p>
A manager receives two classes of messages: <code>ReadRequest</code> and
<code>WriteRequest</code>.
Every message, <code>m</code>, has a field, <code>m.t</code>, which is the
transaction id of the message.

A write request has a field, <code>v</code>, which is the value to be
written.

A manager replies to a read request with a message of class
<code>Reply</code> which has two fields: <code>v</code>, the value of
the shared variable, and <code>t</code>, the transaction id of the
message.

The algorithm is given below.

<pre>
# initialization
q.t, q.v = 0, None

start()
def receive(request, client):
   if request.t >= q.t
      q.t = request.t
      if isinstance(request, ReadRequest):
         send(Reply(q.v, q.t), client)
      else:
         // message is a WriteRequest
         q.v = request.v
</pre>

<p>
A manager ignores requests with transaction ids lower than its own
transaction id, i.e., a request is
ignored if <code>request.t < q.t</code>.

Such requests are treated as lost and don't appear in the dataflow.


<p>
If <code>request.t</code> \(=\) <code>q.t</code> then the manager
continues to process the transaction with id <code>q.t</code>.

<p>
If <code>request.t</code> \(>\) <code>q.t</code> then the manager
begins processing the transaction with id <code>request.t</code>, and
stops processing transactions with any earlier id.

The manager increases its transaction id to <code>request.t</code> to
indicate that it is now processing the transaction with it
<code>request.t</code>. 


<p>
<code>q</code> replies to a read request and sets the transaction id of the
reply to <code>q.t</code>.

<code>q</code> carries out a write operation when <code>q</code>
receives a write request.

<!-------------------------------------------------->
<h4 class="w3-text-teal">Algorithm for a Client </h4>
<!-------------------------------------------------->

<p>
A transaction id is a pair <code>(n, p)</code> where <code>n</code> is
a number and <code>p</code> is the client that carries out the transaction.

Transaction ids are compared lexicographically.

Later transactions initiated by a client have higher transaction ids
than earlier transactions initiated by the same client.


<p>
Each client <code>p</code> has a local variable <code>p.t</code> 
which is the id of the transaction that <code>p</code>
is processing.

A client <code>p</code> has a local variable <code>p.copy</code> which
contains copies of shared variables.
<code>p.copy</code> is a dictionary and <code>p.copy[q]</code> is
<code>p</code>'s copy of the shared variable of manager
<code>q</code>. 


<p class="w3-text-teal">Starting a New Transaction</p>
A client <code>p</code> starts executing a new transaction
and stops execution of previous transactions when it gets a
clock tick message.

A client starts a new transaction by executing the following steps:
<pre>
p.t = p.t + pos()
p.copy = {}
for q in Q: send(ReadRequest(p.t), q)
</pre>

<code>p</code> sets the id <code>p.t</code> of the new transaction to
  be a value greater than the 
  id of its previous transactions.
  <code>pos</code> is a function that returns a positive value.
  The value returned is not relevant to the
  correctness of the algorithm provided that it is positive.
The value is, however, relevant to performance.
We discuss performace later.
<p>
  <code>p</code> discards earlier copies of shared variables and sends
read requests to each manager <code>p</code>.
The transaction id of the
requests is <code>p.t</code>, the id of the new transaction.


<code>p</code> then waits to receive a clock tick 
message and simultaneously waits to receive
  replies to its read requests.


<p class="w3-text-teal">Processing a Reply to a Read Request</p>
A client <code>p</code> takes the following steps when it
receives a reply, <code>message</code>, from a manager,
<code>sender</code>, in the transaction that the client is  
processing.

<pre>
p.copy[sender] = message.v
if len(p.copy) > M:
   for q in Q:
      send(WriteRequest(v = p.f(), t=p.t), q)
</pre>

<code>p</code> copies the value in the reply from <code>sender</code> into <code>p</code>'s
local variable, <code>p.copy[sender]</code>.

If <code>p</code> has received replies from more than <code>M</code>
managers then <code>p</code> sends write requests to all managers.

The transaction id of the write requests is <code>p.t</code>.

The value to be written, specified in the write request is
<code>p.f()</code>, a function of <code>p</code>.

The function <code>p.f()</code> depends on the problem to be solved.

<h4 class="w3-text-teal">Proof of Correctness</h4>

We show that the dataflow graph of an execution of the system can be
partitioned into a sequence of subgraphs where each subgraph is the
dataflow of exactly one transaction.

<p>
The entire algorithm for a client <code>p</code> is given below.

<pre>
# Initialization
p.t = 0

start()
def receive(message, sender):
   if isinstance(message, ClockTick):
      p.t = p.t + pos()
      p.copy = {}
      for q in Q:  send(ReadRequest(p.t), q)
   else:
      # message is a reply to a read request
      if message.t == p.t: 
         p.copy[sender] = message.v
         if len(p.copy) > M:
            for q in Q:
               send(WriteRequest(v = p.f(), t=p.t), q)
</pre>

In the algorithm, <code>p.t</code> and <code>q.t</code> do not
decrease for all clients 
<code>p</code> and managers <code>q</code>. 

So, events at every agent occur in ascending order of transaction id,
i.e., for all events <code>e, e'</code> at an agent, if
<code>e'</code> occurs after <code>e</code> then <code>t(e)</code>
\(\leq\) <code>t(e')</code>.



<p>
From the algorithm, when a client executing  a transaction with id
<code>T</code> sends a request, the request is assigned the same
transaction id, <code>T</code>.

<p>
When a manager <code>q</code> accepts a request with transaction id
<code>T</code>, the manager sets its own transaction id to that of the request,
i.e., <code>q.t</code> becomes <code>T</code>.

A reply sent by a manager when the manager's transaction id is
<code>T</code> also has transaction id <code>T</code>.

A manager's reply, with transaction id <code>T</code>, is accepted by
the client if and only if the client's transaction id is also
<code>T</code>.  

Therefore, there exists a subgraph in which all events and messages
have the same transaction id.


<!----------------------------------------------->
<h5 class="w3-text-teal">Performance Issues</h5>
<!----------------------------------------------->

Each client is either executing a receive or is waiting to receive a
message.

Clients execute transactions concurrently; however, the algorithm
ensures that the dataflow represents a sequence of transaction
executions, one transaction at a time.


<p>
There may be computations with an infinite number of transactions in
which shared variables are never assigned values.

For example, requests may be lost, or there may fewer than
<code>M</code> replies to read requests.

<p>
Another scenario in which shared variables are never assigned values
is as follows.

Two transactions can collide with each other so that neither
transaction sends write requests.

For example, suppose clock ticks arrive every millisecond while
the time taken for a request to reach a manager is 5 milliseconds.

In this case, clients start new transactions every millisecond
and never receive replies to any transaction.

So, the interval selected for clock ticks depends on the delays of
requests and replies.

<p>
For more on performance issues, see <a href="">here</a>.


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>


</body>
</html>
