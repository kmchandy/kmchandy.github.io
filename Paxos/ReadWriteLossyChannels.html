<title>Paxos/ReadWriteLossyChannels.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

  
  <!--------------------------------------------------------->
  <h1 class="w3-text-teal">Serializable Computations in Faulty Systems</h1> 
  <!--------------------------------------------------------->

  <!--------------------------------------------------------->
  <h4 class="w3-text-teal">The System</h4>
  <!--------------------------------------------------------->
  
  A discussion about
  about serializability and transactions can be found
  <a
  href="https://en.wikipedia.org/wiki/Database_transaction">here.</a>

  In this webpage we describe a problem with a specific limited form
  of a transaction.
  
  
  We design an algorithm for a system in which agents may
  halt and messages may be duplicated,
  lost, and delivered out of order.

  <p>
  The system has agents, called <i>clients</i> that send
  requests to agents, called <i>servers</i>, to read and
  write local variables of servers.

  Each server <code>q</code> has a local variable <code>q.v</code>.

  A server  <code>q</code> receives messages from clients to read or
  write <code>q.v</code>.

  <p>
  When a server <code>q</code> receives a read request from a client
  <code>p</code>, the server sends a reply containing
  <code>q.v</code> to <code>p</code>.

  When <code>q</code> receives a write request, containing the value
  <code>w</code> to be written, <code>q</code> executes <code>q.v =
  w</code>.

  The only actions of a server are to respond to requests.

  <p>
  Associated with each client is a clock that sends the client
  a sequence of <i>clock tick</i> messages.
  
  The intervals between clock tick messages are irrelevant for the
  correctness of the algorithm but play a role in the algorithm's
  performance.
  
  <p>
  The only actions of a client are to send requests to servers, receive
  replies from servers, and receive clock tick messages.

  We can think of the collections of servers as implementing a set of
  variables shared by clients.


  <p>
  Requests by clients to servers, and replies from servers may be
  lost, and so a client may never receive a reply.

  Clients can avoid waiting forever for a reply by taking the following
  steps. 

When a client sends requests it also sends itself a timeout message, and
the client only accepts replies that arrive before the timeout.


  <!-------------------------------------------------------->
  <h4 class="w3-text-teal">Transactions</h4>

A transaction is carried out by a single client and consists of step
in which the client reads and then writes server values. 

The transaction uses a constant <code>M</code>.

Each client <code>p</code> has a local variable <code>p.copy</code>
which is a dictionary and where <code>p.copy[q]</code> contains a
(possibly stale) copy of <code>q.v</code>.

A transaction is as follows.

  <p class="w3-text-teal">Read</p>
  <code>p</code> sends read requests to all servers.
  Requests may be lost.
  Servers that receive requests send replies, but replies may be lost.
  
  Let <code>R</code> be the subset of servers from
  which <code>p</code> receives replies to its read requests.
  
  For each <code>q</code> in <code>R</code>: <code>p</code>
  copies the value, <code>q.v</code>, in the reply into 
  <code>p</code>'s local variable <code>p.copy[q]</code>.

  <p>
  If <code>p.copy</code> has more than <code>M</code> elements then
  the client executes the write step.
  
  If <code>p.copy</code> has <code>M</code> or fewer elements then the
   transaction terminates without executing the write step.


  <p class="w3-text-teal">Write</p>
  <code>p</code> requests each server <code>q</code> to assign
  <code>p.f()</code> to <code>q.v</code> where <code>f()</code> is a
given function.

Some requests may be lost.

Let <code>W</code> be the set of servers that receive and process
write requests.


<p class="w3-text-teal">The  Transaction</p>
A  transaction by a client <code>p</code> is as follows.

<pre>
select arbitrary subset R of servers
p.copy = {}
for q in R: p.copy[q] = q.v

if len(p.copy) >= M:
   select arbitrary subset W of servers
   for q in W: q.v = p.f()
</pre>



<h4 class="w3-text-teal">Serializable Computations</h4>
A computation \(X\) is serializable exactly when there exists a
computation \(Y\) where
<ol>
  <li>
  transactions are executed sequentially in \(Y\), and
  </li>
  <li>
  the timeline of each agent is identical in
  \(X\) and \(Y\).
  </li>
</ol>

If computation \(X\) is serializable then the timelines of agents in
\(X\) is the same as that of a sequential iteration:
<pre>
while True:
   select a client p
   p executes a transaction
</pre>
where <code>R, W</code> and <code>p</code> are selected appropriately
for each iteration.

<p>
(Agents have identical timelines in \(X\) and \(Y\) is equivalent to
\(X\) and \(Y\) are
<a href="../DISTRIBUTED_SYSTEM_MODELS/Model.html">
topological sorts of the same dataflow graph.
</a>.)


<!-------------------------------------------------->
<h2 class="w3-text-teal">The Problem</h2>
<!-------------------------------------------------->

The problem is to design a distributed algorithm that executes
transaction such that all computations are serializable. 

<!-------------------------------------------------->
<h5 class="w3-text-teal">How Should You Approach The Problem?</h5>
<!-------------------------------------------------->

What method comes to mind to partition a computation into sequences
where each sequence has some specified property.

Logical time partitions computations into steps in the past at
logical time \(t\) and steps in the future at logical time \(t\).

We use a mechanism, <i>epoch</i>, similar to logical time.


<!-------------------------------------------------->
<h3 class="w3-text-teal">Epochs and Logical Times</h3>
<!-------------------------------------------------->
<p>
Logical clocks assign a logical time \(t(e)\) to each step \(e\) such
that for all edges \((e, e')\) of the dataflow graph:
\(t(e) < t(e')\).

Later steps at an agent have higher logical times than earlier steps, and a message is
received in a step with a higher logical time than the step in which
the message is sent.

<p>
An <i>epoch</i> is a value \(t(e)\) assigned to
each step \(e\) such 
that for all edges \((e, e')\) of the dataflow graph:
\(t(e) \leq t(e')\).
Later steps at an agent have the same or higher epochs as earlier steps, and a message is
received in a step with the same or higher epoch as the step in which
the message is sent.


<p>
The only difference is that \(<\) of logical times is
replaced by \(\leq\) in epochs.

Epochs have some of the properties of logical time
including the following:

<h5 class="w3-text-teal">Observation</h5>
<i>There exists a computation in which steps are executed in
ascending order of epochs</i>.

<p>
The proof of this observation is the same as that for
<a href="../ChannelSnapshots/LogicalClocks.html">logical times:</a>
There exists a topological sort of a dataflow graph where vertices in
the sort occur in ascending order of epoch.


<p>
A consequence of this observation is that there is a computation
in which all steps with the same epoch, say \(T\), occur after all steps with
epochs less than \(T\), and before all steps with epochs greater than
\(T\).

The key idea of the algorithm is:

  <hr class="new2">
<p style="color:blue;">
A sufficient condition for computations to be serializable:

<p style="color:blue;">
Each transaction has a unique epoch, and all steps of a transaction
have the epoch of the transaction.
</p>
<hr class="new2">

Next, we describe an algorithm based on this sufficient condition.


<!-------------------------------------------------->
<h4 class="w3-text-teal">Algorithm for a Server</h4>
<!-------------------------------------------------->

A server <code>q</code> has two local variables:
<ol>
  <li>
  <code>q.t</code>,
called <code>q</code>'s epoch,
which is the epoch of the transaction that <code>q</code> is
  processing.
  </li>
  <li>
  <code>q.v</code> which is the value of the variable managed by
  <code>q</code>.
  </li>
</ol>

<p>
Initially <code>q.t</code> is <code>0</code> and
<code>q.v</code> is a common value <code>init</code>
for all <code>q</code>.

<p>
A server receives two classes of messages: <code>ReadRequest</code> and
<code>WriteRequest</code>.

Every message, <code>m</code>, has a field, <code>m.t</code>, which is
called the epoch of the message.

<code>m.t</code> is the epoch of the transaction in which
<code>m</code> is sent. 


<p>
A read request has a single field <code>t</code> which is the epoch of the
message.

A server replies to a read request with a message of class
<code>Reply</code> which has two fields: <code>v</code>, the value of
the shared variable, and <code>t</code>, the epoch of the
message.

A write request has two fields, <code>v</code>, which is the value to be
written, and <code>t</code>, the epoch of the message.


The algorithm is given below.

<pre>
# initialization
q.v, q.t = init, 0

start()
def receive(request, client):
   if request.t >= q.t
      q.t = request.t
      if isinstance(request, ReadRequest):
         send(Reply(q.v, q.t), client)
      else:
         // message is a WriteRequest
         q.v = request.v
</pre>


<!-------------------------------------------------->
<h5 class="w3-text-teal">Explanation of the Algorithm</h5>
<!-------------------------------------------------->
A server ignores requests from epochs earlier than the epoch
that the server is processing, i.e., a request is
ignored if <code>request.t < q.t</code>.

Ignored requests are treated as lost and don't appear in the
computation.

<p>
A server <code>q</code> is said to <i>accept</i> a request when
<code>request.t</code> \(\geq\) <code>q.t</code>.

The step in which <code>q</code> accepts a request with epoch
<code>T</code> is assigned epoch <code>T</code> because it is a step
in processing the transaction with epoch <code>T</code>.


<p>
If <code>request.t</code> \(=\) <code>q.t</code> then the server
continues processing the transaction in epoch <code>q.t</code>.

If <code>request.t</code> \(>\) <code>q.t</code> then the server
begins processing the transaction with epoch <code>request.t</code>, and
stops processing transactions from earlier epochs.

In this case, the server increases its transaction id to <code>request.t</code> to
indicate that it is now processing the transaction with epoch
<code>request.t</code>. 


<p>
A server <code>q</code> replies to each read request that it accepts and sets the
epoch of the reply to <code>q.t</code>.

When a server <code>q</code> accepts a write request, the server
assigns the value, <code>request.v</code>, in the request to the server's
variable <code>q.v</code>. 
.



<!-------------------------------------------------->
<h4 class="w3-text-teal">Algorithm for a Client </h4>
<!-------------------------------------------------->

<p>
An epoch is a pair <code>(n, p)</code> where <code>p</code> is
the client that carries out the transaction and where <code>n</code> is
and  <code>p</code> are
<a href="https://en.wikipedia.org/wiki/Total_order">total orders.</a>

Epochs are compared lexicographically.

Later transactions initiated by a client have higher epochs
than earlier transactions initiated by the same client.

So, each transaction has a unique epoch.

<p>
In the paragraphs below an epoch is treated as a value without explicitly writing an
epoch as a pair <code>(n, p)</code>.


<p>
Each client <code>p</code> has a local variable <code>p.t</code> 
which is the epoch of the transaction that <code>p</code>
is processing.

A client <code>p</code> has a local variable <code>p.copy</code> which
contains copies of shared variables.
<code>p.copy</code> is a dictionary and <code>p.copy[q]</code> is
<code>p</code>'s copy of the shared variable of server
<code>q</code>. 

<p>
The client's algorithm and explanation are given next.


<pre>
# Initialization
p.t = 0

start()
def receive(message, sender):
   if isinstance(message, ClockTick):
      # Start new transaction
      p.t = p.t + pos()
      p.copy = {}
      for q in Q:  send(ReadRequest(p.t), q)
   else:
      # message is a reply to a read request
      if message.t == p.t: 
         p.copy[sender] = message.v
         if len(p.copy) >= M:
            for q in Q:
               v, t = p.f(), p.t
               send(WriteRequest(v, t), q)
</pre>



<!-------------------------------------------------->
<h5 class="w3-text-teal">Explanation of the Algorithm</h5>
<!-------------------------------------------------->

<p class="w3-text-teal">Receive a Clock Tick Message</p>
A client <code>p</code> starts executing a new transaction
 when it gets a clock tick message.


A client <code>p</code> sets the epoch <code>p.t</code> of the new
  transaction that it starts processing to
be a value greater than the epoch of the transaction that it was
  processing previously.

The client stops processing transactions with earlier epochs.

<p>
  <code>pos</code> is a function that returns a positive value.
  The value returned is not relevant to the
correctness of the algorithm but does impact performance.

<p>
  A client <code>p</code> discards earlier copies of shared variables and sends
read requests to each server.

The epoch of the
requests is <code>p.t</code>, the epoch of the transaction that
  <code>p</code> has started processing.


Client <code>p</code> then waits to receive a clock tick 
message and waits concurrently for replies to its read requests.

<!---------------------------------------------->
<p class="w3-text-teal">Receive a Reply</p>
<!---------------------------------------------->

A client <code>p</code> accepts a <code>reply</code> if and only if
the reply is in the same epoch
as that of the transaction that <code>p</code> is processing.
i.e., <code>p.t</code> \(=\) <code>reply.t</code>.

Client <code>p</code> ignores replies from earlier transactions.

We will see that <code>p</code> doesn't receive replies from
transactions in later epochs, i.e. <code>p.t</code> \(\geq\)
<code>reply.t</code>. 


<p>
Client <code>p</code> takes the following steps when it
accepts <code>reply</code> from a server,
<code>q</code>.

The client copies the value in the reply from <code>q</code> into the client's
local variable, <code>p.copy[q]</code>.

If <code>p</code> has received replies from <code>M</code> or more 
servers then <code>p</code> sends write requests to all servers.

The epoch of the write requests is <code>p.t</code>, the epoch of the
transaction that <code>p</code> is processing.

The value to be written, specified in the write request is
<code>p.f()</code>, a given function.



<!--------------------------------------------------->
<h4 class="w3-text-teal">Proof of Correctness</h4>
<!--------------------------------------------------->
We will show that the algorithm satisfies the sufficient condition for
serializability: 
(1) each transaction has a unique epoch and
(2) all steps and messages of a transaction have the epoch of the
transaction. 

<p>
We have shown that each transaction has a unique epoch.
From the algorithm, all requests sent by clients, all requests accepted
by servers, all replies sent by servers, all replies accepted by
clients, and all steps in a transaction with epoch <code>T</code> have epoch
<code>T</code>.


<!----------------------------------------------->
<h3 class="w3-text-teal">Tagging Variables with Write Times</h3>
<!----------------------------------------------->
Next we describe an algorithm which keeps track of the epoch in which
each server's variable is last written.

To do so, the variable <code>q.v</code> of a server <code>q</code> has two
fields, <code>q.v.s</code> and <code>q.v.t</code> where
<code>q.v.s</code> is the state of <code>q.v</code> and
<code>q.v.t</code> is the epoch in which <code>q.v</code> was last
written.

We make the 
obvious change to the algorithm of client <code>p</code>: replace the
assignment
<code>v = p.f()</code>
by
<pre>
v.s, v.t = p.f(), p.t
</pre>
where <code>p.t</code> is the epoch in which the assignment is made.

Initially <code>q.v.s, q.v.t = init, 0</code>.


<!----------------------------------------------->
<h3 class="w3-text-teal">Sequential and
Distributed Algorithms with Identical Timelines</h3>
<!----------------------------------------------->

<p>
In each transaction a client sends read requests, receives replies
from some servers, and sends write requests only if the client
receives at least <code>M</code> replies.

Server variables are left unchanged in a transaction if the client
receives fewer than <code>M</code> replies.

So, such transactions have no impact on server timelines.

<p>
Server timelines in any computation \(X\) of the distributed algorithm are identical to
server timelines in the following sequential algorithm with
appropriate selections of <code>p, R, W</code>. (Initial conditions are
not shown.)


<pre>
while True:
   select a client p.
   select a subset R of M or more servers
   select a nonempty subset W 

   p.t = p.t + arbitrary positive value
   for q in W:
        q.v.s = p.f(q.v for q in R)
        q.v.t = p.t
</pre>

The list of replies that client
<code>q</code> receives in the iteration is <code>[q.v for q in
R]</code>. 


<p>


<p>
We will prove properties of server timelines in the sequential
algorithm for arbitrary, nondeterministic selections of <code>p, R, W</code> .
These properties hold for all computations of the distributed
algorithm.

Proving properties of the nondeterministic sequential algorithm is
easier than proving properties of the distributed algorithm
executing in a faulty environment.




<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>


</body>
</html>
