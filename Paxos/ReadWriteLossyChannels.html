<title>Paxos/ReadWriteLossyChannels.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

  
  <!--------------------------------------------------------->
  <h2 class="w3-text-teal">Shared Variables in Faulty Systems</h2>
  <!--------------------------------------------------------->
  
<p class="w3-text-teal">Shared Variables</p>
A distributed system has agents, called <i>clients</i> that read and
  write shared variables. 

Associated with each shared variable is an agent, called an
  <i>manager</i>,
  which gets requests from clients to read or write the manager's
  variable.
  A shared variable is <code>q.v</code>, where <code>q</code> is a
  manager. 
 The only actions of a manager <code>q</code> are to respond to
  requests to read or write <code>q.v</code>.
  A manager only receives messages from, and sends messages to,
  clients.
  Managers do not send messages to each other and do not send messages
  to themselves.

  <p class="w3-text-teal">Reading and Writing Shared Variables</p>
  A client <code>p</code> reads a shared variable <code>q.v</code>
  by sending a read request to <code>q</code> which sends a reply
  containing <code>q.v</code> to <code>p</code>.

  A client <code>p</code> assigns a value <code>v'</code> to a shared
  variable <code>q.v</code> by sending a write request containing <code>v'</code>
  to <code>q</code>.
  
  When <code>q</code> receives the request it is assigns <code>q.v =
  v'</code>, and sends reply to <code>p</code> stating
  that the operation has been carried out.

  <p>
  A client sends messages to, and receive messages from, managers.
  Clients do not send messages to themselves or to each other.
  Each client also receives timeout messages, at intervals, from a
  clock; the intervals between timeout messages are irrelevant for the
  correctness of the algorithm but play a role in the algorithm's
  performance. 

  <p class="w3-text-teal">Lossy Channels</p>
  In this page we design an algorithm for a system in which messages may be duplicated,
  lost, and delivered out of order, and in which agents may halt.

  Requests by clients to managers, and replies from managers may be lost, and so a client may never receive
  a reply.

<p>
  Clients avoid waiting forever for a reply by taking the following
steps.

A client sends requests to
managers when the client receives a timeout message.

A client only accepts replies that arrive before the client receives
its next timeout.

  If the client receives the next timeout before receiving a
reply from the manager then the client treats the request as lost, and
if the reply arrives later then the reply is ignored and is also
treated as lost.


  
  <p class="w3-text-teal">Transactions</p>
  A <i>transaction</i> is a sequence of operations on shared variables
by a client.

We begin by considering a very simple type of transaction. 
General transactions are discussed in <a href="">worked-out examples.</a>

<p>
A transaction by a client <code>p</code> has two consecutive steps.
<ol>
  <li>
  <i><code>p</code> reads shared
  variables.</i> 
  <p>
  This step uses a constant <code>M</code> and is implemented as follows.
  When <code>p</code> receives a timeout message it starts executing a
  new transaction by
  sending read requests to all managers of shared
  variables.
  If <code>p</code> receives replies from <code>M</code> or more
  managers before <code>p</code> receives its next timeout message then <code>p</code>
  proceeds to step 2.
  If <code>p</code> receives the next timeout message before it receives
  <code>M</code> replies then this transaction terminates without
  executing step 2.

  </li>
  <li>
  <i>
  <code>p</code> writes a subset of shared
  variables.</i> 
  <p>
  This step is implemented as follows.
  <code>p</code> sends write
  requests to managers of all shared variables.
  A subset
  <code>W</code> of them receive the requests and execute the write
  operation. <code>p</code> does not wait for replies to write requests.
  </li>
</ol>

<p>

  A transaction of a client <code>p</code> has a dataflow graph where
the events are at <code>p</code> or at managers.
The graph has edges that represent requests from <code>p</code> to
managers, and replies from managers to <code>p</code>, in the
transaction. 

  <p class="w3-text-teal">Serializable Executions</p>
A dataflow graph is <i>serializable</i> if it can be partitioned into
a sequence of subgraphs where each subgraph is the dataflow graph of a
single transaction.

If the dataflow is serializable then it represents execution of a
sequence of transactions where at most one transaction is in execution
at a time.
The execution selects a single client <code>p</code> in a
nondeterministic manner which is described later.
<p>
The steps of the transaction executed by <code>p</code> are as
follows.
<ol>
  <li>
  <code>p</code> sends read requests to all managers.
  <code>R</code> is the subset of managers of shared variables from
  which <code>p</code> receives replies to its read requests.
  For each <code>q</code> in <code>R</code>: <code>p</code>
  copies the shared variable, <code>q.v</code>, into 
  <code>p</code>'s local variable <code>p.copy[q]</code>.
  </li>
  <li>
  <code>p</code> requests each manager <code>q</code> to assign
  <code>p.f()</code> to <code>q.v</code> where <code>f()</code> is a
  function that depends on the transaction.
  The write requests are processed by a subset <code>W</code> of
  managers.

  <p>
  The structure of the sequence of transactions is represented by the
  following loop.
<pre>
while true:
  select a client p and subsets R, W of managers
  for q in R: p.copy[q] = q.v
  if len(R) > M: for q in W: q.v = p.f()
</pre>

The problem is to design a distributed algorithm such that its
dataflow is serializable.


<!-------------------------------------------------->
<h3 class="w3-text-teal">How Should You Approach The Problem?</h3>
<!-------------------------------------------------->

What method comes to mind to partition a dataflow graph into dataflow
subgraphs? 

Logical time partitions dataflow into a past and future.

So we use a similar, but not identical, mechanism with transaction ids
playing the role of logical time.

<p>
Each transaction has a unique id called its <i>transaction id</i>.

The algorithm assigns a transaction id <code>t(e)</code> to each
event <code>e</code> and a transaction id <code>m.t</code> to each
message <code>m</code>, so that:
<ol>
  <li>
  All events and messages in a transaction have the id of the
  transaction, and
  </li>
  <li>
  events at an agent are in ascending order of transaction id,
  i.e. for events <code>e, e'</code> at an agent where <code>e'</code>
  occurs after <code>e</code>: <code>t(e)</code> \(\leq\)
  <code>t(e')</code>.
  </li>
</ol>

The dataflow graph can be partitioned into a sequence of subgraphs where all events
in a subgraph have the same transaction id, and later subgraphs
have larger transaction ids.




<!-------------------------------------------------->
<h4 class="w3-text-teal">Algorithm for a Manager of Shared
Variables</h4>
<!-------------------------------------------------->

A manager <code>q</code> has two local variables:
<ol>
  <li>
  <code>q.t</code>,
called <code>q</code>'s transaction id,
which is the id of the transaction that the manager is currently
  processing.
  <code>q.t</code> is also the id of the most recent request that
  <code>q</code> has processed.
  </li>
  <li>
  <code>q.v</code> which is the value of the variable managed by
  <code>q</code>.
  </li>
</ol>

<p>
Initially <code>q.v</code> is a symbol <code>None</code> to indicate
that no value has been assigned, and <code>q.t</code> is <code>0</code>.

<p>
A manager gets two classes of messages: <code>ReadRequest</code> and
<code>WriteRequest</code>.
Every message <code>m</code> has a field <code>m.t</code> which is the
transaction id of the message.
A write request has a field <code>v</code> which is the value to be written.
A manager replies to a read request with a message of class
<code>Reply</code> which has two fields: <code>v</code> the value of
the shared variable and <code>t</code> the transaction id of the message.
The algorithm is given below.

<pre>
# initialization
q.t, q.v = 0, None

start()
def receive(request, client):
   if request.t >= q.t
      q.t = request.t
      if isinstance(request, ReadRequest):
         send(Reply(q.v, q.t), client)
      else:
         // message is a WriteRequest
         q.v = request.v
</pre>

<p>
A manager ignores requests with transaction ids lower than its own
transaction id: a request is
ignored if <code>request.t < q.t</code>.

Such requests are treated as lost and don't appear in the dataflow.


<p>
If <code>request.t</code> \(=\) <code>q.t</code> then the manager
continues to process the transaction with id <code>q.t</code>.

<p>
If <code>request.t</code> \(>\) <code>q.t</code> then the manager
begins processing the transaction with id <code>request.t</code>, and
stops processing transactions with any other id.

The manager increases its transaction id to <code>request.t</code> to
indicate that it is now processing the transaction with it
<code>request.t</code>. 


<p>
<code>q</code> replies to a read request and sets the transaction id of the
reply to <code>q.t</code> which is also the transaction id of the
event which is the same as the transaction id of the request.

<!-------------------------------------------------->
<h4 class="w3-text-teal">Algorithm for a Client </h4>
<!-------------------------------------------------->

<p>

A transaction id is a pair <code>(n, p)</code> where <code>n</code> is
an integer and the transaction is by client <code>p</code>.

Transaction ids are compared lexicographically.

Later transactions initiated by a client have higher transaction ids
than earlier transactions initiated by the same client.


<p>
Each client <code>p</code> has a local variable <code>p.t</code> 
which is the id of the transaction that <code>p</code>
is processing.

A client <code>p</code> has a local variable <code>p.copy</code> which
contains copies of shared variables.
<code>p.copy</code> is a dictionary and <code>p.copy[q]</code> is
<code>p</code>'s copy of the shared variable of manager
<code>q</code>. 


<p class="w3-text-teal">Starting a New Transaction</p>
A client <code>p</code> starts executing a new transaction
and terminates execution of previous transactions when it gets a
timeout message.

A client starts a new transaction by executing the following steps:
<pre>
p.t = p.t + pos()
p.copy = {}
for q in Q: send(ReadRequest(p.t), q)
</pre>

<code>p</code> sets the id <code>p.t</code> of the new transaction to be a value greater than the
  id of its previous transactions.
  <code>pos</code> is a function that returns a positive value.
  The value returned is not relevant to the
  correctness of the algorithm provided that it is positive.
The value is, however, relevant to performance.
We discuss performace later.
<p>
  <code>p</code> discards earlier copies of shared variables and sends
read requests to each manager <code>p</code>.
The transaction id of the
requests is <code>p.t</code>, the id of the new transaction.


<code>p</code> then waits to receive a timeout 
message and simultaneously waits to receive
  replies to its read requests.


<p class="w3-text-teal">Processing a Reply to a Read Request</p>
A client <code>p</code> takes the following steps if it
receives a reply in the transaction that the client is currently
processing,
i.e., where the client and reply have the same transaction id.
The steps shown below are when the client receives a reply.
<code>message</code>, from a manager, <code>sender</code>.
<pre>
p.copy[sender] = message.v
if len(p.copy) > M:
   for q in Q:
      send(WriteRequest(v = p.f(), t=p.t), q)
</pre>

<code>p</code> copies the value in the reply from <code>sender</code> into <code>p</code>'s
local variable, <code>p.copy[sender]</code>.

If <code>p</code> has received replies from more than <code>M</code>
managers then <code>p</code> sends write requests to all managers.

The transaction id of the write requests is <code>p.t</code>, the id
of the transaction that <code>p</code> is processing.

The value to be written, specified in the write request is
<code>p.f()</code>, a function of <code>p</code>.

The function <code>p.f()</code> depends on the problem to be solved.

<p class="w3-text-teal">Proof of Correctness</p>

The entire algorithm for a client <code>p</code> is given below.

<pre>
# Initialization
p.t = 0

start()
def receive(message, sender):
   if isinstance(message, Timeout):
      p.t = p.t + pos()
      p.copy = {}
      for q in Q:  send(ReadRequest(p.t), q)
   else:
      # message is a reply to a read request
      if message.t == p.t: 
         p.copy[sender] = message.v
         if len(p.copy) > M:
            for q in Q:
               send(WriteRequest(v = p.f(), t=p.t), q)
</pre>

In the algorithm, <code>p.t</code> and <code>q.t</code> do not decrease for all clients
<code>p</code> and managers <code>q</code>. 

So, all events with a transaction id <code>T</code> at an agent occur
after all events with transaction id less than  <code>T</code> at that
agent, and before  all events with transaction id greater than
<code>T</code> at that agent.


<p>
From the algorithm, 
all requests sent be a client in a transaction with id <code>T</code>
are received by  a manager <code>q</code>  executing the transaction with the same id:
<code>request.t</code> \(=\) <code>q.t</code>,
and all replies sent by a manager executing a transaction  with id
<code>T</code> are received by the client <code>p</code> when it is
executing the same transaction:
<code>message.t</code> \(=\) <code>p.t</code>.
Therefore, there exists a subgraph in which all events and messages
have the same transaction id.


    <!--------------------------------------------------------->
  <h2 class="w3-text-teal">The Problem</h2>
  <!--------------------------------------------------------->
In each iteration of the sequential algorithm, given above, exactly
  one writer reads and then writes all shared variables.

We will implement the following variant of the sequential algorithm
on a faulty distributed system.

We call the variant <i>Seq</i>.

<p>
<i>Seq</i> initializes variables and then executes a loop.

A single writer <code>p</code> is selected nondeterministically in each
iteration.

The selected writer <code>p</code>
reads and then writes subsets of shared variables.

No writer, other than <code>p</code>,
accesses shared variables in this iteration.

<p>
The writer <code>p</code>, selected on an iteration, determines a
value <code>p.t</code>, called the <i>iteration id.</i>

Later we give rules that ensure that the id of each iteration is unique.


<p>
The manager <code>q</code> of a shared variable has a field
<code>q.var</code> where <code>q.var</code> is a tuple <code>(v,
t)</code> where
<code>v</code> is the value of the shared variable and 
<code>t</code> is the id of the most recent iteration in which
<code>v</code> was assigned a value.

<p>
Each writer <code>p</code> has a local variable <code>p.copy</code>, a
dictionary, where <code>p.copy[q]</code> contains a (possibly stale)
copy of <code>q.var</code>.

Each writer <code>p</code> also has a local variable <code>p.t</code>
which is the id of the most recent iteration in which <code>p</code>
was selected as the writer that accesses shared variables.

<p>
We describe the steps of the sequential program later.



<!---------------------------------------------------->
<h4 class="w3-text-teal">Sequential Program Seq</h4>
<!---------------------------------------------------->
    <pre>
for p in P: p.t = 0
for q in Q: q.var = (None, 0)

while True:
   select a writer p
   p.t = p.t + pos()

   p.copy = {}
   for q in read_set: p.copy[q] = q.var

   if g(p):
      for q in write_set: q.var = (f(p, q), p.t)
</pre>

<code>None</code> is a value that indicates unassigned.

<code>pos</code> is a function that returns a positive value.

The value returned by <code>pos</code> impacts the performance, but not
the correctness of the algorithm.


<p>
<code>read_set</code> and <code>write_set</code> are subsets of
managers of shared variables.

These subsets are selected nondeterministically.


<p>
The iteration id determined by a selected writer <code>p</code> is a
pair <code>(n,p.id)</code> where 
<code>n</code> is a number, and 
<code>p.id</code> is the id of <code>p</code>.

So, different writers cannot determine the same iteration id.

When <code>p</code> starts an iteration it increases <code>p.t</code>.

So, different iterations in which <code>p</code> is the selected
writer have different ids.

<p>
(We don't include <code>p.id</code> explicitly in the algorithm
description so that we can focus on more important aspects.)


<p>
<code>p</code> reads shared variables in <code>read_set</code>, and
<code>p</code> writes shared variables in <code>write_set</code> only 
if condition <code>g(p)</code> holds.

For example, an algorithm may write shared variables only if 
<code>read_set</code> is not empty.

<p>
In the statement that writes shared variables, <code>f(p,q)</code> is
assigned to the value field, 
and <code>p.t</code> is assigned to the iteration id field of
<code>q.var</code>.

<p>
The nondeterministic statements of Seq 
are the statements that select <code>p</code>,
<code>read_set</code> and <code>write_set</code> in each iteration;
different selections of these variables result in different executions
of Seq.
An instance of Seq is a deterministic algorithm with a given selection of these
variables.


<!-------------------------------------------------->
<h3 class="w3-text-teal">Problem Specification</h3>
<!-------------------------------------------------->

Design a distributed algorithm in which agents are writers, managers of shared
variables and observers, and in which an observer receives
a message <code>m</code> 
from a manager <code>q</code> of a shared variable only if
<code>q.var = m</code> at some point in the execution of an instance
of Seq.


<p>
Observers cannot distinguish between messages that they receive in the
distributed algorithm and values of shared variables in Seq.

<p>
In the observer pattern, agents sends descriptions of events to
observers which construct the dataflow of a computation.

In our algorithm, copies of shared variables are sent to observers.
x
Messages may, however, be lost, duplicated and delivered out of order.

What can we deduce from the messages that observers receive?

<p>
If an observer receives <code>(v, t)</code> and <code>(v', t)</code>
from <code>q</code> and <code>q'</code>, respectively, 
then we know that <code>q.var</code> and <code>q'.var</code> were
assigned values <code>(v, t)</code> and <code>(v', t)</code>,
respectively, in the same iteration -- the iteration with unique id
<code>t</code>. 


<!-------------------------------------------------->
<h3 class="w3-text-teal">Performance Issues</h3>
<!-------------------------------------------------->





<p>
The events in the dataflow of an iteration are as follows.

<ol>
  <li>
  A single writer <code>p</code> is selected.
  </li>
  <li>
  The epoch time <code>p.t</code> is increased and the resulting epoch
  time uniquely identifies the iteration -- no other iteration has the
  same epoch time.
  </li>
  <li>
  <code>p</code> sends read requests to shared variables.
  </li>
  <li>
  A read request may get lost, or the manager may ignore the request,
  or the manager may send a reply.
  </li>
  <li>
  A reply may get lost, or <code>p</code> may ignore the reply, or
  <code>p</code> may copy the reply into a local variable and send
  write requests if <code>g(p)</code> holds.
  </li>
  <li>
  A write request may get lost, or a manger may ignore the request, or
  the manager may assign the value specified in the request to the
  shared variable.
  </li>
</ol>


<p>
Ignoring a message has the same effect as losing the message -- the
message is removed from the channel without changing agent states.

<p>
<code>read_set</code> is the set of managers that send replies that
<code>p</code> copies in step 5.
<code>write_set</code> is the set of managers that assign
values to shared variables specified in write requests in step 6.



<p>
<i>The Problem</i>:

Determine how to select a single writer <code>p</code> for each
iteration and which requests and replies to ignore and which to process so that:
<hr class="new2">
  <p style="color:blue;">
Values assigned to shared variables in the distributed
and sequential algorithms are identical.
</p>
<hr class="new2">




<h5 class="w3-text-teal">Message Types</h5>
<ol>
  <li>
  A read request is an instance of a class <code>ReadRequest</code>
  and has a single field <code>t</code> which is the epoch  time of
  the request.
  </li>
  <li>
  A reply is an instance of a class <code>Reply</code> and has fields
  <code>var</code> and <code>t</code> which are a copy of the shared
  variable and the epoch time of the reply, respectively.
  </li>
  <li>
  A write request is an instance of a class <code>WriteRequest</code>
  and has fields <code>var</code> and <code>t</code> which
  are the value to be written into the shared variable and the epoch
  time of the request, respectively. 
  </li>
</ol>



<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>


</body>
</html>
