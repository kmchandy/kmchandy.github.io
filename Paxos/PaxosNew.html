<title>Paxos/Paxos.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">The Paxos Algorithm</h1>
    
<a href="../ConsensusImpossible/ConsensusImpossible.html"> From the
FLP theorem</a>, there is no algorithm that guarantees that consensus among
distributed agents will be reached if messages are delayed for
arbitrary time. Next we describe an algorithm,
<a
    href="https://en.wikipedia.org/wiki/Paxos_(computer_science)">
  <i>Paxos</i></a>, proposed by Lamport that deals with consensus.

  <p>
The description here uses different names for variables than Lamport's
  paper. Also, the proof given here is based on timelines and may
  appear different from the proof given in the original paper though
  the ideas are the same.

   
<p>
The Paxos algorithm deals with messages that may be lost and that may
overtake each other. Agents  may stop and restart later,
  and agents  may be arbitrarily slow.
   Messages are not modified while in transit and that agents
do not have <a href="../Byzantine/Byzantine.html">Byzantine
  faults.</a>
  
<h3 class="w3-text-teal">Specification</h3>

<p>
The algorithm has agents called
<i>proposers</i> and others called <i>learners</i>. Proposers propose
  values and learners come to a consensus among
    the proposed values.

    <p>
Associated with each learner \(L\) is a local variable \(L.value\)
which is initially \(null\). Associated with each proposer \(P\) is a
local constant \(P.VALUE\) which is the value that the
proposer is proposing. The following invariants hold:
<p>
<ol>
  <li>
  Learners learn only proposed values.
  <p>
  \(\forall L: \quad
  (L.value = null) \; \vee \;
  (\exists \; \textrm{proposer} \: P : L.value = P.VALUE)
  \)
  </li>
  
  <li>
  A learner doesn't change a non-null value that it learns.
  <p>
  \(
  \forall L, V \neq null: \quad stable (L.value = V)
  \)
  </li>
  <li>
  All learners learn the same value.
  <p>
  \(
  \forall L, L': \quad
  (L.value = null) \vee (L'.value = null) \vee 
  ( L.value = L'.value)
  \)
  </li>
</ol>
The specification allows for the possibility that
consensus may never be reached --- \(L.value\) may remain
\(null\) forever for all \(L\).


<h3 class="w3-text-teal">The Algorithm</h3>
The algorithm has an additional
layer of agents called <i>acceptors</i> in addition to proposers and
learners. The communication structure 
between agents is shown in the figure below. Proposers send and
receive messages from acceptors.

Learners receive messages from
acceptors, and do not send messages to proposers or
acceptors. We postpone discussion of learners, and begin by focusing
on interactions between proposers and acceptors.

<p>
<figure>
    <img src="./PaxosLecture/PaxosLecture.002.jpeg" alt="Fig1" style="width:80%">
    <figcaption>Fig.1: Proposers, Acceptors and Learners</figcaption>
</figure>

<p class="w3-text-teal">Local Variables</p>
In the description of the algorithm; a
<i>time</i> is a pair
  <code>(n, pid)</code>, where <code>pid</code>
    is the id
  of a proposer, and <code>n</code> and <code>pid</code> are integers
(or any total order).
A <i>value</i> is either <code>null</code> or
<code>P.VALUE</code> where <code>P</code> is a proposer.


We use symbols <code>P</code>, <code>A</code>,
<code>t</code> and <code>v</code> for proposer, acceptor, time and
value.

<p>
A proposer <code>P</code> has the following
local variables.
<ul>
<li>
  <code>P.t = [P.n, P.ID]</code> where <code>P.ID</code> is
  <code>P</code>'s id, and <code>P.n</code> is an integer.
Initially, <code>P.n = 0</code>.
</li>
<li>
<code>P.V</code> is a constant and is <code>P</code>'s value.
</li>
</ul>

<p>
An acceptor <code>A</code> has the following
local variables.
<ul>
  <li>
  <code>A.t</code>: The time at <code>A</code>. Initially <code>A.t =
  [0, null]</code>. 
  </li>
  <li>
  <code>A.v</code>: The most recent value accepted by
  <code>A</code>. Initially <code>A.v = null</code>. 
  </li>
  <li>
  <code>A.v_t</code>: The time at which <code>A</code> accepted
  <code>A.v</code>. Initially <code>A.v_t = [0, null]</code>. 
  </li>
</ul>

<p class="w3-text-teal">Message Types</p>
<ul>
  <li>
  <code>prepare(time)</code> from a proposer to all acceptors.
  </li>
  <li>
  <code>promise(time, value, time)</code> reply to the proposer from
  an acceptor.
  </li>
  <li>
  <code>accept(time, value)</code> from the proposer to
  all acceptors.
  </li>
</ul>
  

<h4 class="w3-text-teal">Algorithm for Proposers and Acceptors</h4>
<pre>
// Proposer P. Step P.1. 
P.n = P.n + any positive value
P.t = [P.n, P.id]
send prepare(P.t) to all acceptors

// Acceptor A. Step A.1: 
upon receiving prepare(t) from a proposer P:
   if t >= A.t:
      A.t = t
      send promise(t, A.v, A.v_t) to P

// Proposer P. Step P.2. 
wait until timeout or:
     receive promise(t, A.v, A.v_t) from majority of
     acceptors where t = P.t
If timeout: return to step P.1
else:
     let promise(t, v*, v_t*) be the promise with
     the largest v_t
     if v* == NULL: send accept(t, P.V) to acceptors
     else: send accept(t, v*) to acceptors
      
// Acceptor A. Step A.2. 
upon receiving accept(t, v):
    if t >= A.t:  A.t, A.v = t, v
</pre>
<h4 class="w3-text-teal">Algorithm Steps</h4>
The algorithm has only one point where an agent waits: step P.2
In this step a proposer waits for a bounded time
to receive promise messages from a majority of acceptors. If these
messages don't arrive within this time then the proposer aborts this
iteration and starts the next iteration, i.e. back to step P.1,
without completing step P.2.
Acceptors respond immediately to messages that they receive.

<p>
A proposer repeatedly executes a loop consisting of steps P.1 and P.2.
For the time being assume that the loop never terminates; we will
discuss termination later.

<p>
In the discussion, we refer to <code>P.t</code> and <code>A.t</code>
as <code>P</code>'s sync-time and <code>A</code>'s sync-time,
respectively. We refer to <code>A.accept_v</code> as the value
accepted by <code>A</code>, and <code>A.accept_t</code> as the
sync-time of the value accepted by <code>A</code>. Notice that
<code>A.accept_t</code> and <code>A.accept_v</code> are always
modified together; moreover, they are modified only in step A.2 when
an acceptor receives an <code>accept</code> message.


<h3 style="color:red;">Example</h3>
The figure below shows a system timeline with 3 acceptors and 2
proposers. Timelines for learners are not shown. The events on the
timeline are: 
<ol>
  <li>
  <i>N(t)</i>: A proposer sends <code>prepare(t)</code> message, and
  the proposer's sync-time when it sends the message is
  <code>t</code>.
  </li>
  <li>
  <i>U(t)</i>: An acceptor replies to the proposer with a
  <code>updated_time(t, accept_v, accept_t)</code> message, and 
  the acceptor's sync-time when it sends the message is
  <code>t</code>.
  </li>
  <li>
  <i>P(t)</i>: A proposer responds with a
  <code>proposal(t, v)</code> message, and the proposer's sync-time at
  this event is <code>t</code>.
  </li>
  <li>
  <i>A(t)</i>: An acceptor accepts a proposer's
  <code>proposal(t, v)</code> by 
  sending a
  <code>accept(accept_v, accept_t)</code> message to learners, and 
  the acceptor's sync-time when it sends the message is
  <code>t</code>. The accept messages to learners are not shown.
  </li>
</ol>

<p>
In the diagram, <code>new_time</code> messages are grey,
<code>updated_time</code> messages are purple, and
<code>proposals</code> are black. The <code>new_time(t)</code> message
sent by proposer P0 to acceptor A2 is lost, and the the <code>proposal</code> sent
by P0 to acceptor A1 is lost.

<figure>
    <img src="PaxosFigures/PaxosFigures.012.jpeg" alt="Fig2" style="width:100%">
    <figcaption>Fig.2: Timelines</figcaption>
</figure>

<h4 class="w3-text-teal">Sync-times in Paxos satisfy rules for partial synchrony</h4>

Below is a copy of the description of partial synchrony that was given earlier.
The key property of sync-times:
   The sync-time of an event in which a message <code>M</code> is sent
   is the 
   the sync-time of the event in which <code>M</code> is processed.
  </p>
  
  <p class="w3-text-teal">Rules that ensure the sync-times
   property</p>
   Let <code>d</code> be the event in which a message <code>M</code>
   is sent, and let <code>e</code> be the event in which
   <code>M</code> is received. Let
   <code>P</code> and <code>Q</code> be the agents that send and
   receive <code>M</code>, respectively.
  <ol>
    <li>
    When <code>P</code> sends <code>M</code>, it
    sets <code>M.t</code> to <code>P.t</code>, which is also the
    sync-time <code>d.t</code> of this event. So
    <code>d.t = M.t</code>
    </li>
    <li>
    If <code>Q</code> receives <code>M</code> it processes
    <code>M</code> only if <code>M.t</code> \(\geq\) <code>Q.t</code>.
    If <code>Q</code> does process the message,
    <code>Q</code> first sets <code>Q.t </code> to <code>M.t</code>
   and next
    executes event <code>e</code> that processes <code>M</code>.
    So <code>e.t = M.t</code>.
  </ol>
  From these rules, <code>d.t = M.t = e.t</code>, and the key property
   of sync times follows.


<h1>=========================================</h1>

<h3 class="w3-text-teal">Observations about the Algorithm</h3>
Proposers execute steps P.1 and P.2. Acceptors execute steps A.1 and
A.2. 
<ol>
  <li>
  A proposer changes its sync-time only in step P.1. A proposer's
  sync-time never decreases.
  A proposer only processes messages with sync-times equal to the
  proposer's sync-time; all other messages are ignored (see step
  P.2).
  </li>
  <li>
  An acceptor only processes a message that has a sync-time that is greater
  than or equal to the acceptors's sync-time.
  When an acceptor processes a message, the acceptor sets its
  sync-time to the message's sync-time.
  </li>
  <li>
  The sync-time of a message sent by an agent (either an acceptor or a
  proposer) is the sync-time of the agent when the message is
  sent. So, the sync-time of a message is the sync-time of the event
  in which the message is sent.
  </li>
</ol>
So, the sync-time of a message is the sync-time of the event that
sends the message and is also  the sync-time of the event that
receives the message


<h5 class="w3-text-teal">Acceptor's Timeline</h5>
The figure below illustrates the timeline of an acceptor
<code>A</code> which receives messages from proposers <code>Y</code>
and <code>Z</code>.
<p>
<figure>
    <img src="./PaxosLecture/PaxosLecture.003.jpeg" alt="Fig2" style="width:80%">
    <figcaption>Fig.3: Acceptor's Timeline</figcaption>
</figure>
The arrows from the proposors' timelines to <code>A</code>'s timeline
represent messages sent by the proposer and accepted by
<code>A</code>. Lost messages are not shown.

<p>
The number next to the message is the sync-time of the message. A
sync-time is a pair (integer, proposer id); however, the proposer id
is not shown.

<p>
<code>A</code>'s sync-time is initially 0. When <code>A</code>
receives a message with sync-time 4 it increases its
sync-time to 4. Then <code>A</code> receives a message with sync-time
3 which it ignores because the message sync-time is lower
than its time. When <code>A</code> gets a message with
sync-time 6, <code>A</code> increases its sync-time to 6.

<p>
An acceptor's timeline can be partitioned into intervals where the
acceptor's time within each interval remains constant and increases
from an interval to the following one.
</p>




 

<p> In step A.1 if <code>t < A.t</code>, and in step A.2 if <code>t <=
A.t</code>, the message received by the acceptor is ignored. In step
P.2, an <code>updated_time</code> message received by a proposer
<code>P</code> is ignored if the <code>time</code> component of the
message is different from <code>P.t</code> Hereafter, we won't
consider messages that are ignored by agents. A diagram showing acceptor
<code>A</code>'s timeline without ignored or lost messages is shown
below where the blue arrows are messages from proposers.

<figure>
    <img src="./PaxosLecture/PaxosLecture.023.jpeg" alt="Fig3" style="width:80%">
    <figcaption>Fig.4: Acceptor's Timeline without Ignored Messages</figcaption>
</figure>

<hr class="new2">
<p style="color:blue;">
  Ignored messages are treated as lost messages.
</p>
<hr class="new2">
Hereafter, a <i>received message</i> is one that is not lost and is not ignored by the
receiver: it is a message in which the receiver takes some action upon
receiving the message.


<h5 class="w3-text-teal">Proposer's Timeline</h5>
An example of a proposer's timeline is shown in the figure below.

<figure>
    <img src="./PaxosLecture/PaxosLecture.024.jpeg" alt="Fig4" style="width:80%">
    <figcaption>Fig.5: Proposer's Timeline</figcaption>
</figure>
The proposer's timeline can also be partitioned into intervals within
    which the proposer's time remains constant. In this diagram,
    proposer <code>p</code>'s time is initially 0, and the proposer
    increases its time in step P.1. Let the new time be 10. Then the
    proposer sends <code>new_time(10)</code> to all acceptors. The
    proposer ignores all messages it gets next except for
    <code>updated_time(10, ..,)</code> messages with the same
    sync-time, 10. If it gets a majority of such messages, it sends 
<code>proposal(10, ..)</code> to all acceptors.
<p>
Likewise, in the next interval, while the proposer's time is 35, all
    the messages that the proposer sends and receives have the same
    sync-time: 35. (Recall that ignored messages are treated as lost
messages, and are treated as having been not received.)

<p>
  From the algorithm, the only new values of time are created by
  proposers in step P.1. Message sync-times and agent times in all
  other steps of the algorithm are obtained from messages received by
  agents.
  
<p>
As you can see: 
<hr class="new2">
<p style="color:blue;">
While a proposer's time is <code>t</code>, the sync-times of 
all messages that the proposer sends and receives is
<code>t</code>.
</p>
<hr class="new2">


The algorithm has the following easily-checked properties, for all acceptors \(A\) and
proposers \(P\):
<p>
invariant: \( \; A.accept\_t \leq A.t \)
<p>
invariant: \( \; (A.accept\_t = 0) \; \equiv \; (A.accept\_v = null) \)
<p>
\(A.t\), \(A.accept\_t\) and \(P.t\) never decrease.

<h4 class="w3-text-teal">Ignored messages</h4>
Messages that are lost or ignored do not change the states of
agents. <i>Processed</i> messages are messages that an agent receives
and then carries out an action such as sending a message. Processed
messages are:
<ol>
  <li>
    \(new\_time(T)\) messages received by an
    acceptor \(A\) when \(T > A.t\). See step A.1.
			     </li>
<li>
  \(proposal(T)\) messages received by an
    acceptor \(A\) when \(T \geq A.t\). See step A.2.
  </li>
<li>
  \(updated\_time(T)\) messages received by a proposer \(P\) when
  \(T = P.t\). See step P.2.
  </li>
</ol>


Because ignored messages don't change states of agents: 
<hr class="new2">
<p style="color:blue;">
  We only consider processed messages in trajectories.
</p>
<hr class="new2">

Every event in the algorithm sends a  \(new_time\),
\(updated_time\), \(proposal\), or \(accept\) message. Define the time
of the event as the sync-time of the messages sent in the event. This
is also the sync-time of the agent when it sends the message.

<h4 class="w3-text-teal">Semi-synchronous trajectories</h4>
We begin by proving that the Paxos algorithm satisfies its
specifications for semi-synchronous trajectories and later carry out
the proof for all trajectories.
<hr class="new2">
<p style="color:blue;">
A semi-synchronous trajectory is one that can be partitioned
into epochs where all events with the same sync-time are in the same
epoch. 
</p>
<hr class="new2">

<p>
  An epoch in which events have sync-time \(t\) is called epoch
  \(t\). Because sync-times are pairs (integer, process id), and all
  sync-times are created by proposers when they <i>send new_time</i>
  messages, it follows that exactly one proposer sends messages within
  an epoch.

  
<h5 style="color:red;">Example</h5>
<figure>
    <img src="./PaxosProof/PaxosProof.008.jpeg" alt="Fig4" style="width:80%">
    <figcaption>Fig.6: Example of epochs in a semi-synchronous trajectory</figcaption>
</figure>
The diagram shows a semi-synchronous trajectory with three epochs with
times \(t^{0}\), \(t^{1}\), and \(t^{2}\), shown
in brown, blue and green, respectively. All the events and messages in epoch
\(t^{i}\) have sync-time \(t^{i}\). In epochs \(t^{0}\) and \(t^{2}\)
the only proposer that sends and receives messages is P1, while in
epoch \(t^{1}\) the only proposer that sends and receives messages is P0.

<p>
  In epoch \(t^{0}\), proposer P1 increases its time (see step P.1) to  \(t^{0}\)
  and sends \(new\_time(t^{0})\) messages --- shown as brown arrows ---
  to acceptors. The message to acceptor A0 is lost. An acceptor \(A\)
  that gets the message replies with \(updated\_time(t^{0},
  A.accept\_v, A.accept\_t)\). Proposer P1 waits to receive at least 2
  \(updated\_time\) messages because 2 is a majority for a set of 3
  agents. When it receives the 2 messages, P1 sends  \(proposal(t^{0},
  P1.v)\) messages to acceptors. In this diagram, the \(proposal\)
  messages sent to A0 and A1 are lost while A2 receives the
  message which, in turn, sends \(accept\) messages. In this epoch, a
  majority of acceptors do not send \(accept\) messages.

<p>
  In epoch \(t^{1}\), proposer P0 increases its time, and sends
  \(new\_time(t^{1})\) messages. P0 timesout waiting to receive
  \(updated\_time\) messages from a majority of acceptors, and so it
  sends no \(proposal\) messages.

<p>
  In epoch \(t^{2}\), proposer P1 increases its time, and sends
  \(new\_time(t^{2})\) messages. P1 receives
  \(updated\_time\) messages from a majority of acceptors; sends
  proposals to acceptors; receives replies from a majority of
  acceptors, and then sends \(proposal\) messages. The
  \(proposal\) messages are received by a majority of acceptors, each
  of which sends \(accept\) messages. So, learners that receive
  \(accept\) messages from a majority of acceptors, set the values
  that they learned to the value in the \(accept\) messages.
  
  



<h3 class="w3-text-teal">Theorem</h3>
If a majority of acceptors accept the same value, \(V^{*}\) in an
epoch \(T^{*}\) of a semi-synchronous 
trajectory, then in all subsequent epochs:
<ol>
  <li>
    the value in all proposal and accept messages is \(V^{*}\), and
  </li>
  <li>
  for all acceptors \(A\):
    \( (A.accept\_t < T^{*}) \vee (A.accept\_v =  V^{*}) \)
		      </li>
</ol>

<h4 class="w3-text-teal">Proof</h4>
The proof is by induction on successive epochs in the sequence of
epochs that follows epoch \(T^{*}\). Let \(T^{i}\) be the time of the
\(i\)-th epoch after epoch \(T^{*}\), and let \(T^{0} = T^{*}\).

<p class="w3-text-teal">Base Case: epoch \(T^{*}\)</p>
<i>Part 1</i>: All proposals are sent by the
same proposer in an epoch, and all proposals have the same sync-time
and value. Therefore, the value in all proposal and accept messages in
epoch \(T^{*}\) is \(V^{*}\).

<p>
<i>Part 2</i>:  In epoch \(T^{*}\), \(A.accept\_t\) is changed only when 
\(A.accept\_v\) is set to \(V^{*}\), and so part 2 follows.

<p class="w3-text-teal">Induction step: epoch \(T^{i+1}\)</p>
Assume that the theorem holds for epochs \(T^{0}, T^{1}, \ldots,
T^{i}\), and prove that it holds for epoch \(T^{i+1}\).
The result is vacuously true if no proposals are sent in
   this epoch. Consider the case where proposals are sent.

   <p>
     Because  \(A.accept\_t\) is never decreased, it follows
     that in all epochs after epoch \(T^{*}\) there is a majority of
     acceptors for which \(A.accept\_t \geq T^{*}\). 
   <p>
     A proposer \(p\) sends a proposal only if it receives
     \(updated\_time\) messages from a majority of acceptors. Any two
     majorities have at least one element in common. So, there exists
     an acceptor \(A\) that sends an \(updated\_time\) message to
     \(p\) and for which \(A.accept\_t \geq T^{*}\). Because
     \(A.accept\_t\) is positive, \(A.accept\_v\) 
     is not null (see the invariants).

   <p>
     So, proposer \(p\) identifies the \(updated\_time\) message with
     the largest \(A.accept\_t\). This value is greater than or equal
     to \(T^{*}\), and so the corresponding \(A.accept\_v \) is
     \(V^{*}\), and therefore the  proposal's value is
     \(V^{*}\). So, the value of accept messages is also \(V^{*}\),
     and if \(A.accept\_v\) is changed then the new value is \(V^{*}\).


     <h5 style="color:red;">Example</h5>
     This example illustrates the idea underlying the proof. In the
     next diagram, proposer P0 sends a \(new\_time(T^{*})\)
     message which is received by acceptors A0 and A1 which respond
     with updated time messages with sync-time \(T^{*}\). Proposer P0
     receives both messages, and sends proposals to all acceptors. In
     this case the proposals are received by A0 and A2 which then send
     accept messages. When A0 and A2 receive the proposals they set
     \(A.accept\_t, A.accept\_v = T^{*}, V^{*}\), and these values
     remain unchanged until the next proposal is received. 
<figure>
    <img src="./PaxosProof/PaxosProof.009.jpeg" alt="Fig4" style="width:60%">
    <figcaption>Fig.7: Idea underlying the proof</figcaption>
</figure>

The diagram below shows an epoch T1 that follows epoch T0. In this
epoch, proposer P1 sends \(new\_time(T^{1})\) messages which are
received by acceptors A0 and A1 which respond with updated time
messages with sync-time \(T^{1}\).
When P1 gets both messages it sends proposals to all acceptors.
Let's use the argument of the proof
to determine the value of proposals and the accept message sent by A1 in this
epoch. 


<figure>
    <img src="./PaxosProof/PaxosProof.010.jpeg" alt="Fig4" style="width:60%">
    <figcaption>Fig.8: What can be proved about the next accept message?</figcaption>
</figure>


When P1 gets both updated time messages it
identifies the message with the largest value of \(A.accept\_t\). The
message sent by A0 has sync-time \(T^{*}\) whereas the message sent by
A1 has an earlier sync-time. So, the updated time message with the
largest \(A.accept\_t\) is the message sent by A0. 

P1 sends proposals with a value of
\(A0.accept\_t\) which is \(V^{*}\). The green circles show how the
value \(V^{*}\) is sent from A0 to P1 to A1.

   <p>
     We see that proposals and accept
messages have value \(V^{*}\) in the next epoch as well. 
<figure>
    <img src="./PaxosProof/PaxosProof.012.jpeg" alt="Fig4" style="width:60%">
    <figcaption>Fig.9: The role of the accept time: accept_t </figcaption>
</figure>
     
		  
<h3  class="w3-text-teal">Theorem: Paxos is Correct for
  Semi-Synchronous Trajectories</h3>
The specification of the algorithm is repeated here for convenience.
<ol>
  <li>
  <i>Learners learn only proposed values.</i>
  </li>
  <li>
  <i>A learner doesn't change the value that it learns.</i>
  </li>
  <li>
  <i>All learners learn the same value.</i>
  </li>
</ol>

   <p  class="w3-text-teal">Proof</p>
   The value of
<code>v</code> in every message is either null or <code>P.VALUE</code>
for some proposer P, and so part 1 follows. Parts 2 and 3 follow from
the previous theorem: if a majority of acceptors send identical
 \(accept(T^{*}, V^{*})\) messages in an epoch, then in all succeeding
epochs, the value \(v\) of every accept message remains \(V^{*}\).


<h3  class="w3-text-teal">Paxos is Correct for
  all Trajectories</h3>

We have shown that the Paxos algorithm is correct for semi-synchronous
trajectories. Now we show the correctness of the algorithm for all
trajectories.

Let \([past(T), future(T)]\) be a cut of a timeline where \(past(T)\)
is the set of events with time \(T\) or
less. Therefore \(future(T)\) is the set of events with time greater than \(T\).

<h4  class="w3-text-teal">Theorem: Consistent cuts</h4>
The cut \([past(T), future(T)]\) is consistent.

<h5  class="w3-text-teal">Proof</h5>
There is no message from an event in \(future(T)\)
to an event in \(past(T)\).

<p>
  If a proposer sends a message in the future, i.e., with a sync-time
  \(T' > T\) then the event in which an acceptor processes the message also
      has sync-time \(T'\), and is also in the future.
      Likewise, if a proposer sends a message with a sync-time
  \(T' > T\) then the event in which an acceptor receives the message also
      has sync-time \(T'\).

<h5 style="color:red;">Example</h5>
<figure>
    <img src="./PaxosProof/PaxosProof.018.jpeg" alt="Fig8" style="width:80%">
    <figcaption>Fig.8: Consistent Cuts of Paxos Trajectories</figcaption>
</figure>

The diagram shows a cut \([past(T), future(T)]\) of a trajectory. The
green circles represent events in the past, and the yellow circles
represent events in the future. A little analysis shows that there are
no edges from the future to the past. (Indeed, you can show that there
are no edges from the past to the future, and so the graph can be
partitioned into independent subgraphs.)

<h3  class="w3-text-teal">Theorem: Paxos is Correct</h3>
Consider any trajectory \(X\) in which a majority of acceptors accepts \((T^{*},
V^{*})\). Let \(Y\) be the semi-synchronous trajectory corresponding
to X.

From the theorem on semi-synchronous trajectories, for all
acceptances \((T', V')\) in \(Y\) with \(T' \geq T\) have \(V' =
V^{*}\).
Because the global states are identical in \(X\) and \(Y\), for all
acceptances \((T', V')\) in \(X\) with \(T' \geq T\) also have \(V' =
V^{*}\). Therefore if a learner receives \(accept(T^{*}, V^{*})\) from a
majority of acceptors, and the same or another learner receives \(accept(T', V')\) from a
majority of acceptors, then \(V' = V^{*}\) and the correctness of parts 2 and 3 of the
specification follow.


<h5 style="color:red;">Example</h5>
<figure>
    <img src="./PaxosProof/PaxosProof.019.jpeg" alt="Fig8" style="width:80%">
    <figcaption>Fig.8: Global States of Unsynchronized and
    Semi-Synchronized Trajectories</figcaption>
</figure>




<h4 class="w3-text-teal">Learners</h4>
The algorithm for learners is simple:
A learner determines that the consensus value is <code>V</code> if the
learner receives <code>accept(T, V)</code> messages from a majority of
acceptors with identical values of <code>(T, V)</code>.
We ignore learners in the algorithm description, and restrict
attention to whether and when a majority of
acceptors sends <code>accept(T, V)</code> messages with identical
values of <code>(T, V)</code>. 

<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
