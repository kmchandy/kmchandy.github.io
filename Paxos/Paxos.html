<!DOCTYPE html>
<html lang="en">
<title>Paxos</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
</style>
<body>


<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()"><i class="fa fa-bars"></i></a>
    <a href="../index.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">About the Course</a>
    <a href="../table_of_contents.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">Table of Contents</a>
    <a href="../cross_reference.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Index</a>
  </div>
  </div>
 

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left" id="mySidebar">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="Close Menu">
    <i class="fa fa-remove"></i>
  </a>

  <!-------------------------->
  <h3 class="w3-bar-item"><b>An Introduction to Distributed
  Algorithms</h3>
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="Paxos.html">Global Snapshots</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="PaxosExample.html">Examples</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="PaxosSelfTest.html">Self Test</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="PropertiesOfTimelinesExercises.html">Exercises</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="Paxos.html">Explorations</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="../SelfStabilizing/SelfStabilizing.html">
  Next: Self Stabilizing Algorithms</a> 
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="../ApplicationsDiffusingComputations/ApplicationsDiffusingComputations.html">
  Previous: Applications of Diffusing Computations
  </a>
  
</nav>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
  <div class="w3-row w3-padding-64">
  <div class="w3-twothird w3-container">

    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">The Paxos Algorithm</h1>
    
    <h2 class="w3-text-teal">Key Ideas</h1>
    There are many problems in which a collection of agents have to
    come to a <i>consensus</i> about something.
    In a control system with multiple
    and actuators, the actuators have to come to a consensus about the
    state of the environment so that they can operate in concert. A
    vehicle would crash
    if some actuators caused the vehicle to accelerate while other
    actuators applied brakes.
    In some applications, multiple agents have to elect a single
    leader.
    This module describes, <i>Paxos</i> an important algorithm by which agents in
    distributed systems come to a consensus.

    
<h2 class="w3-text-teal">Best Effort Consensus</h3>
The theorem says that there is no algorithm that guarantees that
    consensus will be reached;
    however, consensus can be reached in most practical situations.


    <p>
    The Paxos algorithms makes few assumptions.  Agents communicate by
    sending and receiving messages. Messages may be lost and may
    overtake each other. Agents may stop
    and restart later, and agents may be arbitrarily slow.

    <p>
    Messages are not modified in transit, and agents are not
    <a href="../Byzantine/Byzantine.html">Byzantine.</a> When an agent
    receives a message, the receiver knows the identity of the agent
    that sent the message.

<h3 class="w3-text-teal">Specification</h3>
<p>
The algorithm has agents called
<i>proposers</i> others called <i>learners</i>. (In an
implementation an agent may play the role of both proposer and
learner.) Proposers propose values. Learners come to a consensus among
    the proposed values.

    <p>
Associated with each learner \(L\) is a local variable \(L.value\)
which is initially \(null\). Similarly, each proposer \(P\) has a
local variable \(P.value\) which is initially the value that the
proposer is proposing.
<p>
The specification has three parts.
<ol>
  <li>
  Learners learn only proposed values.
  <p> For every learner \(L\):
  <p>
  \(
  (L.value \neq null) \quad \Rightarrow \quad
  (\exists \; \textrm{proposer} \: P : L.value = P.value)
  \)
  </li>
  <li>
  <i>All learners learn the same value.</i>
  <p>
  For all learners \(L\) and \(L'\):
  <p>
  \(
  (L.value \neq null) \wedge (L'.value \neq null) \quad \Rightarrow \quad
  ( L.value = L'.value)
  \)
  </li>
  <li>
  <i>After a learner learns a value it doesn't later learn a different
  value.</i>
  <p>
  For all learners \(L\), and for all non-null values \(V\):
  <p>
  \(
  stable (L.value = V)
  \)
  </li>
</ol>

<h2 class="w3-text-teal">The Paxos Algorithm</h2>
The Paxos Algorithm, proposed by Leslie Lamport, has an additional
layer of agents called <i>acceptors</i>. The communication structure
between agents is shown in the figure below.

<p>
<figure>
    <img src="PaxosFigures/Slide03.jpg" alt="Fig3" style="width:80%">
    <figcaption>Fig.1: Proposers, Acceptors and Learners</figcaption>
</figure>

<h4 class="w3-text-teal">Messages and Local Variables</h4>
In the description of the algorithm, <code>t</code> and
<code>acceptT</code> are numbers and <code>v</code> is either
<code>null</code> or 
<code>P.value</code> of some proposer <code>P</code>.

<p class="w3-text-teal">Message Types</p>
Proposers to acceptors: <code>prepare(t)</code>
<br>
Acceptors reply to proposer:
<code>promise(t, v, acceptT)</code>.
<br>
Proposers  to acceptors:
<code>propose(t, v)</code>.
<br>
Acceptors to learners: 
<code>accept(t, v)</code>. 

<p class="w3-text-teal">Local Variables</p>
The local variables are as follows.
<br>
Proposer <code>P</code>: <code>(P.t, P.v)</code>.
<br>
Acceptor <code>A</code>: <code>(A.t, A.v, A.acceptT)</code>.

<p>
The algorithm is given as an interleaving of actions of proposers and
acceptors. The algorithm for learners is simple:
A learner determines that the consensus value is <code>V</code> if the
learner receives <code>accept(T, V)</code> messages from a majority of
acceptors with identical <code>(T, V)</code>.

<pre>
Initially:
  For proposer P: P.v = P.value
  For acceptor A: A.v, A.acceptT = null, null,
  // P.t, A.t are arbitrary

// Proposer P. Step P.1
increment P.t by a positive amount
send prepare(P.t) to all acceptors

// Acceptor A. Step A.1
upon receiving prepare(t) from P:
   if t > A.t:
      A.t = t
      send promise(A.t, A.v, A.acceptT) to P

// Proposer P. Step P.2
upon receiving promise(t, v, acceptT) messages from a
     majority of acceptors where t == P.t:
     if v is not null for any of these messages:
         P.v =  the v field of the promise message
                with the largest acceptT field
     send propose(P.t, P.v) to all acceptors
      
// Acceptor A. Step A.2
upon receiving propose(t, v) from P:
    if t == A.t:
       A.v = v
       A.acceptT = t
       send accept(A.t, A.v) to all learners
</pre>

<h4 class="w3-text-teal">Algorithm Steps</h4>
The proposer repeatedly executes a
loop consisting of steps P.1 and P.2 until any learner learns a
consensus value.
<p>
For step P.2, a proposer waits for a bounded time
to receive promise messages from a majority of acceptors. If these
messages don't arrive within this time then the proposer aborts this
iteration and starts the next iteration i.e. back to step P.1.
<p>
In step 2 of the proposer, the proposer determines the promise message
with the largest <code>acceptT</code> field. How are ties broken? We
assume that the <code>t</code> values of a proposer have an extra
component: the id of the proposer. Ties are
broken lexicographically, using the proposer's id. (The proposer's id
is not shown in the algorithm.)

<!-------------------------------------------------------->
<h2 class="w3-text-teal">Timeline Diagram for Paxos</h2>

<p class="w3-text-teal">Position of an Event in a Timeline</p>
We will use a variation of timeline diagrams to help us understand and
prove the Paxos algorithm. Assume that all agents start with
<code>t</code> values of \(0\). This is merely for convenience in drawing
timelines. Timelines are horizontal and time progresses from left to
right. The position of an event on the timeline be the
<code>t</code> value of the agent that executes the event.

<p class="w3-text-teal">Messages in a Timeline</p>
Messages are shown only for those messages that are accepted by the
receiver. Let's look at this example. A proposer sends a message with
<code>t=T</code> and an acceptor <code>A</code> that receives this
message ignores it because <code>A.t</code> \(\geq\)
<code>t=T</code>. This message is not shown in the timeline because
the receiver ignored the message, and so message does not change the
state of the system.

<p>
For the purposes of the timeline, a message takes an infinitely small
positive amount to travel from sender to receiver. The diagram below
shows an example of a timeline.

<p>
<figure>
    <img src="PaxosFigures/Slide14.jpg" alt="Fig3" style="width:100%">
    <figcaption>Fig.3: Timelines</figcaption>
</figure>

<p>
The diagram shows the timeline for a proposer <code>Z</code>, acceptor
<code>A</code> and learner <code>L</code>. The diagram doesn't show
multiple proposers, acceptors and learners to prevent the diagram from
getting too crowded.

<p>
The first event in the timeline is a prepare message sent by proposer
<code>Z</code> when <code>Z.t = 10</code>. The position of this event
is 10 units to the right of time 0. The message,
<code>prepare(10)</code> is received by acceptor <code>A</code>;
assume that the message is received a little after 10, and this time
is indicated by 10+.

<p>
When acceptor <code>A</code> gets the prepare message it replies with
<code>promise(10, A.v, A.acceptT)</code>. The timeline shows that
proposer <code>Z</code> gets this message a little after it is sent,
and this time is shown as 10++.

<p>
Assume that proposer <code>Z</code> gets promise messages from a set
of acceptors in step P.2 where this set has more than half the number
of acceptors. Assume that in step P.2, proposer <code>Z</code> sets
<code>Z.v</code> to 'red' and so <code>Z</code> sends
<code>propose(10, 'red')</code> to all acceptors. Acceptor
<code>A</code> gets this message at 10+++ which is a little after it
was sent. Acceptor <code>A</code> then sends <code>accept(10,
'red')</code> to all learners which receive the message a little
later.

<p>
Then proposer <code>Z</code> starts a new round by sending
<code>prepare(11)</code>. The important point shown in the diagram is
that in the timeline <i>all the events due to the
<code>prepare(11)</code> message come after all
the events due to the <code>prepare(10)</code>
message</i>. And this property is because the diagram doesn't show
messages that are ignored by recipients.

<p>
This timeline diagram can be partitioned into a sequence of epochs
with each epoch stemming from a prepare(t) message.

<!-------------------------------------------------------->
<h5 class="w3-text-teal">Correctness Proof: Part 1</h5>
The proof of part 1 --
learners only learn values of proposers --- follows from
the following invariant which has a straightforward proof.
<p>
Invariant: For every agent and message,
the <code>v</code> field is either <code>null</code> or
<code>P.value</code> for some 
<code>P</code>.

<h3 class="w3-text-teal">Correctness Proof: Parts 2, 3</h3>

<p class="w3-text-teal">Lemma</p>
If a majority of acceptors have sent <code>accept(T,
V)</code> messages, where <code>(T, V)</code> are arbitrary constants
other than null,
then all <code>accept(t, v)</code> messages with <code>t</code> \(\geq\)
<code>T</code> have <code>v</code> = <code>V</code>.

<p class="w3-text-teal">Proof</p>
Assume that every acceptor in a set \(M\) of acceptors has sent
<code>accept(T, V)</code> messages, where \(M\) includes at least a
majority of acceptors. In the Paxos timeline, these messages are sent
in the epoch that is started by a proposer sending
<code>prepare(T)</code>.

<p>
Consider the next epoch in the timeline in
which an accept message is sent. Let this accept message be
<code>accept(t', v')</code> where <code>t'</code> \(>\)
<code>T</code>. This accept message is sent in the epoch that is
started by a proposer sending <code>prepare(t')</code>. In this epoch
every acceptor \(A\) in 
a majority \(M'\) of acceptors sends <code>promise(t', A.v,
A.acceptT)</code> messages. 

<p>
Sets \(M\) and \(M'\) have at least one
element in common. Every acceptor that is in both \(M\) and \(M'\)
sends <code>promise(t', V, T)</code>. Every acceptor \(A\) that is in \(M'\)
and not in \(M\) sends <code>promise(t', A.v, A.acceptT)</code> where
<code>A.acceptT</code> \(<\) <code>T</code> because
<code>A.acceptT</code> was last modified in an earlier epoch. In
step P.2, proposers in this epoch send <code>propose(t', V)</code>,
and so acceptances in this epoch are <code>accept(t', V)</code>.

<p>
A learner determines that the consensus is <code>V</code> only when it
receives <code>accept(T, V)</code> from a majority of acceptors. From
the lemma it follows that after any learner learns <code>V</code>, the
values learned by all learners is <code>V</code>.

<h3 style="color:red;">Example</h3>

<p style="color:red;">Diagram Structure</p>
The next diagram illustrates the idea behind the proof. The diagram
shows the Paxos timelines for a system with 3 acceptors A, B, C, and two
proposers Y and Z. Proposers Y and Z propose letters of the alphabet
and the learners come to a consensus about a proposed letter. Assume
that Y and Z propose "y" and "z" respectively. The diagram also shows
some events as yellow numbered circles; we will describe these events
while we explain the operation of the algorithm.

<p>
<figure>
    <img src="PaxosFigures/Slide15.jpg" alt="Fig3" style="width:100%">
    <figcaption>Fig.3: Example of Timelines Illustrating Proof Idea</figcaption>
</figure>

<p style="color:red;">Epoch 10</p>
The timeline shows three successive epochs with timestamps 10, 11,
12. In epoch 10, proposer Z sends <code>prepare(10)</code> to all
acceptors. Acceptors A and B receive the message, but C does
not. Acceptors A and B respond with <code>promise(10, null,
null)</code> because we assume that they haven't accepted a value
earlier. They set <code>A.t = 10</code> and <code>B.t = 10</code>.

<p>
When proposer Z receives these messages, it sends
<code>propose(10, "z")</code> on step P.2 to all acceptors. Only
acceptor A receives this message, and this event is shown as a yellow
circle with number 1. When A receives the message
it sets <code>A.v = "z"</code> and <code>A.acceptT = 10</code>, and
these values are shown in the yellow box, and A sends
<code>accept("z", 10)</code> to all learners.
<p>
The <code>v</code> and
<code>acceptT</code> values of acceptors <code>B</code> and
<code>C</code> have not changed, and the values are shown as (null,
null) in yellow boxes on timelines.

<p style="color:red;">Epoch 11</p>
In epoch 11, proposer Y sends <code>prepare(11)</code> to all
acceptors. Acceptors B and C receive the message, but A does
not. Acceptors B and C respond with <code>promise(11, null,
null)</code> because we assume that they haven't accepted a value
earlier. They set <code>B.t = 11</code> and <code>C.t = 11</code> and
reply to the prepare message with <code>promise(11, null,
null)</code>. 

<p>
When proposer Y receives these messages, it sends
<code>propose(11, "y")</code> on step P.2 to all acceptors.
Acceptors B and C receive this message, shown as yellow circles with
numbers 2 and 3.
Acceptor A does not receive the message.

<p>
When acceptors B and C receive the message
they sets <code>B.v, B.acceptT = "y", 11</code> and
<code>C.v, C.acceptT = "y", 11</code> (shown in yellow boxes) and each
of them sends <code>accept(11, "y")</code> to all learners.
<p>
The <code>v</code> and
<code>acceptT</code> values of acceptor <code>A</code> has not
changed; it remains <code>("z", 10)</code>.

<p>
After epoch 11, a majority of acceptors have sent <code>accept(11,
"y")</code>.

<p style="color:red;">Epoch 12</p>
In epoch 12, proposer Z sends <code>prepare(12)</code> to all
acceptors. Only A and B receive the message, and A responds with  
<code>promise(12, "z", 10)</code>, while A responds with  
<code>promise(12, "y", 11)</code>.

<p>
Proposer Z gets these promise messages on step P.2 (shown as event
number 6) and changes
<code>Z.v</code> from "z" to "y" and sends <code>propose(12,
"y")</code> to all acceptors. Acceptors A and B receive the message
and send <code>accept(12, "y")</code> to all learners.




  <footer id="myFooter">

    <div class="w3-container w3-theme-l1">
      <h4>An Introduction to Distributed Algorithms by K. Mani Chandy,
      <br>
      Simon Ramo Professor, Emeritus, California Institute of Technology</h4>
    </div>
  </footer>


      


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>

