    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">The Paxos Algorithm</h1>
    
    <h2 class="w3-text-teal">Key Idea: Consensus with Faulty
    Agents</h1>
Algorithms by which groups of agents
<a
    href="https://en.wikipedia.org/wiki/Consensus_(computer_science)">
come to a consensus
</a>
are among the most fundamental problems in distributed computing.


    <p>
    <a href="../ConsensusImpossible/ConsensusImpossible.html">
    From the FLP theorem</a>, which we discussed in the earlier
    module, we 
    know that that there is no algorithm that guarantees that
    consensus among distributed agents will be reached if messages
    are delayed for arbitrary time. Next we describe an algorithm that
    enables consensus to be reached in most situations,
    though there is a possibility that
    consensus may never be reached. We can use probabalistic
    algorithms to reduce the probability of
    never reaching consensus.

    <p>
    Why is reaching consensus so important? There are many problems in
    which messages are sent to groups of agents who collectively
    maintain a common <i>consensus</i> state. A bank may use a group
    of agents, rather than a single agent, to maintain bank
    balances. Multiple agents reduce the possibility of system-wide
    failure due to the failure of a single agent.  Managing replicated
    databases requires the replications to come to a consensus on the
    sequence of transactions that is applied to the
    database. Cryptocurrency transactions also require collections of
    agents to come to a consensus about sequences of the
    transactions. In distributed control systems agents have to come
    to a consensus about the state of the environment so that they can
    operate in concert.  In some applications, multiple agents have to
    elect a single leader.
    
    <p>
    This module describes,
    <a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)">
<i>Paxos</i>, an important algorithm</a> by which agents in a
distributed system come to a consensus.


There are other algorithms, such as
<a href="https://en.wikipedia.org/wiki/Raft_(algorithm)">
<i>Raft</i>
</a>
that deal with this problem;
we will describe them later.

    
<h3 class="w3-text-teal">Assumptions</h3>

<p>
The Paxos algorithm deals with messages that may be lost and that may
overtake each other. Agents  may stop and restart later,
and agents  may be arbitrarily slow. By contrast, in the
algorithms that we have discussed so far, we assume that messages are
not lost; messages sent along a channel are delivered in the order
sent; and agents do not stop.


<p>
The Paxos algorithm, and most distributed algorithms studied here,
assume that messages are not modified while in transit and that agents
do not have <a href="../Byzantine/Byzantine.html">Byzantine
faults.</a>

<h3 class="w3-text-teal">Specification</h3>

<p>
The algorithm has agents called
<i>proposers</i> and others called <i>learners</i>. (In an
implementation an agent may play the role of both proposer and
learner.) Proposers propose values. Learners come to a consensus among
    the proposed values.

    <p>
Associated with each learner \(L\) is a local variable \(L.value\)
which is initially \(null\). Associated with each proposer \(P\) is a
local constant \(P.VALUE\) which is the value that the
proposer is proposing.
<p>
The specification has three parts.
<ol>
  <li>
  <i>Learners learn only proposed values.</i>
  <p> For every learner \(L\):
  <p>
  \(
  (L.value \neq null) \quad \Rightarrow \quad
  (\exists \; \textrm{proposer} \: P : L.value = P.VALUE)
  \)
  </li>
  <li>
  <i>All learners learn the same value.</i>
  <p>
  For all learners \(L\) and \(L'\):
  <p>
  \(
  (L.value \neq null) \wedge (L'.value \neq null) \quad \Rightarrow \quad
  ( L.value = L'.value)
  \)
  </li>
  <li>
  <i>After a learner learns a value it doesn't later learn a different
  value.</i>
  <p>
  For all learners \(L\), and for all non-null values \(V\):
  <p>
  \(
  stable (L.value = V)
  \)
  </li>
</ol>

<h2 class="w3-text-teal">The Paxos Algorithm</h2>
The Paxos Algorithm, proposed by Leslie Lamport, has an additional
layer of agents called <i>acceptors</i>. The communication structure
between agents is shown in the figure below.

<p>
<figure>
    <img src="PaxosFigures/Slide02.jpg" alt="Fig1" style="width:80%">
    <figcaption>Fig.1: Proposers, Acceptors and Learners</figcaption>
</figure>

<h4 class="w3-text-teal">Local Variables and Messages</h4>
In the description of the algorithm;
<br>
<i>A timestamp</i> is a pair
  <code>(n, pid)</code>, where <code>n</code> is a number
  and <code>pid</code> is the id
  of a proposer. Proposer ids are totally ordered and are used to break
ties.
<br>
<i>A value</i>
  is either <code>null</code> or <code>P.VALUE</code>
  for some proposer <code>P</code>.

<p class="w3-text-teal">Local variable and constant for proposer
<code>P</code>.</p>
<ul>
  <li>
  Variable <code>P.t</code> (a timestamp), and
  </li>
  <li>
  Constant, <code>P.VALUE</code> (a value).
  </li>
</ul>

<p class="w3-text-teal">Local variables for acceptor
<code>A</code>.</p>
<ul>
  <li>
  <code>A.t</code> (a timestamp),
  </li>
  <li>
  <code>A.accept_v</code> (a value), and
  </li>
  <li>
  <code>A.accept_t</code> (a timestamp).
  </li>
</ul>

<p class="w3-text-teal">Messages</p>
<ol>
  <li>
  proposer to acceptors: <i>new_time</i>
  </li>
  <li>
  acceptor replies: <i>updated_time</i>
  </li>
  <li>
  proposer to acceptors: <i>proposal</i>
  </li>
  <li>
  acceptors to learners: <i>accept</i>
  </li>
</ol>

<h4 class="w3-text-teal">Learners</h4>
The algorithm for learners is simple:
A learner determines that the consensus value is <code>V</code> if the
learner receives <code>accept(T, V)</code> messages from a majority of
acceptors with identical values of <code>(T, V)</code>.

<h3 class="w3-text-teal">Algorithm for Proposers and Acceptors</h3>

<p>
The algorithm for proposers and acceptors is given below.

<pre>
//Initial values:
For all acceptors A:
     A.t = 0
     A.accept_v, A.accept_t = null, 0
For all proposers P:
     P.t = 0
  
// Proposer P. Step P.1
P.t = P.t + any positive value
send new_time(P.t) to all acceptors

// Acceptor A. Step A.1
upon receiving new_time(t) from any proposer P:
   if t > A.t:
      A.t = t
      send updated_time(A.t, A.accept_v, A.accept_t) to P

// Proposer P. Step P.2
wait to receive updated_time(t, accept_v, accept_t) messages from a
     majority of acceptors where t == P.t:
     if accept_v is null for all of these messages:
         send proposal(P.t, P.VALUE) to all acceptors
     else:
         v_max_acceptT =  the accept_v field of the updated_time message
                          with the largest accept_t field
         send proposal(P.t, v_max_acceptT) to all acceptors
      
// Acceptor A. Step A.2
upon receiving proposal(t, v) from P:
    if t >= A.t:
       A.t = t
       A.accept_v, A.accept_t = v, t
       send accept(A.accept_v, A.accept_t) to all learners
</pre>

<h4 class="w3-text-teal">Algorithm Steps</h4>
The algorithm has only one point where an agent waits: Step P.2.
In step P.2, a proposer waits for a bounded time
to receive promise messages from a majority of acceptors. If these
messages don't arrive within this time then the proposer aborts this
iteration and starts the next iteration, i.e. back to step P.1,
without completing step P.2.

<p>
A proposer repeatedly executes a loop consisting of steps P.1 and P.2.
For the time being assume that the loop never terminates; we will
discuss termination later.
Acceptors respond to messages that they receive from proposers.

<h4 class="w3-text-teal">Observations about the Algorithm</h4>
The following observations are helpful in understanding the algorithm.
<ol>
  <li>
  <p class="w3-text-teal">Ignored messages can be treated as lost</p>
  In step A.1 if <code>t < A.t</code>, and in step A.2 if <code>t <= A.t</code>, the
  message received by the acceptor is ignored. In step P.2, an
  <code>updated_time</code> message received by a proposer
  <code>P</code> is ignored
  if the <code>time</code> component of the message is different from
  <code>P.t</code>
  A lost message has exactly the same impact as an ignored message.
  We can treat all ignored messages as lost because they do not change
  variables or messages.
  </li>
  <li>
  <p class="w3-text-teal"><code>P.t</code> never decreases</p>
  The only change to <code>P.t</code> is in step P.1, and this change
  increases <code>P.t</code>. So, <code>P.t</code> never decreases:
  <p>
  <code>
  for all P, T: stable(P.t > T)
  </code>
  </li>
  <li>
  <p class="w3-text-teal"><code>A.t</code> never decreases</p>
  The changes to <code>A.t</code> in steps A.1 and A.2
  increase <code>A.t</code>. So, <code>A.t</code> never decreases:
  <p>
  <code>
  for all A, T: stable(A.t > T)
  </code>
  </li>
  <li>
  <p class="w3-text-teal"><code>A.accept_t <= A.t</code></p>
  The only step at which <code>A.accept_v, A.accept_t</code> is
  modified is step
  A.2 where
  <br><code>A.t = A.accept_t</code>.
  <p>
  Because
  <code>A.t</code> never decreases, we can prove the invariant:
  <br>
  <code>
  A.accept_t <= A.t
  </code>
  </li>
  <li>
  The next assertion deals only with messages that are received and
  processed. It does not deal with messages that are lost or ignored.
  <p>
  <i>Upon receiving a message with timestamp T the acceptor sets
  its timestamp to T or greater.</i> (See steps A.1, A.2).
  <p>
  <i>Upon receiving a message with timestamp T the proposer's
  timestamp is T.</i> (See steps P.2).
  </li>
</ol>
  
<h3 class="w3-text-teal">Consistent Cuts Based on Timestamps</h3>
Given any system timeline for the Paxos algorithm there exists a
system timeline with identical agent timelines and in which messages
are received only after they are sent and in which
<br>
<i>
events with smaller timestamps appear before events with larger
timestamps.
</i>
  

<h3 style="color:red;">Example</h3>
Consider a system with 5 acceptors. In step P.2 the proposer
implicitly starts a timer. The
proposer waits to
receive <code>promise(t, v, acceptT)</code> with 
<code>t == P.t</code> from at least 3 acceptors. Suppose it gets 
<code>promise(t, v, acceptT)</code> messages from 3 acceptors, but for some of the
messages <code>t != P.t</code>. In this case the proposer continues to
wait for more messages. If the timer goes off while the proposer is
waiting then the proposer aborts step P.2 and initiates the next
iteration of the loop by executing step P.1.

<h3 style="color:red;">Example</h3>
<p>
<figure>
    <img src="PaxosFigures/Slide07.jpg" alt="Fig2" style="width:100%">
    <figcaption>Fig.2: Timelines</figcaption>
</figure>

Assume that proposers propose colors and all learners come to a
consensus on a single proposed color. Assume that the color of
proposer <code>Z</code> is 'red'.

<p>
The diagram shows the timeline for a proposer <code>Z</code>, acceptor
<code>A</code> and learner <code>L</code>. The diagram doesn't show
multiple proposers, acceptors and learners to prevent the diagram from
getting too crowded.

<p>
The first event in the timeline is a prepare message sent by proposer
<code>Z</code> when <code>Z.t = 10</code>. The message,
<code>prepare(10)</code> sent by <code>Z</code> is received by acceptor
<code>A</code>.


When acceptor <code>A</code> gets the prepare message it replies with
<code>promise(10, A.v, A.acceptT)</code>.

<p>
Assume that proposer <code>Z</code> gets <code>promise(t, A.v,
A.acceptT)</code> messages from a
majority of acceptors where <code>t = 10</code> before step P.2 times
out.

<p style="color:red;">Example: Proposer proposes its own value</p>
If <code>A.v = null</code> for <i>all</i> these messages, then the
proposer proposes its own value, i.e., 
<code>Z</code> sends <code>propose(10, 'red')</code> to all acceptors
where <code>'red'</code> is <code>Z</code>'s color.

<p style="color:red;">Example: Proposer proposes value from acceptor</p>
If <code>A.v != null</code> for at least one of these messages then 
<code>Z</code>
inspects these messages to find the <code>A.v</code> in the message with the
largest value of <code>A.acceptT</code>.
Assume that <code>Z</code> receives
<code>promise(10, null, 0)</code>,
<code>promise(10, 'green', 4)</code>, and
<code>promise(10, 'blue', 6)</code>.
The promise message with the highest <code>A.acceptT</code> is
<code>promise(10, 'blue', 6)</code>.
So, <code>Z</code> sends
<code>propose(10, 'blue')</code> to all acceptors. 

<p>
If in step P.2, proposer <code>Z</code> sends
<code>propose(10, 'blue')</code> to all acceptors, and
<code>A</code> receives this message,  then <code>A</code>
sends <code>accept(10, 'blue')</code> to all learners.

<p style="color:red;">Example: Next Round</p>
In this example proposer <code>Z</code> starts a new round by sending
<code>prepare(11)</code>. It's possible that in this round
<code>Z</code> gets <code>promise(11, A.v, A.acceptT)</code> messages
from at least a majority of acceptors where <code>A.v = null</code> for
<i>all</i> the message that <code>Z</code> receives. In this example 
<code>Z</code> sends <code>propose(11, 'red')</code> to all
acceptors. Note that in this case <code>Z</code> sends 
<code>propose(10, 'blue')</code> and later sends
<code>propose(11, 'red')</code>. This example shows that <code>Z</code> may change the
value that it proposes.

<h3 style="color:red;">Example</h3>
The next two figures illustrate the meaning of <code>A.t</code> for an
acceptor <code>A</code>. 

<figure>
    <img src="PaxosFigures/Slide03.jpg" alt="Fig3" style="width:100%">
    <figcaption>Fig.3: Meaning of A.t for Acceptor A</figcaption>
</figure>

Acceptor <code>A</code> ignores all
<code>prepare(t)</code> and code>propose(t, v)</code> messages for
which <code>t < A.t</code>.

<figure>
    <img src="PaxosFigures/Slide04.jpg" alt="Fig4" style="width:100%">
    <figcaption>Fig.4: Meaning of A.t for Acceptor </figcaption>
</figure>

<!-------------------------------------------------------->
<p class="w3-text-teal">Timeline Diagram for Paxos</p>
In the Paxos algorithm an agent may discard a message without
taking action. For example, in step A.2 an acceptor <code>A</code> discards messages
with timestamps equal to or earlier than <code>A.t</code> without
taking action. 
In timeline diagrams for Paxos we show only messages that are
accepted. A message that is lost or discarded is not shown.


<h2 class="w3-text-teal">Correctenss</h2>
In the following the symbol "-" denotes any arbitrary value.

<!-------------------------------------------------------->
<h3  class="w3-text-teal">Theorem 1: Learners only learn values
proposed by proposers</h3>
The proof of part 1 --
learners only learn values of proposers --- follows from
the following invariant which has a straightforward proof.

<p  class="w3-text-teal">Invariant</p>
For every proposer, acceptor, and message,
the <code>v</code> field is either <code>null</code> or
<code>P.value</code> for some proposer
<code>P</code>.

<!-------------------------------------------------------->
<h4  class="w3-text-teal">Theorem 2</h4>
Let \(T_{0}\) be the smallest value of \(T\) such that a majority of
acceptors \(accept(T, -)\). Let \(V_{0}\) be the value accepted;
so a majority accepts \((T_{0}, V_{0})\). Let \(P\) be the earliest
time at which any acceptor accepts \((T_{0}, V_{0})\).
<p>
Then \(R.acceptT < T_{0}\) for all acceptors \(R\) at time \(P\).
<!-------------------------------------------------------->
<h4  class="w3-text-teal">Theorem 3</h4>
If a majority of acceptors
accepts \((T, V)\) and any acceptor accepts \((T', V')\) where \(T' \geq T\) then \(V'
= V\).

  
<h2 style="color:red;">Example: Illustration of Proof</h2>
We give the idea underlying the proof before giving the proof itself. 
The next sequence of diagrams illustrates the idea.
<p>
In the following we refer to the \(j\)-th acceptor either as acceptor
\(j\) or as \(R_{j}\).

<h4 style="color:red;">Example: Illustration of Proof of Theorem
2</h4>
The figure below shows a timeline diagram for proposers A, B, C
and acceptors 1 - 5. Acceptors 3, 4, 5 have accepted \((T_{0}, V_{0})\). No
majority of acceptors have accepted (T, V) for \(T < T_{0}\).
<p>
The acceptors that accept \((T_{0}, V_{0})\) may do so at different
points in time. Let \(P\) be the earliest time at which any acceptor
accepts \((T_{0}, V_{0})\). In the diagram acceptor 3 is the first to
accept \((T_{0}, V_{0})\) and point \(P\) is marked.
<p>
Consider an acceptor that does not accept  \((T_{0}, V_{0})\).
In the diagram, acceptors 1 and 2 do not accept 
\((T_{0}, V_{0})\). Let \(T'\) be the value of \(acceptT\)
for acceptor 1 at point \(P\). (The same argument holds for acceptor
2.)
<p>
The theorem says: \(T' < T_{0}\).

<figure>
    <img src="PaxosFigures/Slide08.jpg" alt="Fig5" style="width:100%">
    <figcaption>Fig.5: Illustration of Theorem </figcaption>
</figure>

<p>
What sequence of events must occur for \(R1.acceptT\) at point \(P\)
to be \(T'\)?

<p>
Acceptor R1 must have received \(propose(T', -)\) from some
proposer. In the diagram this proposer is \(B\).

<figure>
    <img src="PaxosFigures/Slide09.jpg" alt="Fig5" style="width:100%">
    <figcaption>Fig.5: Illustration of Theorem </figcaption>
</figure>

<p>
Proposer \(B\) sent \(propose(T', _)\) only because it received
\(promise(T', -, -)\) from a majority of acceptors. Any two
majorities have at least one element in common. So, at least one of
the acceptors that sent \(promise(T', -, -)\) also accepted \((T_{0},
V_{0})\). In the diagram this acceptor is R3.

<figure>
    <img src="PaxosFigures/Slide10.jpg" alt="Fig5" style="width:100%">
    <figcaption>Fig.5: Illustration of Theorem </figcaption>
</figure>
<p>
Because an acceptor sends \(promise(T', -, -)\) and later accepts \((T_{0},
V_{0})\) it follows that \(T' < T_{0}\).

<h4 style="color:red;">Example: Illustration of Proof of Theorem
3</h4>

Theorem 3 says: If a majority of acceptors accepts \((T_{0}, V_{0})\)  and any acceptor accepts \((T_{1}, V_{1})\) where \(T_{1} \geq T_{0}\), then \(V_{1} = V_{0}\).


The figure below shows a timeline diagram for proposers A, B, C
and acceptors 1 - 5. Acceptors 3, 4, 5 have accepted \((T_{0}, V_{0})\). No
majority of acceptors have accepted (T, V) for \(T < T_{0}\).


<figure>
    <img src="PaxosFigures/Slide05.jpg" alt="Fig5" style="width:100%">
    <figcaption>Fig.5: Illustration of Theorem </figcaption>
</figure>
In this figure, acceptor 1 has accepted \((T_{1}, V_{1})\). The diagram
    illustrates the first step of the induction. No acceptor has
    accepted \((T, V)\) where \(T_{0} < T < T_{1}\)

<p>
The next figure shows the steps that must precede acceptor 1 accepting
\((T_{1}, V_{1})\). Acceptor 1 must have received a \(propose(T_{1},
V_{1})\) message from some proposer before acceptor 1 accepted
\((T_{1}, V_{1})\). In the diagram this proposer is C. 


<figure>
    <img src="PaxosFigures/Slide06.jpg" alt="Fig6" style="width:100%">
    <figcaption>Fig.6: Illustration of Theorem </figcaption>
</figure>

<p>
Proposer C sends \(propose(T_{1}, V_{1})\) only after receiving
\(promise(T_{1}, -, -)\) messages from a majority of acceptors.
In the figure, proposer C
receives \(promise(T_{1}, -, -)\) messages from acceptors 1, 2, and
3. Let's analyze the promise messages received by proposer C.
<p>
The majority that accepts \((T_{0}, V_{0})\) and the majority that
sends \(promise(T_{1}, -, -)\) must have at least one acceptor in
common. In the figure acceptor 3 is common to both majorities.
<p>
Acceptor 3 sends \(promise(T_{1}, V_{0}, T_{0})\). 

Acceptor 1 sends \(promise(T_{1}, R_{1}.V, R_{1}.acceptT)\) and we
have shown that \(R_{1}.acceptT < T_{0}\) at point \(P\).
The same argument holds for acceptor 2.

<p>
Proposer C inspects the promise messages that it receives from acceptors
1, 2 and 3 and picks the message with the largest
value of accepT. This message is \(promise(T_{1}, V_{0}, T_{0})\) sent
by acceptor 3. Therefore, proposer C sends \(propose(T_{1}, V_{1})\) where
\(V_{1} = V_{0}\).



<h3 class="w3-text-teal">Proof</h3>
Next we give the outline of the proof.
<p>
The proof is by induction. Let \(T_{0}\) be the smallest value of
\(T\) such that a majority of acceptors accepts \((T, V)\). Let the
sequence of accepts with \(T\)-value greater than \(T_{0}\) be
\(T_{1}, T_{2}, \ldots\) where \(T_{j} < T_{(j+1)}\). Assume that the
theorem holds for the first \(k\) accepts in the sequence,
i.e., assume \(V_{j} = V_{0}\) for \(0 \leq j \leq k\)
and prove that
\(V_{(k+1)} = V_{0}\).

<p class="w3-text-teal">Base Case</p>
The base case is \(k = 0\)

<p class="w3-text-teal">Induction Step</p>
Let acceptor \(A\) accept \((T_{(k+1)}, V_{(k+1)})\). From step A.2,
acceptor  \(A\) received \(propose(T_{(k+1)}, V_{(k+1)})\) from a
proposer; let this proposer be proposer \(P\).

<p>
From step P.2, proposer \(P\) sends \(propose(T_{(k+1)}, V_{(k+1)})\)
only if it receives \(promise(T_{(k+1)}, -, -)\) from a majority of
acceptors. 

<p>
Because any two majorities have at least one element in common, there
is at least one acceptor that sent \(promise(T_{(k+1)}, -, -)\) and
also accepts \((T_{0}, V_{0})\).

<p>
By the induction assumption any
acceptor \(B\) that accepts \((T_{j}, V_{j})\) for any  \(0 \leq j \leq k\) sends
<p>
\(
promise(T_{(k+1)},V_{0}, B.acceptT)
\)
<p>
where \(T_{0} \leq B.acceptT \leq T_{k}\).

<p>
Any acceptor \(C\) that did not accept \((T_{j}, V_{j})\) for any
\(0 \leq j \leq k\)
sends
\(promise(T, V, C.acceptT)\) where \(C.acceptT < T_{0}\).

<p>
From step P.2 the promise message with the largest value of acceptT
has \(V = V_{0}\). So, proposer \(P\) sends
\(
propose(T_{(k+1)}, V_{0})
\)
and the theorem follows.