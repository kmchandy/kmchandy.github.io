<!DOCTYPE html>
<html lang="en">
<title>Paxos</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
</style>
<body>


<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()"><i class="fa fa-bars"></i></a>
    <a href="../index.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">About the Course</a>
    <a href="../table_of_contents.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">Table of Contents</a>
    <a href="../cross_reference.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Index</a>
  </div>
  </div>
 

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left" id="mySidebar">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="Close Menu">
    <i class="fa fa-remove"></i>
  </a>

  <!-------------------------->
  <h3 class="w3-bar-item"><b>An Introduction to Distributed
  Algorithms</h3>
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="Paxos.html">Global Snapshots</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="PaxosExample.html">Examples</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="PaxosSelfTest.html">Self Test</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="PropertiesOfTimelinesExercises.html">Exercises</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="Paxos.html">Explorations</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="../SelfStabilizing/SelfStabilizing.html">
  Next: Self Stabilizing Algorithms</a> 
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="../ApplicationsDiffusingComputations/ApplicationsDiffusingComputations.html">
  Previous: Applications of Diffusing Computations
  </a>
  
</nav>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
  <div class="w3-row w3-padding-64">
  <div class="w3-twothird w3-container">

    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">The Paxos Algorithm</h1>
    
    <h2 class="w3-text-teal">Key Ideas</h1>
    There are many problems in which a collection of agents have to
    come to a <i>consensus</i> about something.
    In a control system with multiple
    and actuators, the actuators have to come to a consensus about the
    state of the environment so that they can operate in concert. A
    vehicle would crash
    if some actuators caused the vehicle to accelerate while other
    actuators applied brakes.
    In some applications, multiple agents have to elect a single
    leader.
    This module describes an important algorithm by which agents in
    distributed systems come to a consensus.

    <h3 class="w3-text-teal">Consensus: Impossible with a
    faulty agent</h3>
    Consensus is impossible with even a single faulty agent. This was
    proved in a paper published by Fischer, Lynch and Patterson.

    <p>
    You can get the idea of why consensus is not possible by
    considering the following problem in which
    when message delays are finite but arbitrarily long.
    A collection of 2N + 1 agents want to
    come to a consensus about a color. N of the agents pick blue and
    N+1 pick red. One of the red agents is arbitrarily slow. The
    2N non-slow agents exchange messages among each other, and each of
    these 2N agents gets N votes for red and N votes for blue. Agents
    decide to take a majority vote, and in the event of a tie pick
    blue.

<p>
<figure>
    <img src="PaxosFigures/Slide01.jpg" alt="Fig1" style="width:80%">
    <figcaption>Fig.1: Problem with a slow agent</figcaption>
</figure>

    <p>
    How long should they wait for the slow agent?

    <p>
    Consider an algorithm in which agent waits until its local clock
    shows an elapsed time of T and then makes a decision based on the
    votes that it has.  An agent Y gets N red and N blue votes when
    its clock shows an elapsed time of T, and agent Y decides that the
    consensus is blue. Another agent Z has a slower clock and gets a
    red vote from the slow agent for a total of N+1 red votes, before
    Z's clock shows an elapsed time of T. So Z determines that the
    consensus is red. The algorithm fails because Y and Z have not
    come to a consensus. 

<p>
No algorithm is guaranteed to come to a consensus in finite time if
messages can be arbitrarily slow or if agents can be arbitrarily slow.
Systems with synchronized clocks don't have this particular
problem. We'll look at consensus in such systems later.

<h2 class="w3-text-teal">Best Effort Consensus</h3>
The theorem says that there is no algorithm that guarentees that
consensus can be reached in all scenarios; 
however, consensus can be reached in most practical situations. An idea
to overcome the counterexample given above is:
Agents keep trying repeatedly until they reach consensus. The theorem tells us
that the agents may have to keep trying for ever. We expect, however,
that in most practical situations their attempts will succeed at some point.

<p>
What does keep trying mean? When does one trial
end and the next one begin? If agents use timeouts to end a trial,
then --- because clocks aren't synchronized --- the timeouts may complete
at different times.
We'll see that we can use the idea of time, even though clocks aren't
synchronized. We've done that before with logical clocks.

<p>
The algorithm has agents called
<i>proposers</i> others called <i>learners</i>. (In an
implementation an agent may play the role of both proposer and
learner.) Proposers propose values. Learners come to a consensus among
the proposed values.

<p>Agents can communicate with each
other across message channels. Messages may be lost. Agents
may stop and restart later, and may be arbitrarily slow.

<p>
<figure>
    <img src="PaxosFigures/Slide02.jpg" alt="Fig2" style="width:80%">
    <figcaption>Fig.2: Proposers and Learners</figcaption>
</figure>

<h3 class="w3-text-teal">Specification</h3>
Associated with each learner \(L\) is a local variable \(L.value\)
which is initially \(null\). Similarly, each proposer \(P\) has a
local variable \(P.value\) which is initially the value that the
proposer is proposing.
<p>
The specification has three parts.
<ol>
  <li>
  <i>Learners learn only proposed values.</i>
  <p> For every learner \(L\):
  <p>
  \(
  (L.value \neq null) \quad \Rightarrow \quad
  (\exists \; \textrm{proposer} P : L.value = P.value)
  \)
  </li>
  <li>
  <i>All learners learn the same value.</i>
  <p>
  For all learners \(L\) and \(L'\):
  <p>
  \(
  (L.value \neq null) \wedge (L'.value \neq null) \quad \Rightarrow \quad
  ( L.value = L'.value)
  \)
  </li>
  <li>
  <i>After a learner learns a value it doesn't later learn a different
  value.</i>
  <p>
  For all learners \(L\), and for all non-null values \(V\):
  <p>
  \(
  stable (L.value = V)
  \)
  </li>
</ol>

<h2 class="w3-text-teal">The Paxos Algorithm</h2>
The Paxos Algorithm, proposed by Leslie Lamport, has an additional
layer of agents called <i>acceptors</i>. The communication structure
between agents is shown in the figure below.

<p>
<figure>
    <img src="PaxosFigures/Slide03.jpg" alt="Fig3" style="width:80%">
    <figcaption>Fig.3: Proposers, Acceptors and Learners</figcaption>
</figure>

<h4 class="w3-text-teal">Messages</h4>
The algorithm has four types of messages exchanged between proposers
and acceptors; we'll discuss learners later. The parameter \(t\) in all
these messages is a timestamp.
<ol>
  <li>
  <i>prepare(t)</i> sent from proposers to acceptors.
  </li>
  <li>
  <i>promise(t)</i> sent from acceptors to proposers.
  </li>
  <li>
  <i>request(t)</i> sent from proposers to acceptors.
  </li>
  <li>
  <i>accepted(t)</i> sent from acceptors to proposers.
  </li>
</ol>
The messages are sent in the above order.

<p>
<figure>
    <img src="PaxosFigures/Slide13.jpg" alt="Fig4" style="width:100%">
    <figcaption>Fig.4: Messages</figcaption>
</figure>

<p>
We will describe the algorithm in two stages.  The first stage
deals only with proposers and acceptors, and focuses exclusively on
timestamps. The second stage looks at communication between acceptors
and learners, and looks at consensus values as well as timestamps.

<h3 class="w3-text-teal">Stage 1: Proposers, Acceptors and
Timestamps</h3>
The algorithm, as described below, does not terminate; we will discuss
termination later. 

<h3 class="w3-text-teal">Timestamp Algorithm</h3>
Associated with each proposer \(P\) and each acceptor \(A\) are
local variables \(P.t\) and \(A.t\), respectively. The values of these
local variables are timestamps.

<h4 class="w3-text-teal">Algorithm for an Acceptor \(A\)</h4>

<pre>
initially A.t = 0

while true:

   1. upon receiving a prepare message from a proposer P:
          if prepare.t >= A.t:
               A.t = prepare.t
               send promise(A.t) to P

   2. upon receiving a request message from a proposer P:
          if request.t >= A.t
               A.t = request.t
               send accepts(A.t) to P
</pre>

<h5 class="w3-text-teal">Meaning of \(A.t\)</h5>
From the acceptor's algorithm, it follows that for an acceptor \(A\):
\(A.t\) is the maximum 
value of \(prepare.t\) and \(request.t\) 
over all the \(prepare\) and \(request\) messages that acceptor \(A\) has
received.

<p>
Acceptor \(A\) ignores a \(prepare\) messages
if \(prepare.t < A.t\), and likewise ignores a \(request\) messages if
\(request.t < A.t\). 

<p style="color:red;">Example</p>
The figure below illustrates the meaning of \(A.t\) for an acceptor \(A\). The diagram shows
timelines for proposers \(Y\) and \(Z\) in red, and the timeline for
acceptor \(A\) in blue. The \(prepare\) and \(request\) messages
sent by proposers \(Y\) and \(Z\) are shown as message lines.

<p>
\(A.t\) never
decreases and is the largest timestamp that \(A\) has received in messages from
proposers. 

<figure>
    <img src="PaxosFigures/Slide05.jpg" alt="Fig5" style="width:100%">
    <figcaption>Fig.5: Acceptor's t value</figcaption>
</figure>


<h5 class="w3-text-teal">Meaning of promise.t</h5>
After a proposer \(Y\) receives a \(promise(t)\) message sent by
acceptor \(A\), proposer \(Y\) knows that acceptor \(A\) will no
longer reply to \(prepare(t')\) or \(request(t')\) messages where \(t'
< t\). 


<p style="color:red;">Example</p>
After proposer \(Y\) receives
\(promise(6)\) from acceptor \(A\), proposer \(Y\)  knows that \(A\)
will ignore
\(prepare(t')\) or \(request(t')\) messages where \(t' < 6\). 

<figure>
    <img src="PaxosFigures/Slide06.jpg" alt="Fig6" style="width:100%">
    <figcaption>Fig.6: promise.t</figcaption>
</figure>

<h4 class="w3-text-teal">Algorithm for a Proposer \(P\)</h4>
<pre>
initially P.t = 0

while true:
   1. start timer; restart loop body if timeout

   2. increment P.t by a positive amount
      and then send prepare(P.t) to all acceptors

   3. if P receives promise messages where
      promise.t == P.t from a majority of acceptors:
           send request(P.t) to all acceptors
      // else execution of the loop times out and
      // a new loop begin

   4. if P receives accepts messages where
      accepts.t == P.t from a majority of acceptors:
          break
          // This completes execution of P.
      // else execution of the loop times out and
      // a new loop begins
</pre>



<h3 class="w3-text-teal">Theorem</h3>
At any point, if the largest timestamp of acceptance
messages sent by any majority of acceptors is \(t\), then the
timestamps of all messages sent up to that point do not exceed \(t\).

<p class="w3-text-teal">Proof</p>
We give the idea of the proof using an example. Consider the timelines
of a system with 5 acceptors, \(A, B, C, D, E\). Assume that there is
a point \(\tau\) on the timeline at which a majority --- say (A, B, C)
--- have sent <code>accept(t, v)</code>

Consider a point
\(\tau\) at
which the latest (and hence largest) timestamps of accepts messages
sent by \(A, B, C\) is \(t\). Let the latest timestamp of accepts
messages sent by \(D\) at \(\tau\) be \(t'\). We will prove that \(t'
\leq t\). 

<p>
Because \(D\) sent \(accepts(t')\) at \(\tau\),  it must have got
\(request(t')\) from a proposer, say proposer \(P\) before
\(\tau\). Because \(P\) sent \(request(t')\), it must have received
\(promise(t')\) from a majority of acceptors before \(\tau\). At least
one acceptor in this majority must be in \(A, B, C\) because any two
majorities must have an element in common. Let \(A\) be common to both
majorities.

<p>
Because \(A\) sent \(accepts(t)\), it must have received
\(request(t)\). If \(A\) sent \(promise(t')\) and then received
\(request(t)\), if \(t' > t\) then \(A\) would have ignored that
request. So, \(t' \leq t\) and the theorem follows.

<p>
If \(A\) received \(request(t)\) and then sent \(promise(t')\)
<p>




<h3 class="w3-text-teal">Theorem</h3>
If an acceptor sends \(accepts(t)\) at time \(\tau\) and a different
acceptor sends \(accepts(t')\) at time \(\tau'\), then:
<p>
\(
\tau < \tau' \quad \Rightarrow \quad t \leq t'
\)
<p class="w3-text-teal">Proof</p>
We first give the idea of the proof using an example. Consider a
system with 5 acceptors called \(A, B, C, D, E\).  At time \(\tau\) an
acceptor, say \(A\), sends \(accepts(t)\), and at time \(\tau'\) an
acceptor, say \(B\), sends \(accepts(t')\).
<p>
Because \(A\) sent \(accepts(t)\) at \(\tau\),  it must have got
\(request(t)\) from a proposer, say proposer \(P\) before
\(\tau\). Because \(P\) sent \(request(t)\), it must have received
\(promise(t)\) from a majority of 
acceptors before \(\tau\). By the same argument, a proposer must have
received 
\(promise(t')\) from a majority of 
acceptors before \(\tau'\). Let \(A\) be an acceptor common to both
majorities.

<p>
Ass


<p class="w3-text-teal">Proof</p>
We first give the idea of the proof using an example. Consider a
system with 5 acceptors called \(A, B, C, D, E\). At some point in
time \(\tau\), acceptor \(A\)
sends \(accepts(t)\). What must have happened before \(\tau\)?

<p>
Because \(A\) sent \(accepts(t)\) at \(\tau\),  it must have got
\(request(t)\) from a proposer, say proposer \(P\) at some time
\(\tau'\) where \(\tau' \leq \tau\). Because \(P\) sent \(request(t)\)
at \(\tau'\), it must have received \(promise(t)\) from at least a majority of
acceptors at some time \(\tau''\) where \(\tau'' \leq \tau'\). Assume
that this majority consists of \(A, B, C\).

<p>
Because \(A, B, C\) sent \(promise(t)\) messages at or before
\(\tau''\), all messages that they send at or after \(\tau''\) will
have timestamps greater than or equal to \(t\).

<p>
From the hypothesis of the theorem, a majority of acceptors send
\(accept(t')\) messages. There must be an overlap of at least one
acceptor between this majority and \(A, B, C\). Let this overlap be
\(C\).

<p>
Because \(C\) sent \(accept(t')\) it must have received a
\(request(t')\) from a proposer. So, this proposer must have received
\(promise(t')\) from a majority of acceptors.





<p class="w3-text-teal">Proof</p>
An acceptor accepts t only after receiving a request(t)
message from a proposer. See line 2 of the acceptor's algorithm.
<p>
A proposer sends a request(t) message only after receiving promise(t)
messages from a majority of acceptors. See line 4 of the proposer's
algorithm.
<p>
After an acceptor accepts t there exists a majority of proposers that
do not reply to prepare(t') or request(t') messages where t' <
t. Let's call the set of proposers in this majority \(m\).
<p>
Let \(m\) be the set of proposers in the majority that accepts \(T\)
after the acceptor accepts t. The sets \(m\) and \(m'\) have an
element in common because any two majorities have at least one common
element. Let \(A\) be a common element of both majorities.
<p>
\(A\) does not reply to prepare(t') or request(t') messages where t' <
t, and so if accepts \(T\) then \(T \geq t\).

<p>
<figure>
    <img src="PaxosFigures/Slide07.jpg" alt="Fig7" style="width:80%">
    <figcaption>Fig.7: Idea of the proof: 1</figcaption>
</figure><figure>
    <img src="PaxosFigures/Slide08.jpg" alt="Fig8" style="width:80%">
    <figcaption>Fig.8: Idea of the proof: 2</figcaption>
</figure>
The two figures, above, illustrate the ideas behind the proof.

<p>
We will find the following verion of theorem 1 to be useful.
<h4 class="w3-text-teal">Corollary</h4>
If a majority of acceptors has accepted \(T\) at some point, then no
acceptor has accepted \(t\) at that point where \(t > T\).


<h3 class="w3-text-teal">Proposers, Acceptors and Values</h3>
Now we give the complete algorithms for proposers and acceptors.

<h4 class="w3-text-teal">Messages</h4>
The messages have fields in addition to timestamps.
<ol>
  <li>
  <i>promise(t, accepted_t, value)</i> sent from acceptors to proposers.
  </li>
  <li>
  <i>request(t, value)</i> sent from proposers to acceptors.
  </li>
  <li>
  <i>accepts(t, value)</i> sent from acceptors to proposers.
  </li>
</ol>

<h4 class="w3-text-teal">Algorithm for Proposers</h3>
Associated with each proposer P is a local variable P.value
which is initially the value proposed by P, and which may change.

<pre>
initially P.t = 0, P.value = value proposed by P

while true:
   1. start timer; restart loop body if timeout

   2. increment P.t by a positive amount

   3. send prepare(P.t) to all acceptors

   4. if P receives promise messages where
      promise.t == P.t from a majority of acceptors:
           let M be the set of these messages
           where promise.value is not null
           if M is not the empty set:
                 let msg be the element of M with
                 the largest accept_t
                 set P.value to msg.value
            send request(P.t, P.value) to all acceptors


   5. if P receives accepts messages where
         accepts.t == P.t
         from a majority of acceptors:
             break
</pre>

<h4 class="w3-text-teal">Algorithm for Acceptors</h3>
Associated with each acceptor \(A\) are local variables A.accepted_t
and A.value which are both null initially. A.accepted_t and A.value
are timestamp and the value (respectively) of the most
recent proposal to which A replied with an accepts message.

<pre>
initially A.t = 0, A.accepted_t = null, A.value = null

while true:

   1. upon receiving a prepare message from a proposer P:
          if prepare.t >= A.t:
               A.t = prepare.t
               send promise(A.t, A.accepted_t, A.value) to P

   2. upon receiving a request message from a proposer P:
          if request.t >= A.t
               A.accepted_t, A.value = request.t, request.value
               send accepts(request.t, request.value) to P
</pre>
<p>
We shall say that an acceptor "<i>accepts (t, V)</i>" when it sends an
          accepts(t, V) message to any proposer.

<h3 class="w3-text-teal">Theorem: Stability of Majority
Acceptance</h3>
If any acceptor accepts (t', V') after a majority of acceptors accepts
(t, V) then V = V'

<p  class="w3-text-teal">Proof</p>


<p>
Let \(A\) be the first acceptor to accept any (t', V') where t' > t,
after the majority accepts (t, V).

From line 2 of the acceptor's program,
\(A\) received request(t', V') from a proposer P before \(A\)
accepted (t', V').
<p>
From line 4 of the proposer's program,
proposer P received promise messages with  promise.t = t'
from a majority of acceptors before P
sent request(t', V'). Let this majority be M'.
<p>
Two majorities have at least one element in common.
Let A' be any acceptor in both M and M'. Then since A' accepted (t, V),
it follows from line 1 of the acceptor's program that A' sends
promise(t', t, V) to proposer P. 
<p>
Let C be an acceptor in M' and not in M. From theorem 1, C.accepted_t
< t or C.value = V. So, C sends a promise message with
promise.accepted_t < t or promise.value.
<p>
Proposer P chooses the promise message with the largest accepted_t
field. The message with the largest accepted_t is promise(t', t,
V). So, proposer P sends request(t', V) to acceptor A. Therefore
acceptor A accepts (t', V).

<p>
The sequence of figures illustrates the steps of the proof. In these
figures t = 9 and t' = 12.


</figure><figure>
    <img src="Slide09.jpg" alt="Fig9" style="width:50%">
    <figcaption>Fig.9: Idea of the proof: 1</figcaption>
</figure>
<figure>
    <img src="Slide10.jpg" alt="Fig10" style="width:50%">
    <figcaption>Fig.10: Idea of the proof: 2</figcaption>
</figure>
<figure>
    <img src="Slide11.jpg" alt="Fig11" style="width:50%">
    <figcaption>Fig.11: Idea of the proof: 3</figcaption>
</figure>
<figure>
    <img src="Slide12.jpg" alt="Fig12" style="width:50%">
    <figcaption>Fig.12: Idea of the proof: 4</figcaption>
</figure>
<figure>
    <img src="Slide13.jpg" alt="Fig13" style="width:50%">
    <figcaption>Fig.13: Idea of the proof: 5</figcaption>
</figure>
<figure>
    <img src="Slide14.jpg" alt="Fig14" style="width:50%">
    <figcaption>Fig.14: Idea of the proof: 6</figcaption>
</figure>




<h3 class="w3-text-teal">Learning Consensus</h3>
We now have a simple solution to learn a consensus. Acceptors send
accept messages to all learners. When a learner receives
accept messages with the same accept.t and accept.V values then the
learner learns the value V.
From the above theorem, after a majority
of acceptors accept (t, V), all subsequent acceptances will accept the
same V.

<p>
Recall that the specification has three parts: (1)
learners learn values that have been proposed, (2) all learners learn
the same value, and (3) and after learning a value a learner doesn't
lear a new value.
The proof that the algorithm satisfies the specification is
straightforward.

<p>
The algorithm can be optimized. The optimizations don't change the
basic structure of the proof.


  <footer id="myFooter">

    <div class="w3-container w3-theme-l1">
      <h4>An Introduction to Distributed Algorithms by K. Mani Chandy,
      <br>
      Simon Ramo Professor, Emeritus, California Institute of Technology</h4>
    </div>
  </footer>


      


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>

