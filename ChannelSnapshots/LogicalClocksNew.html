<title>ChannelSnapshots/LogicalClocks.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  
    <!--------------------------------------------------------->
<h1 class="w3-text-teal">Logical Clocks</h1>

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/ChannelSnapshots/ChannelSnapshots.html">
  GlobalSnapshots.
  </a>
  


  <p class="w3-text-red">
   Logical clocks are local clocks that can be used in many algorithms
  as though local clocks are synchronized.
  </p>
  <p>
A logical clock algorithm is one in which each agent assigns a
number \(t(e)\), called
a timestamp, to each event \(e\) in its trajectory.
The timestamp of an event is
  called the logical time at the event.
  The logical time of an event can be used as though it is the real
  time for some problems.
  Logical clocks are not synchronized: different agents may have
  different logical times at the same instant.

<p>
  <i>Logical clocks don't change the underlying computation.</i> For example,
  we can add logical clocks to an algorithm that manages how files are
  shared in a distributed system. The algorithm for file-sharing
  remains unchanged when we superpose logical clocks on top of the
  algorithm. We can, however, use logical clocks to
  determine if the file-sharing algorithm is deadlocked.

 <h2 class="w3-text-teal">Specification of Logical Clocks</h2>
The specification of the algorithm is as follows.


<hr class="new2">
  <h5 style="color:blue;">
  Specification: 
If an event \(e\) depends on an
  event \(e'\) in the trajectory --- i.e. if there is a path from
  \(e'\) to \(e\) --- then \(t(e') < t(e)\).
</h5>
  <hr class="new2">

  This specification is equivalent to: If there is an edge from
\(e'\) to \(e\) then \(t(e') < t(e)\).

<h4 style="color:red;">Example</h4>


<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.001.jpeg" alt="Fig1" style="width:100%">
    <figcaption>Fig. 1: Logical Times</figcaption>
</figure>
The figure shows a timeline diagram with
agents \(A, B, D\), and with one channel from each agent to every
other agent.
Messages are shown as red arrows.
The diagram doesn't show arrows from each event to the next event on
    the same agent; each horizontal edge has an implicit direction
from left to right.
<p>
Logical times are shown as integers inside the circles
representing events.
The logical times satisfy the property that for every edge from 
\(e'\) to \(e\): \(t(e') < t(e)\).

<p>
We see that the \(n\)-th event on an agent's timeline does not have
logical time \(n\). For example the events on \(A\)'s timeline have
logical times 0, 1, 3. We  assume that logical times increase
continuously --- i.e. there is a point on each agent's
timeline at which the logical time is \(n\) for all \(n\).
So we assume that there is a point on on \(A\)'s timeline,  at which \(A\)'s
logical time increases from 1 to 2t.

<h2 class="w3-text-teal">Events in Logical Time Order</h2>
A consequence of the
<a href="../DISTRIBUTED_SYSTEM_MODELS/Timelines.html">
theorem about event dependence</a>
is the following important property of logical times.
<hr class="new2">
<h5 style="color:blue;">
Any permutation \(Y\) of the sequence of events of a given trajectory
\(X\) is also a trajectory that starts and ends in the same states as
\(X\) does provided
<br>
<center>
<i>events in \(Y\) are in increasing order of
logical times.</i> </center>
</h5>
<hr class="new2">

<h4 style="color:red;">Example: Events in Logical Time Order</h4>

The diagram below shows the events in the trajectory of figure 1 with
the events appearing in increasing order of timeline. The sequence of states of an
agent is the same in the
trajectories of figures 1 and 2.
<p>
We can think of the timeline in figure 2 as synchronous where local
clocks of agents are synchronized. 
Each agent takes a step that increments its local clock from \(t\) to
\(t+1\) at the same point in the trajectory.
A step either changes the system state state (an event) or 
merely increments the agent's local clock without changing state.  For
example, agents \(A\) and \(D\) execute actions that increment their
local clocks from 0 to 1, while
agent \(B\) increments its local clock to 1 without taking an action.
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.002.jpeg" alt="Fig1" style="width:100%">
    <figcaption>Fig. 2: Events Logical Time Order</figcaption>
</figure>
We partition trajectories in which events are ordered in logical time
into <i>epochs</i> 
where all agents have the same logical time in an epoch.
In the diagram, epoch 0 (agents have logical time 0) is shown in
green, epoch 1 in blue, and epoch 2 in brown.
Events occur at the border of one epoch and the next.
In the diagram, events are shown as colored circles while increments
of logical time without events are shown in white.

<p>
We can reason about the behavior of a given trajectory (figure 1) by
analyzing a synchronous trajectory (figure 2) with the same timeline
graph as the given trajectory.
We can design algorithm for a synchronous system and then
map the algorithm to an
asynchronous system by replacing <i>time</i> in the synchronous system
by <i>logical time</i> in the asynchronous system.

<p>
Let's use this methodology to develop a global snapshot algorithm.


<h2 class="w3-text-teal">Global Snapshots using Logical Times</h2>

<h4 class="w3-text-teal">First step: global snapshot algorithm for a
synchronous system</h4>
A snapshot algorithm in a system in which local clocks are
synchronized is straightforward.
Each agent records its state when its local clock is at \(T\).
A message is timestamped with the sender's time as determined by the
sender's clock.
An records the state of an
incoming channel as the sequence of messages that the agent receives with
timestamps of \(T\) or less that the agent receives when the agent's
time is greater than \(T\). 

<h4 style="color:red;">Example: Global snapshot in a synchronous system</h4>

The figure below illustrates the global state taken at time 2 in a
synchronous system.
The vertical line represents a point in the trajectory at time 2.

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.003.jpeg"
    alt="Fig3" style="width:100%"> 
    <figcaption>Fig. 3: Global Snapshot at Time 2 in a Synchronous System</figcaption>
</figure>


<h4 class="w3-text-teal">Second step: global snapshot for an
asynchronous system</h4> 
We get a general global snapshot algorithm by substituting <i>time</i> in the
algorithm for the synchronous system with <i>logical time</i>. Here is
the algorithm obtained by this substitution.
<p>
Each agent records its state at logical time \(T\). An agent records the state of an
incoming channel as the sequence of messages that the agent receives with
timestamps of \(T\) or less that the agent receives at time greater
than logical time \(T\).

<h4 style="color:red;">Example of Global Snapshot at Logical Time 2
</h4>
The vertical line at time 2 in the synchronous case is equivalent to a
curvilinear line in the asynchronous case.
The consistent cut separates the past (events with logical times of 2
or less) from the future (events with logical times greater than 2).
In the diagram, past events are colored black and future events are
colored green.

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.004.jpeg"
    alt="Fig4" style="width:100%"> 
    <figcaption>Fig. 4: Consistent Cut based on Timestamps</figcaption>
</figure>



<h2 class="w3-text-teal">Algorithm for Logical Clocks</h2>
The algorithm assigns logical times to events so that 
if there is an edge from \(e'\) to
\(e\) in the timeline graph then \(t(e') < t(e)\).x

<h4 class="w3-text-teal">Timestamps of Messages</h4>
Agents assign timestamps to messages that they send.
A message's timestamp is the logical time of the sender at the point
at which the message is sent, which is also
the logical time of the event in which the message is sent.

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.005.jpeg" alt="Fig2" style="width:100%">
    <figcaption>Fig. 5: Message Timestamps</figcaption>
</figure>

<h4 class="w3-text-teal">Logical Times of Events</h4>
The logical time of an event is a value greater than the
timestamps of messages (if any) received in the event and also greater than
the logical time of the previous event on that agent.
<p>
The timestamp of an initial event is arbitrary. In the examples we
assume that it is 0.

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.006.jpeg" alt="Fig2" style="width:100%">
    <figcaption>Fig. 6: Logical Times of Events</figcaption>
</figure>

The proof that this algorithm satisfies the specification is
straightforward.


<h3 class="w3-text-teal">Vector Clocks</h3>
The logical clock
algorithm ensures that if there  is 
a path from event \(e'\) to event \(e\) in the timeline then 
\(t(e') < t(e)\);
however, the converse is not necessarily true.
The vector clock algorithm assigns a vector time \(t(e)\) to each
event \(e\) with the following property

<hr class="new2">
<h5 style="color:blue;">
\(t(e') < t(e)\) if and only if there is 
a path from \(e'\) to \(e\).
</h5>
<hr class="new2">


<p>
Vector times are computed in the following way.
Let there be \(N\) agents in the system indexed \(0 \leq j <
N\).
A vector time is a vector of length \(N\).
Initial timestamps are zero vectors.

<p>
Let \(I_{j}\) be unit vector in direction \(j\), i.e. \(I_{j}\)
is  a vector of 
zeroes except that \(I_{j}[j] = 1\). A timestamp for an event \(e\)
on agent \(j\) is computed in the following way. Let \(e'\) be the
event immediately preceding \(e\) at agent \(j\).
<ol>
  <li>
  For an internal event: \(t(e) = t(e') + I_{j}\)
  </li>
  <li>
  For an event in which a message \(M\) with timestamp \(t(M)\) is received:
  \(t(e) = \textrm{max}(t(e') + I_{j}, t(M))\).
  The maximum of vectors in this formula is taken element by element.
  </li>
</ol>

<h4 style="color:red;">Example of Vector Clocks</h4>
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.008.jpeg" alt="Fig8" style="width:100%">
    <figcaption>Fig. 8: Example of Vector Clocks</figcaption>
</figure>
The figure shows both scalar and vector timestamps. Scalar
timestamps are shown inside the circles representing events while
vector timestamps are shown just outside the circles.
<p>
For example, there is a path from the event with timestamp \([1, 0,
1]\) to the event with timestamp \([2, 0, 1]\) whereas there is no
path between events with timestamps \([2, 0, 1]\) and \([1, 1, 2]\).


<h4 class="w3-text-teal">Proof of Correctness of Vector Clocks</h4>
Let \(e\) be an event at an agent \(j\), and let the vector time for
the event be \(T\). Then
<ol>
  <li>
  \(e\) is the \(T_{j}\)-th event at agent \(j\).
  </li>
  <li>
  For \(i \neq j\):
  <ol>
    <li> If \(T_{i} = 0\) then there is no path from
    any event at agent \(i\) to \(e\).
    </li>
    <li>
    If \(T_{i} > 0\) then the \(T_{i}\)-th event at agent \(i\) is the
    latest event at agent \(i\) with a path to \(e\).
    </li>
  </ol>
</ol>
The straightforward proof is by induction on the sequence of events in
the trajectory. 
  


<p style="color:red;">Example</p>
As an example, look at the event \(e\) with vector time \(T = [2, 2,
1]\) on agent 1. \(e\) is the second (\(T_{1} = 2\)) event at agent 1.
The latest event on agent 0 with a path to \(e\) is the second
(\(T_{0} = 2\)) event at agent 0. 
The latest event on agent 2 with a path to \(e\) is the first
(\(T_{2} = 1\)) event at agent 2. 

<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
