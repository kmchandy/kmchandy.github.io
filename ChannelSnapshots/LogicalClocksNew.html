<title>ChannelSnapshots/LogicalClocksNew.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  
  <!--------------------------------------------------------->
  <!--------------------------------------------------------->
<h1 class="w3-text-teal">Local Clocks and Logical Time</h1>

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/ChannelSnapshots/ChannelSnapshots.html">
  GlobalSnapshots.
  </a>
  </p>

  

  <!------------------------------------------------------------------->
  <!------------------------------------------------------------------->
  <h4 class="w3-text-red">
  <i>Central Ideas</i></h4>

  <p class="w3-text-red">
  (1) Local clocks of agents.
  (2) Logical times of events.
  (3) Consistent cuts at logical time \(t\).
  (4) Vector times.

  
  <!------------------------------------------------------------------->
  <p class="w3-text-red">

  Agents can maintain local clocks that may not be synchronized.

  The logical time of event \(e\) is greater than that of event \(e'\)
  if there is a path from \(e'\) to \(e\) in the causality graph.

  The vector times of event \(e\) is greater than that of event \(e'\)
  if and only if there is a path from \(e'\) to \(e\) in the causality
  graph.

  The set of events with logical timestamps less than \(t\), for any
  \(t\), is a consistent cut.


  <!--------------------------------------------->
  <h3 class="w3-text-teal">Agent Clocks</h3>
  <!--------------------------------------------->
  Most computers have clocks that move forward as time progresses.
  The clocks may, however, drift away from real time.
  Protocols such as
  <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">
  NTP -- Network Time Protocol</a> 
  can be used to limit the drift.
  Later, we will discuss synchronization using these protocols.
  Next, we look at a very simple synchronization problem.

  <p>
  Let \(t(e)\) be the time of an agent's clock when event \(e\) occurs
  at that agent.
  Assume that clocks tick forward as time progresses.
  Then for an event \(e\) that follows an event \(e'\) at an agent:
\(t(e) > t(e')\).
It is possible that \(t(e) \leq t(e')\) where \(e\) is the
  event in which a message is received, and \(e'\) is the event in
which that message is sent.
This situation may happen when the sender's clock runs 
faster than the receiver's clock.

<h4 class="w3-text-teal">Simple Clock Synchronization</h4>
<i>The Problem</i>: Design an algorithm to assign times \(t(e)\) to events \(e\) so that the
time of an event in which a message is received is later than the time
of the event in which the message is sent.

<p>
<i>Solution</i>: Use the following two rules:

<ol>
  <li>
  A message sent in an event \(e\) is assigned a timestamp \(t(e)\).
  </li>
  <li>
  If a message with with timestamp \(T\) arrives at an agent when the
  agent's clock is less than or equal to \(T\) then the clock is moved
  forward to a value greater than \(T\).
  </li>
</ol>
The amount of clock drift can be reduced by exchanging messages between agents
  periodically and adjusting clocks using delay statistics. 

<h4 class="w3-text-teal">Algorithm without using Computer Clocks</h4>
The algorithm given above assumes that agents hav clocks that tick
forward as time progresses.
If a computer doesn't have a clock, a rule that creates a logical clock
that effectively ticks forward is as follows:
For event \(e\) following event \(e'\) at the same agent, assign a
logical time \(t(e)\) to event \(e\) such that \(t(e) > t(e')\).
An algorithm that implements these rules is as follows.

<h4 class="w3-text-teal">Logical Clock Algorithm</h4>
Let \(e'\) be the event immediately preceding event \(e\) at an
agent.
<ol>
  <li>
  A message sent in an event \(e\) is assigned a timestamp \(t(e)\).
  </li>
  <li>
  If no message is received in event \(e\) then set \(t(e)\) to any
  value greater than \(t(e')\).
  </li>
  <li>
  If a message with timestamp \(T\) is received in \(e\) then set
  \(t(e)\) to any value greater than \(max (t(e'), T) \).
  </li>
</ol>

<!--------------------------------------------->
<h3 class="w3-text-teal">Logical Times of Events</h3>
<!--------------------------------------------->
An algorithm that uses the above three rules assigns logical time
\(t(e)\) to events \(e\) such that:
<hr class="new2">
<p style="color:blue;">
For every edge \((e', e)\) in the causality
graph of the computation, 
  \(t(e') < t(e)\).
  </p>
  <hr class="new2">

<!--------------------------------------------->
  <h4 style="color:red;">Example of Logical Time</h4>

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.001.jpeg" alt="Fig1" style="width:100%">
    <figcaption>Fig. 1: Logical Times</figcaption>
</figure>
The figure shows a timeline diagram with
agents \(A, B, D\), and with one channel from each agent to every
other agent.
Messages are shown as red arrows.
The diagram doesn't show arrows from each event to the next event on
    the same agent; each horizontal edge has an implicit direction
from left to right.
<p>
Logical times of events are shown as integers inside the circles
representing events.
For example, events 0, 1, and 2 on the timeline for agent B have
    logical times 0, 2 and 4, respectively.


<!--------------------------------------------->
<h3 class="w3-text-teal">Events in Increasing Logical Time are Computations</h3>
<!--------------------------------------------->

From the definition of logical time: a sequence of events in
increasing logical time is a topological sort of the causality graph.
Topological sorts of the causality graph are also computations.

So we get the following result.

<hr class="new2">
<p style="color:blue;">
Given logical times assigned to events in a computation from a state \(S\)
to a state \(S'\):
any permutation of events in the computation, where events occur in
increasing order of logical time in the permutation, is also
computations from \(S\) to \(S'\). 
</p>
<hr class="new2">

<!--------------------------------------------->
<h4 style="color:red;">Example: Events in Increasing Logical Time</h4>
<!--------------------------------------------->
Given the computation and logical times of figure 1,  there exists a
computation, shown in figure 2, in which events occur in logical
time: events with higher logical time occur to the right of events
with lower logical times.



<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.002.jpeg"
    alt="Fig2" style="width:100%"> 
    <figcaption>Fig. 2: Events occurring in Logical Time </figcaption>
</figure>

<h3 class="w3-text-teal">Cuts at Logical Times are Consistent</h3>
For any \(t\), define the cut \((past(t), future(t))\), as follows.
\(past(t)\) is the set of events with logical time \(t\) or less, and
therefore \(future(t)\) is the set of events with logical time greater
than \(t\). From the logical time property it follows that the cut
\((past(t), future(t))\) is consistent.


<!--------------------------------------------->

<h3 class="w3-text-teal">Global Snapshot at Logical Time \(t\)</h3>
An algorithm to obtain the global snapshot for the cut at any logical time \(t\) is as
follows.
<ol>
  <li>
  <i>Agent states</i>: Each agent records its local state at a point
  after all events with logical time at most \(t\) and before all
  events with logical time greater than \(t\).
  </li>
  <li>
  <i>Message timestamps</i>: Each message is timestamped with the
  logical time of the event in which the message is sent.
  </li>
  <li>
  <i>Channel states</i>: Each agent records the state of an incoming
  channel as the sequence of messages that have timestamp at most
  \(t\) that are received along the channel at events with logical
  time greater than \(t\).
  </li>
</ol>

<h4 style="color:red;">Example: Cut and Global Snapshot at Logical Time \(t =
2.8\)</h4> 

Figure 3 shows a consistent cut and a global snapshot at logical time
\(t = 2.8\).

<i>past(2.8)</i> is the set of events with logical time
\(2.8\) or less, and events in this set are shown as black vertices.
<i>future(2.8)</i> is the set of events with logical time greater than
\(2.8\) and events in this set are shown in green.


<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.003.jpeg"
    alt="Fig3" style="width:100%"> 
    <figcaption>Fig. 3: Global Snapshot at logical time t = 2.8</figcaption>
</figure>

<p>
Let's look at the same cut and snapshot in a computation in which
events occur in increasing logical time. 

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.004.jpeg"
    alt="Fig4" style="width:100%"> 
    <figcaption>Fig. 4: Cut at Logical Time 2.8 when Events occur in
    Logical Time</figcaption>
</figure>


<!--------------------------------------------->
<h3 class="w3-text-teal">Vector Clocks</h3>
<!--------------------------------------------->

The logical clock algorithm ensures that if there is a path from event
\(e'\) to event \(e\) in the causality graph then logical times have
the property \(t(e') < t(e)\).  Vector clocks ensure that the converse
also holds.  The specification for the vector time \(t(e)\) for an
event \(e\) is:

<p style="color:blue;">
\(t(e') < t(e)\) if and <i>only if</i> there is a path in the
causality graph from \(e'\) to \(e\).
</p>


<p>
A vector time for an event \(e\) is a vector \(V(e)\) of length \(N\)
where \(N\) is the number of agents in the system.

Let \(V_{j}(e)\) be the \(j\)-th element of vector \(V(e)\).
For events \(e'\) and \(e\) at the same agent \(j\), if \(e'\)
precedes \(e\), then set \(V_{j}(e)\) to any value such that:

<p>
\(
V_{j}(e) > V_{j}(e') 
\)

<p>
A message \(M\) is assigned a timestamp \(T(M)\) which is the vector
time of the event in which the message is sent.  Let \(e\) be an event
at an agent \(j\) where message \(M\) is received in the event, and
let \(e'\) be the event that immediately precedes \(e\) at agent \(j\). Then:
<p>
\(
\forall k \neq j:
V_{k}(e) = \textrm{max}(V_{k}(e'), T_{k}(M))
\)


<!--------------------------------------------->
<h4 style="color:red;">Example of Vector Clocks</h4>
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.005.jpeg" alt="Fig5" style="width:100%">
    <figcaption>Fig. 5: Example of Vector Clocks</figcaption>
</figure>
In this figure, the \(n\)-th event at an agent is shown as a circle
containing the number \(n\). Vector timestamps have 3 elements
corresponding to agents 0, 1, and 2.

<p>
Let \(U, V, W \) be the vector timestamps for for event number 2 at
agent 0, event number 3 at agent 0, and event number 1 at agent 1.
What values can \(V\) have?

<p>
The algorithm requires:
<p>
\(
V_{0} > U_{0} = 2
\)
<p>
\(
V_{1} = \textrm{max}(U_{1}, W_{1}) = \textrm{max}(0, 1) = 1
\)
<p>
\(
V_{2} = \textrm{max}(U_{2}, W_{2}) = \textrm{max}(1, 0) = 1
\)
<p>

<!--------------------------------------------->
<h4 class="w3-text-teal">Proof of Correctness</h4>
The proof that the vector clock algorithm satisfies its specification
is straightforward.


<!--------------------------------------------->
<h4 class="w3-text-red">
<i>Central Ideas: Review</i></h4>
<p class="w3-text-red">

If there is a path in the causality graph from an event \(e'\) to an
event \(e\) then the logical time of \(e\) is greater than that of
\(e'\).

For any \(t\), a cut where <i>past</i> is a set of events with logical
time \(t\) or less is a consistent cut.

Determining global snapshots using logical times is straightforward.

<!--------------------------------------------->
<p class="w3-text-red">
<i>Concepts</i>:
Timelines -> causality graphs -> logical and vector times -> consistent cuts ->
global snapshots.



<h4 class="w3-text-teal">Next</h4>
Next look at 
-- <a href="../Paxos/ConsensusImpossible.html">consensus algorithms</a>
or <a href="../table_of_contents.html">other types of algorithms</a>.







<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
