<title>ChannelSnapshots/LogicalClocksNew.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  
    <!--------------------------------------------------------->
<h1 class="w3-text-teal">Local Clocks and Logical Time</h1>

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/ChannelSnapshots/ChannelSnapshots.html">
  GlobalSnapshots.
  </a>
  </p>
  <h2 class="w3-text-teal">Local clocks</h2>
  Each agent can maintain a local clock.
  Later, we will describe algorithms that use protocols such as
<a href="https://en.wikipedia.org/wiki/Network_Time_Protocol"> the
Network Time Protocol (NTP)</a> and <a
href="https://en.wikipedia.org/wiki/Precision_Time_Protocol"> the
Precision Time Protocol (PTP)</a> to synchronize agent clocks.
  These algorithms do not, however, guarantee perfect synchrony.
  If the times at which messages are sent and received are determined
  by the sender's and receiver's clocks then a message may appear to
  be received before it is sent. The logical clock algorithm fixes
  this problem by assigning logical times to events so that the
  sender's logical time when a message is sent is earlier than
  the receiver's logical time when the message is received.

  <h3 class="w3-text-teal">Rules for Assigning Logical Times to Events</h3>

  Let \(t(e)\) be the value of the local clock at the agent on which
event \(e\) occurs.

<ol>
  <li>
  Each agent's clock ticks forward. So, if an event \(e'\) occurs
  after an event \(e\) at an agent then \(t(e') < t(e)\).
  </li>
  <li>
When a message is sent in an event \(e\), the message is assigned
  timestamp \(t(e)\).
  </li>
  <li>
  When a message with timestamp \(T\) arrives at the receiver, if the
  receiver's timestamp is less than \(T\) then the receiver
  moves its local clock forward to a value greater than \(T\)
  before it receives the message.
  </li>
</ol>

<h3 class="w3-text-teal">The Logical Time Property</h3>
Times assigned to events using the above rules have the following property:
<hr class="new2">
<p style="color:blue;">
The Logical Time Property: For every edge \((e', e)\) in the causality graph, 
\(t(e') < t(e)\).
</p>
<hr class="new2">
Event times that satisfy the logical time property are called logical
times. There are many ways of assigning times to events
that satisfy the logical time property.

  <h4 style="color:red;">Example of Logical Time</h4>

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.001.jpeg" alt="Fig1" style="width:100%">
    <figcaption>Fig. 1: Local Clock Times</figcaption>
</figure>
The figure shows a timeline diagram with
agents \(A, B, D\), and with one channel from each agent to every
other agent.
Messages are shown as red arrows.
The diagram doesn't show arrows from each event to the next event on
    the same agent; each horizontal edge has an implicit direction
from left to right.
<p>
Local clock values are shown as integers inside the circles
representing events.
For example, events 0, 1, and 2 on the timeline for agent B occur when
B's local clock has value 0, 2 and 4, respectively.



<h3 class="w3-text-teal">Events in Logical
Time</h3>

A sequence is defined to be in ascending order exactly when
smaller values occur in the sequence before larger values.
A sequence of events in ascending order of logical times is a
topological sort of the causality graph, which gives the following result.

<hr class="new2">
<p style="color:blue;">
A permutation of a computation
from a state \(S\) to a state \(T\) is also a computation from \(S\)
to \(T\) if events in the permutation occur in ascending order
of logical time.
</p>
<hr class="new2">

<p>
This result tells us that there is a computation in which
the time-axis of a timeline can be treated as real time, and where the
real time at which an event occurs is its logical time.

<h4 style="color:red;">Example: Events in Logical Time</h4>
Given the computation and logical times of figure 1,  there exists a
computation, shown in figure 2, in which events occur in logical
time.
The causality graphs of figures 1 and 2 are identical.
In the computation shown in figure 2, we can think of the time 
axis as real time, and treat logical times as real times.
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.002.jpeg"
    alt="Fig2" style="width:100%"> 
    <figcaption>Fig. 2: Events occurring in Logical Time </figcaption>
</figure>

<h3 class="w3-text-teal">Cuts at Logical Times are Consistent</h3>
For any \(t\), the cut with <i>past</i> as the set of events with
logical time \(t\) or less is consistent. This follows from the
logical time property: edges from events with logical time greater
than \(t\) are directed to events with logical time greater than \(t\).

<h5 class="w3-text-teal">Algorithm to obtain Global Snapshot at Logical Time \(t\)</h5>
An algorithm to obtain the global snapshot for the cut at logical time \(t\) is as
follows.
<ol>
  <li>
  <i>Agent states</i>: Each agent records its local state at a point
  after all events with logical time at most \(t\) and before all
  events with logical time greater than \(t\).
  </li>
  <li>
  <i>Message timestamps</i>: Each message is timestamped with the
  logical time of the event in which the message is sent.
  </li>
  <li>
  <i>Channel states</i>: Each agent records the state of an incoming
  channel as the sequence of messages that have timestamp at most
  \(t\) that are received along the channel at events with logical
  time greater than \(t\).
  </li>
</ol>

<h4 style="color:red;">Example: Cut and Global Snapshot at Logical Time \(t =
2.8\)</h4> 

Figure 3 shows a consistent cut and a global snapshot at logical time
\(t = 2.8\). The <i>past</i> is the set of events with logical time
\(2.8\) or less.


<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.003.jpeg"
    alt="Fig3" style="width:100%"> 
    <figcaption>Fig. 3: Global Snapshot at logical time t = 2.8</figcaption>
</figure>

<p>
Let's look at the same cut and snapshot in a computation in which
events occur in logical time. 

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.004.jpeg"
    alt="Fig4" style="width:100%"> 
    <figcaption>Fig. 4: Cut at Logical Time 2.8 when Events occur in
    Logical Time</figcaption>
</figure>



<h3 class="w3-text-teal">Vector Clocks</h3>
The logical clock
algorithm ensures that if there  is 
a path from event \(e'\) to event \(e\) in the causality graph then
logical times have the property
\(t(e') < t(e)\).
Vector clocks ensure that the converse also holds.
The specification for the vector time \(t(e)\) for an event \(e\)  is:

<p style="color:blue;">
\(t(e') < t(e)\) if and <i>only if</i> there is 
a path in the causality graph from \(e'\) to \(e\).
</p>


<p>
A vector time for an event \(e\) is a vector \(V(e)\) of length \(N\)
wher \(N\) is the number of agents in the system.
Let \(V_{j}(e)\) be the \(j\)-th element of vector \(V(e)\).
Let \(I^{(j)}\) be the unit vector along the \(j\)-th axes, i.e., the
vector has 1 in the \(j\)-th position and 0 elsewhere. The algorithm
for vector timestamps is as follows.

<p>
A message \(M\) is assigned a timestamp \(T(M)\) which is the vector time of the event in
which the message is sent.
Let \(e\) be an event at an agent \(j\) where message \(M\) is
received in the event and let \(e'\) be the event immediately
preceding \(e\) at agent \(j\). Set:
<p>
\(
V(e) = \textrm{max}(V(e'), T(M)) + I^{(j)}
\)
<p>
where the max is an element-wise maximum.
If \(e\) is an event in which no message is received then:
\(
V(e) = V(e') + I^{(j)}
\)
<p>
The proof that the algorithm gives vector times that satisfy the
specification is straightforward.


<h4 style="color:red;">Example of Vector Clocks</h4>
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.005.jpeg" alt="Fig5" style="width:100%">
    <figcaption>Fig. 5: Example of Vector Clocks</figcaption>
</figure>
The \(n\)-th event at an agent is shown as a circle containing the
number \(n\). You can easily verify that the vector times shown in the
diagram can be obtained by executing the given algorithm.


<h3 class="w3-text-teal">Heartbeats, NTP and Sequences of
Snapshots</h3>

<h4 class="w3-text-teal">Reference Times: NTP and PTP</h4>
Local clocks may drift away from a true or reference time.
We assume that all clocks tick forward: later clock readings are
always larger than earlier clock readings.
Many distributed systems
synchronize their local clocks to a standard reference clock. 
Logical time may, however, have no relation to real time.
Next, we discuss methods that reduce the drift of local clocks from a
reference time and also 
ensure that local clock times satisfy the logical
time specification.

<h4 class="w3-text-teal">Logical Times and Reducing Clock Drift</h4>
Agents call 
<a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">
NTP (Network Time Protocol)</a> servers to get the reference time.
Agents adapt local clock settings to match NTP.
Timing accuracies of milliseconds can be otained using
NTP, and <a href="https://en.wikipedia.org/wiki/Precision_Time_Protocol">
Precision Time Protocols (PTP)</a> deliver accuracy in the microsecond range.

<p>
We ensure that local clock times satisfy the logical time
specification using the logical time algorithm given earlier.
The steps of the algorithm are given here, again, for convenience.
The logical time of an event is
the time on the clock of the agent on which the event occurs.
Each message is assigned a timestamp which is the time of the sender's
clock when the message is sent.
When an agent receives a message with timestamp \(T\), if the
receiver's clock is at a value less than or equal to \(T\) then the
receiver moves its clock forward to a value greater than \(T\).


<h4 class="w3-text-teal">Heartbeat Messages</h4>
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">
Heartbeat messages
</a>
are used in many distributed systems.
Each agent periodically sends a heartbeat message, with the sender's
time, on each of its outgoing channels.
Heartbeat messages reduce clock drift among agents.
Agents can record global states at heartbeats by using their local
clocks, as described earlier.
The sequence of global states, recorded in successive heartbeats, is
useful in many algorithms. 


<h4 class="w3-text-teal">Properties of local clocks</h4>
Local clocks that use these algorithms have valuable properties:
<ol>
  <li>
  <i>Consistent cuts at \(t\)</i>. For all \(t\), the cut when each
  agent's local clock is at \(t\) is a
  consistent cut.
  Therefore, the global state when local clocks are at \(t\) is a
  state that could have occurred in the computation.
  </li>
  <li>
  <i>Clocks tick forward</i>. For any \(t\) there is a point in the computation at which the
  clocks of all agents have times greater than \(t\).
  </li>
</ol>
<p>
Local clocks do not have to use reference times such as NTP to have
these properties. Synchronization with reference time reduces the
likelihood that an agent will need to move its local clock forward
so that the receiver's time when a message is received is later than
the sender's time when a message is sent. Reference clocks are widely
used in distributed systems, and we might as well use them in
combination with logical time requirements.

<h4 class="w3-text-teal">Example Applications</h4>
The operating system of a distributed system can use local times to detect important
conditions such as termination and deadlock of a computation.
The operating system merely checks the snapshots recorded at each
heartbeat to determine if the snapshot exhibits the specified
property.
If a snapshot shows that the computation has terminated then the
computation has indeed terminated.
If the snapshot doesn't show that the computation has terminated then
check the snapshot at the next heartbeat.






<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
