<title>ChannelSnapshots/LogicalClocksNew.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  
  <!--------------------------------------------------------->
  <!--------------------------------------------------------->
<h1 class="w3-text-teal">Local Clocks and Logical Time</h1>

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/ChannelSnapshots/ChannelSnapshots.html">
  GlobalSnapshots.
  </a>
  </p>

  

  <!------------------------------------------------------------------->
  <!------------------------------------------------------------------->
  <h4 class="w3-text-red">
  <i>Central Ideas</i></h4>

  <p class="w3-text-red">
  (1) Local clocks of agents.
  (2) Logical times of events.
  (3) Consistent cuts at logical time \(t\).
  (4) Vector times.

  
  <!------------------------------------------------------------------->
  <p class="w3-text-red">

  Agents can maintain local clocks that may not be synchronized.

  The logical time of event \(e\) is greater than that of event \(e'\)
  if there is a path from \(e'\) to \(e\) in the causality graph.

  The vector times of event \(e\) is greater than that of event \(e'\)
  if and only if there is a path from \(e'\) to \(e\) in the causality
  graph.

  The set of events with logical timestamps less than \(t\), for any
  \(t\), is a consistent cut.
  

  <!------------------------------------------------------------------->
  <!------------------------------------------------------------------->
  <h2 class="w3-text-teal">Local clocks</h2>
  <!------------------------------------------------------------------->
  
  Each agent can maintain a local clock.
  Later, we will describe algorithms that use protocols such as
<a href="https://en.wikipedia.org/wiki/Network_Time_Protocol"> the
Network Time Protocol (NTP)</a> and <a
href="https://en.wikipedia.org/wiki/Precision_Time_Protocol"> the
Precision Time Protocol (PTP)</a> to synchronize agent clocks.
  These algorithms do not, however, guarantee perfect synchrony.
  If the times at which messages are sent and received are determined
  by the sender's and receiver's clocks then a message may appear to
  be received before it is sent. The logical clock algorithm fixes
  this problem by assigning logical times to events so that the
  sender's logical time when a message is sent is earlier than
the receiver's logical time when the message is received.


<!--------------------------------------------->
  <h3 class="w3-text-teal">Rules for Assigning Logical Times to
Events</h3>
<!--------------------------------------------->

  Let \(t(e)\) be the value of the local clock at the agent on which
event \(e\) occurs.

<ol>
  <li>
  Each agent's clock ticks forward. So, if an event \(e'\) occurs
  after an event \(e\) at an agent then \(t(e') < t(e)\).
  </li>
  <li>
When a message is sent in an event \(e\), the message is assigned
  timestamp \(t(e)\).
  </li>
  <li>
  When a message with timestamp \(T\) arrives at the receiver, if the
  receiver's timestamp is less than \(T\) then the receiver
  moves its local clock forward to a value greater than \(T\)
  before it receives the message.
  </li>
</ol>

<!--------------------------------------------->
<h3 class="w3-text-teal">The Logical Time Property</h3>
<!--------------------------------------------->

Times assigned to events using the above rules have the following property:
<hr class="new2">
<p style="color:blue;">
The Logical Time Property: For every edge \((e', e)\) in the causality graph, 
\(t(e') < t(e)\).
</p>
<hr class="new2">
Event times that satisfy the logical time property are called logical
times. There are many ways of assigning times to events
that satisfy the logical time property.

<!--------------------------------------------->
  <h4 style="color:red;">Example of Logical Time</h4>

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.001.jpeg" alt="Fig1" style="width:100%">
    <figcaption>Fig. 1: Local Clock Times</figcaption>
</figure>
The figure shows a timeline diagram with
agents \(A, B, D\), and with one channel from each agent to every
other agent.
Messages are shown as red arrows.
The diagram doesn't show arrows from each event to the next event on
    the same agent; each horizontal edge has an implicit direction
from left to right.
<p>
Local clock values are shown as integers inside the circles
representing events.
For example, events 0, 1, and 2 on the timeline for agent B occur when
B's local clock has value 0, 2 and 4, respectively.


<!--------------------------------------------->
<h3 class="w3-text-teal">Events in Ascending Logical Time</h3>
<!--------------------------------------------->

All sequences of events in ascending logical times are
topological sorts of the causality graph.

So:

<hr class="new2">
<p style="color:blue;">
All permutations of a computation from a state \(S\) to a state \(T\),
where events in the permutation are in ascending logical time, are also
computations from \(S\) to \(T\).
</p>
<hr class="new2">

<p>
So there is a timeline in which each event occurs at its logical
time. This is illustrated by the next example.

<!--------------------------------------------->
<h4 style="color:red;">Example: Events in Ascending Logical Time</h4>
<!--------------------------------------------->
Given the computation and logical times of figure 1,  there exists a
computation, shown in figure 2, in which events occur in logical
time.
The causality graphs of figures 1 and 2 are identical.



<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.002.jpeg"
    alt="Fig2" style="width:100%"> 
    <figcaption>Fig. 2: Events occurring in Logical Time </figcaption>
</figure>
In the timeline shown in figure 2, each event occurs at
the event's logical time; some events occur at logical time 1, and
others at logical time 2, and so on.

A computation is a sequence of events, and events at the same
logical time can occur in arbitrary order in the computation.

<h3 class="w3-text-teal">Cuts at Logical Times are Consistent</h3>
For any \(t\), the cut with <i>past</i> as the set of events with
logical time \(t\) or less is consistent. This follows from the
logical time property: edges from events with logical time greater
than \(t\) are directed to events with logical time greater than
\(t\).


<!--------------------------------------------->

<h4 class="w3-text-teal">Algorithm to obtain Global Snapshot at Logical Time \(t\)</h4>
An algorithm to obtain the global snapshot for the cut at logical time \(t\) is as
follows.
<ol>
  <li>
  <i>Agent states</i>: Each agent records its local state at a point
  after all events with logical time at most \(t\) and before all
  events with logical time greater than \(t\).
  </li>
  <li>
  <i>Message timestamps</i>: Each message is timestamped with the
  logical time of the event in which the message is sent.
  </li>
  <li>
  <i>Channel states</i>: Each agent records the state of an incoming
  channel as the sequence of messages that have timestamp at most
  \(t\) that are received along the channel at events with logical
  time greater than \(t\).
  </li>
</ol>

<h4 style="color:red;">Example: Cut and Global Snapshot at Logical Time \(t =
2.8\)</h4> 

Figure 3 shows a consistent cut and a global snapshot at logical time
\(t = 2.8\). The <i>past</i> is the set of events with logical time
\(2.8\) or less.


<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.003.jpeg"
    alt="Fig3" style="width:100%"> 
    <figcaption>Fig. 3: Global Snapshot at logical time t = 2.8</figcaption>
</figure>

<p>
Let's look at the same cut and snapshot in a computation in which
events occur in logical time. 

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.004.jpeg"
    alt="Fig4" style="width:100%"> 
    <figcaption>Fig. 4: Cut at Logical Time 2.8 when Events occur in
    Logical Time</figcaption>
</figure>


<!--------------------------------------------->
<h3 class="w3-text-teal">Vector Clocks</h3>
<!--------------------------------------------->

The logical clock algorithm ensures that if there is a path from event
\(e'\) to event \(e\) in the causality graph then logical times have
the property \(t(e') < t(e)\).  Vector clocks ensure that the converse
also holds.  The specification for the vector time \(t(e)\) for an
event \(e\) is:

<p style="color:blue;">
\(t(e') < t(e)\) if and <i>only if</i> there is a path in the
causality graph from \(e'\) to \(e\).
</p>


<p>
A vector time for an event \(e\) is a vector \(V(e)\) of length \(N\)
where \(N\) is the number of agents in the system.

Let \(V_{j}(e)\) be the \(j\)-th element of vector \(V(e)\).
For events \(e'\) and \(e\) at the same agent \(j\), if \(e'\)
precedes \(e\), then set \(V_{j}(e)\) to any value such that:

<p>
\(
V_{j}(e) > V_{j}(e') 
\)

<p>
A message \(M\) is assigned a timestamp \(T(M)\) which is the vector
time of the event in which the message is sent.  Let \(e\) be an event
at an agent \(j\) where message \(M\) is received in the event, and
let \(e'\) be the event that immediately precedes \(e\) at agent \(j\). Then:
<p>
\(
\forall k \neq j:
V_{k}(e) = \textrm{max}(V_{k}(e'), T_{k}(M))
\)


<!--------------------------------------------->
<h4 style="color:red;">Example of Vector Clocks</h4>
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.005.jpeg" alt="Fig5" style="width:100%">
    <figcaption>Fig. 5: Example of Vector Clocks</figcaption>
</figure>
In this figure, the \(n\)-th event at an agent is shown as a circle
containing the number \(n\). Vector timestamps have 3 elements
corresponding to agents 0, 1, and 2.

<p>
Let \(U, V, W \) be the vector timestamps for for event number 2 at
agent 0, event number 3 at agent 0, and event number 1 at agent 1.
What values can \(V\) have?

<p>
The algorithm requires:
<p>
\(
V_{0} > U_{0} = 2
\)
<p>
\(
V_{1} = \textrm{max}(U_{1}, W_{1}) = \textrm{max}(0, 1) = 1
\)
<p>
\(
V_{2} = \textrm{max}(U_{2}, W_{2}) = \textrm{max}(1, 0) = 1
\)
<p>

<!--------------------------------------------->
<h4 class="w3-text-teal">Proof of Correctness</h4>
The proof that the vector clock algorithm satisfies its specification
is straightforward.


<!--------------------------------------------->
<h4 class="w3-text-red">
<i>Central Ideas: Review</i></h4>
<p class="w3-text-red">

If there is a path in the causality graph from an event \(e'\) to an
event \(e\) then the logical time of \(e\) is greater than that of
\(e'\).

For any \(t\), a cut where <i>past</i> is a set of events with logical
time \(t\) or less is a consistent cut.

Determining global snapshots using logical times is straightforward.

<!--------------------------------------------->
<p class="w3-text-red">
<i>Concepts</i>:
Timelines -> causality graphs -> logical and vector times -> consistent cuts ->
global snapshots.



<h4 class="w3-text-teal">Next</h4>
Next either look at two examples
 -- <a href="TerminationDetectionNew.html">termination</a> and
<a href="DatabaseDeadlockDetection.html">database deadlock</a>
detection --
of snapshots or
move to the next topic, 
<a href="LogicalClocksNew.html">logical clocks</a>.







<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
