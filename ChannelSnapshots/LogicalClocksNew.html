<title>ChannelSnapshots/LogicalClocks.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  
    <!--------------------------------------------------------->
<h2 class="w3-text-teal">Logical Clocks</h2>

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/ChannelSnapshots/ChannelSnapshots.html">
  GlobalSnapshots.
  </a>
  


  <p class="w3-text-red">
  We use the following heuristic for solving many
  problems: Design algorithms assuming that local clocks are perfectly
  synchronized, and then
  determine whether the same algorithms can be used with
  unsynchronized clocks.
  </p>

  <p>
  
  Logical clocks are local clocks that can be used in many algorithms
  as they though the clocks are synchronized even though they
  are not.
  </p>

If every agent had a perfect clock, then a global state of the system
  could be obtained easily. Each agent records its state at a
  specified time \(T\), and each agent records the state of an
  incoming channel as the sequence of messages sent before or at \(T\) and
  received after \(T\).

  <p>
  Local clocks are not perfect; they drift
  apart from each other. Later we will describe algorithms that reduce
  drift among local clocks. The algorithms do not, however, guarantee
  that local clocks are perfectly synchronized.

  <p>
A logical clock algorithm is one in which each agent assigns a
number \(t(e)\), called
a timestamp, to each event \(e\) in its trajectory.
The timestamp of an event is
  called the logical time at the event.
  The logical time of an event can be used as though it is the real
  time for some problems.

<p>
  <i>Logical clocks don't change the underlying computation.</i> For example,
  we can add logical clocks to an algorithm that manages how files are
  shared in a distributed system. The algorithm for file-sharing
  remains unchanged when we superpose logical clocks on top of the
  algorithm. We can, however, use logical clocks for monitoring the
  underlying computation. For instance, logical clocks can be used to
  determine if the file-sharing algorithm is deadlocked.

 <h3 class="w3-text-teal">Specification of Logical Clocks</h3>
The specification of the algorithm is as follows.
For all
\(t\), let <i>past(t)</i> be the set of events with timestamps of \(t\) or
less, and let <i>future(t)</i> be the set of events with timestamps
greater than \(t\).

<hr class="new2">
<h4 style="color:blue;">
For all \(t\), the cut \([past(t), future(t)]\)
must be a consistent cut.
</h4>
  <hr class="new2">

  <p>
  An equivalent definition is that if an event \(e\) depends on an
  event \(e'\) in the trajectory (i.e., there is a path from \(e'\) to
  \(e\)) then \(t(e) > t(e')\).
  

<h4 style="color:red;">Examples of Consistent Cut based on
Timestamps</h4>

The figure below illustrates a consistent cut obtained from timestamps.
It shows a set of timestamps in a timeline diagram with
agents \(A, B, D\), and with one channel from each agent to every
other agent. Timestamps are shown as integers inside the circles
representing events. Initial events have timestamps of 0.

<p>

The first event on agent \(A\) after the initial event is an internal
event. Its timestamp can be any value greater than 0; the diagram
shows a timestamp of 1.  In this event, agent \(A\) sends a message to
agent \(B\); the message is also given the same timestamp as the
event, i.e. a timestamp of 1.

<p>
The first event on agent \(D\), after the initial event, occurs when
\(D\) receives a message. This message has timestamp 1. The timestamp
for this event must be greater than 1 and greater than 0 (the
preceding event on the agent). In the diagram the timestamp is set to
2. Note that any value greater than 1 would be correct.


<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.011.jpeg" alt="Fig1" style="width:100%">
    <figcaption>Fig. 1: Consistent Cut based on Timestamps</figcaption>
</figure>

The diagram shows a cut <i>[past(2), future(2)]</i>.  Because all
edges are directed from lower- to higher-numbered timestamps, there is
no edge from <i>future(2)</i> to <i>past(2)</i>. And so the cut is
consistent.


Logical times satisfy the specification if and only
if:
<hr class="new2">
<h4 style="color:blue;">
Logical times satisfy the specification if and only
if:
<br>
For all edges \((e, e')\) in the timeline diagram:
\(t(e') > t(e)\).
</h4>
<hr class="new2">



<h4 class="w3-text-teal">Algorithm</h4>
An algorithm for assigning timestamps follows directly from the above
observation. 

<p>
<i>Timestamps of messages</i>:
Every message is assigned a timestamp by the sender of the message. 
An agent assigns a timestamp of
\(t(e)\) or greater to each message that it sends in event \(e\).

<p>
The timestamp of an initial event is arbitrary.
For any event \(e'\) on an agent, let \(e\) be the event
that immediately precedes \(e\) on that agent.
<ol>
  <li>
  For an internal event \(e'\) (i.e. an event in which no message is
  received), set \(t(e')\) to any value greater than \(t(e)\).
  </li>
  <li>
  For an event \(e'\) in which message with timestamp \(T\) is
  received, set \(t(e')\) to any value greater than
  \(\textrm{max}(t(e), T)\).
 </li>
</ol>

<h4 class="w3-text-teal">Using Logical Clocks to Determine Global
Snapshots</h4>
The state of an agent at a consistent cut is its state after past
events and before future events. Likewise,
the state of a channel is the sequence of messages sent in the past
and received in the future. So, the global snapshot corresponding to
any timestamp \(T\) can
be obtained in the following way:
<ol>
  <li>
  Each agent records its local state after an event with timestamp at most
  \(T\) and before an event with timestamp greater than \(T\).
  </li>
  <li>
  An agent starts recording the state of each of its incoming channels
  when the agent records its own state.  An agent stops the recording
  the state of an incoming channel when the agent receives a message
  on the channel where either:
  <ol>
    <li>
    the message has timestamp equal to \(T\), in which case this message
    is included in the recorded state of the channel, or
    </li>
    <li>
    the message has timestamp greater than \(T\), in which case this message
    is not included in the recorded state of the channel.
    </li>
</ol>

From the algorithm, it follows that an agent records the state of an
incoming channel as the sequence of messages sent in past events and
received in future events. This is the state of the channel at the
consistent cut specified by \(T\).


<h4 style="color:red;">Example of a Global Snapshot using Timestamps</h4>
The figure shows the global snapshot in which <i>past</i> events are
those with snapshots at most 2. Agent \(A\) records its local state as
its state after its event with timestamp 1 and before its event with
timestamp 3. Agent \(B\) records its local state as its state after
its event with timestamp 2 and before its event with timestamp 4.
Agent \(B\) records its local state as is its state after its event
with timestamp 2 and before its event with timestamp 3. The points in
the timeline at which the agents start recording their states are the
points at which the cut (the purple line) crosses the agent timelines.

<p>
Agent \(A\) starts recording the state of its incoming channel from
\(B\) when \(A\) records its own local state.  \(A\) stops recording
the state of this channel when it receives a message on the channel
with timestamp equal to 2, and this message is included in the state
of the channel. So, the state of this channel is recorded by agent
\(A\) as the single message with timestamp 2. In the diagram this is
the message that crosses the cut.



<h3 class="w3-text-teal">Vector Clocks</h3>
The logical clock algorithm ensures that if there is a path from an
event \(e\) to an event \(e'\) in the timeline diagram then \(t(e') >
t(e)\); however, the converse isn't necessarily true.
The vector clock algorithm assigns a timestamp to each event where the
timestamp is a vector with an element for each agent in the
system.

<hr class="new2">
<h4 style="color:blue;">
The vector clock
algorithm ensures that \(t(e') > t(e)\) if and <i>only if</i> there is 
a path from \(e\) to \(e'\).
</h4>
<hr class="new2">


<p>
Let there be \(N\) agents in the system indexed \(0 \leq j <
N\). Let \(I_{j}\) be unit vector in direction \(j\), i.e. \(I_{j}\)
is  a vector of 
zeroes except that \(I_{j}[j] = 1\). A timestamp for an event \(e'\)
on agent \(j\) is computed in the following way. Initial timestamps
are zero vectors.
<ol>
  <li>
  For an internal event: \(t(e') = t(e) + I_{j}\)
  </li>
  <li>
  For an event in which a message with timestamp \(T\) is received:
  \(t(e') = max(t(e), t(M)) + I_{j}\)
  </li>
</ol>

<h4 style="color:red;">Example of Vector Clocks</h4>
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.012.jpeg" alt="Fig2" style="width:100%">
    <figcaption>Fig. 2: Example of Vector Clocks</figcaption>
</figure>
The figure shows both scalar and vector timestamps. Scalar
timestamps are shown inside the circles representing events while
vector timestamps are shown just outside the circles.
<p>
For example, there is a path from the event with timestamp \([1, 0,
1]\) to the event with timestamp \([2, 0, 1]\) whereas there is no
path between events with timestamps \([2, 0, 1]\) and \([1, 1, 2]\).

<h4 class="w3-text-teal">Proof of Correctness of Vector Clocks</h4>
We will prove that for all events \(e, e'\) if \(t'(e) \leq t(e)\)
then there is a path from \(e'\) to 
\(e\). (If \(t'(e) = t(e)\) then \(e' = e\) and there is a
zero-length path from \(e\) to itself.)
The proof is based on the following observations that are easily
proved.
<ol>
  <li>
  For all events \(e\) and all agents \(j\): There exists a path to
  \(e\) from the \(i\)-th event on agent \(j\) for all \(i \leq
  t(e)_{j}\).
  </li>
  <li>
  If \(e\) is at agent \(j\) then \(e\) is the
  \(t(e)_{j}\)-th event on agent \(j\).
  </li>
</ol>
<p>
From observation 2, \(e'\) is the \(t(e')_{j}\)-th on an agent \(j\).
From observation 1, there is a path to \(e\) from the \(i\)-th event on
agent \(j\) for \(i \leq t(e)_{j}\).
So, there is a path from \(e'\) to \(e\) because \(t(e')_{j} \leq t(e)_{j}\).

<p style="color:red;">Example of Proof Steps</p>
As an example of observation 1, consider the 5-th event in figure 2; this event has
timestamp \([3, 1, 1]\). 
There are paths to this event from the zeroth, first, second, and third
events on agent 0, and from the zero-th and first events on agent
\(1\), and from the zero-th and first
events on agent \(2\).
<p>
As an example of observation 2, the event with timestamp \([1, 1, 2]\)
is the second event on agent \(2\).


<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
