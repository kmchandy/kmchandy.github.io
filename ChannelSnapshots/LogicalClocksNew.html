<title>ChannelSnapshots/LogicalClocksNew.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  
    <!--------------------------------------------------------->
<h1 class="w3-text-teal">Local Clocks and Logical Time</h1>

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/ChannelSnapshots/ChannelSnapshots.html">
  GlobalSnapshots.
  </a>
  </p>
  <h3 class="w3-text-teal">Local clocks</h3>
  Each agent can maintain its own local clock. If local clocks of
  all agents are perfectly synchronized then all agents have access to
  a <i>common global variable: the time</i>. With perfect synchrony, every
  agent \(A\) has access to the values of the local clocks of every agent
  because these values are the same as \(A\)'s clock.
  Developing algorithms in which all agents have access to a common
  time is easier than dealing with drifting clocks.
  Later, we discuss methods that reduce the drift of local clocks from
  each other; however these methods do not guarantee synchrony.

  <h4 class="w3-text-teal">Determining global state with synchronized
  clocks</h4>
  Let's look
  at an example of how access to a common time simplifies algorithm
  development. How can agents cooperate to determine a global state of
  the system?

  <p>
  The global state at time \(T\) consists of the states of agents and
  channels at \(T\).
  The state of a channel at \(T\) is the sequence of messages in the
  channel at \(T\).
  The state at time \(T\) corresponds to
  a vertical cut of the system timeline at \(T\).

  <p>
  The global state can be computed in the following way.
  Each agent records its state at time \(T\).
  Messages are timestamped with the times that the messages are sent.
  A message with timestamp \(T\) that is received after time \(T\) is
  in the channel at \(T\)

  <h4 class="w3-text-teal">Determining a global state with clocks that
  drift</h4>
  Let's try to use the above algorithm with local clocks that may
  drift apart.
  A message sent when the sender's clock
  reads \(T\) may be received when the receiver's clock reads a
  value earlier than \(T\). In this case, a cut of the timeline at
  points where local clocks read \(T\) is inconsistent --- a
  message from the future (clock reads \(T\)) is received in the past
  (clock reads less than \(T\)). So, agent and channel states obtained
  in this way may not represent a global state.


<p>
The algorithm failed because a message sent in the future (as defined
by local clocks) was received in the past.
  What steps can prevent a message with timestamp
  \(T\) from being received when the receiver's clock is at a value
  less than \(T\)? The obvious way is for the receiver to move its clock forward to a
  value greater than \(T\) when it receives a message timestamped
\(T\). The rules of the algorithm are summarized next.


<h3 class="w3-text-teal">The Logical Time Algorithm for setting Local Clocks</h3>
Let \(t(e)\) be the value of the local clock at the agent on which
event \(e\) occurs.

<ol>
  <li>
  For events \(e'\) followed by \(e\) at an agent, the
  agent sets \(t(e)\) to any value greater than \(t(e')\).
  </li>
  
  <li>
When a message is sent in an event \(e\), the message is assigned
  timestamp \(t(e)\).
  </li>
  <li>
  If an agent receives a message with timestamp \(T\) in an event
  \(e\) then the agent sets \(t(e)\) to any value greater than \(T\).
  </li>
</ol>

The algorithm satisfies the property:

<hr class="new2">
<p style="color:blue;">
Logical Time Property
<p style="color:blue;">
For every edge \((e', e)\) in the causality graph
  of a computation:
\(t(e') < t(e)\).
</p>
<hr class="new2">
The proof is straightforward

<h4 style="color:red;">Example of Logical Time</h4>

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.001.jpeg" alt="Fig1" style="width:100%">
    <figcaption>Fig. 1: Local Clock Times</figcaption>
</figure>
The figure shows a timeline diagram with
agents \(A, B, D\), and with one channel from each agent to every
other agent.
Messages are shown as red arrows.
The diagram doesn't show arrows from each event to the next event on
    the same agent; each horizontal edge has an implicit direction
from left to right.
<p>
Local clock values are shown as integers inside the circles
representing events.
For example, events 0, 1, and 2 on the timeline for agent B occur when
    B's local clock has value 0, 2 and 4, respectively.

<h4 class="w3-text-teal">Events in Ascending Logical Time are
Topological Sorts</h4>
<hr class="new2">
<p style="color:blue;">
Theorem: Given a computation specified by an initial state and event sequence
\(X\) there exists computations with the same initial state and all
permutations \(Y\) of \(X\) where
<i>events in \(Y\) are in ascending order of
logical times</i>,
i.e., if \(t(e') < t(e)\) then \(e'\) appears before \(e\) in \(Y\)  .
</p>
<hr class="new2">
This result follows from the property of topological sorts.


<h4 style="color:red;">Example: Events Occurring in Logical Time</h4>
The next figure shows a timeline with the same events as in figure 1
but with events appearing at their logical times --- all events with
logical time \(T\) appear at point \(T\) in the timeline.
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.004.jpeg" alt="Fig4" style="width:100%">
    <figcaption>Fig. 2: Events Occur at their Logical Times</figcaption>
</figure>
<p>
A heuristic for designing distributed algorithms is to treat logical
time as though it were real time, and to think of timelines such as
those in the above figure.
<p>
Events in a computation occur in a sequence.
We break ties in logical time by
using lexicographic ordering with an order among agents.
For example, agents are ordered \(A, B, D\), and logical
times are pairs \(T, agent\_id\) where \(T\) is a real number.
Then
\((T, A) < (T, B) < (T, D)\).
<p>
In the diagram, the event with local time \(1\) on agent \(A\)
occurs before the event with local time \(1\) on agent \(D\)
in the event sequence.


<h3 class="w3-text-teal">A Cut at a Logical Time is Consistent</h3>
Assume that local clocks increase continuously. For
events \(e'\) followed by \(e\) at an agent \(A\), assume that the
\(A\)'s local clock increases continuously from \(t(e')\) at event
\(e'\) to \(t(e)\) at event \(e\).
A cut of the timeline at time \(t\) is the cut when each agent's local
clock is at \(t\).
Next we show that the cut at any time \(t\) is consistent.
<p>
We give two examples of timelines. In the first, local clock values
match real time, and in the second they do not.



<h4 style="color:red;">Examples: Instant when Events Occur in Logical Time</h4>
<p>
The figure below shows an event sequence in ascending order of logical
time. The figure illustrates the global state at time 2.8 on this timeline.
The vertical line represents a point in the trajectory at time 2.8.
The time of 2.8 is a helpful fiction --- no event occurred at logical
time 2.8.
The point at which a local clock reads 2.8 is immaterial --- all that
matters is that clocks move forward.

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.005.jpeg"
    alt="Fig5" style="width:100%"> 
    <figcaption>Fig. 3: Global Snapshot at 2.8 when
    Events occur in Logical Time </figcaption>
</figure>

<h4 style="color:red;">Examples: Cut when Events are not in Logical Time</h4>
The next figure shows an event sequence that is not in ascending order
of logical time, and it illustrates the global state at <i>logical
time</i> 2.8.

<p>
The vertical (upper figure) and curvilinear (lower figure) lines at time and
logical time 2.8 represent the cases when events
are, and are not, (respectively), in ascending order of logical time.

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.006.jpeg"
    alt="Fig6" style="width:100%"> 
    <figcaption>Fig. 4: Cut at Logical Time 2.8</figcaption>
</figure>


<h5 class="w3-text-teal">Theorem about Consistent Cuts and Logical
Times</h5>
For a computation, and for all \(T\), define \(past(T)\) as the set of
events with logical clock values that are at most
\(T\), and define \(future(T)\) as the set of
events with logical clock values that exceed \(T\).

<p>
For all \(T: [past(T), future(T)]\) is a consistent cut.
<p>

<p class="w3-text-teal">Proof</p>
There exists a topological sort of the causality graph in which events
in \(past(T)\) appear before events in \(future(T)\).



<h2 class="w3-text-teal">Heuristic: Use Time in Algorithms</h2>
A heuristic that helps in designing distributed algorithms is to
first design an algorithm for a system in which local clocks are
perfectly accurate and then modify the algorithm by using
<i>logical time</i> in place of real time to deal with clock
inaccuracy. 
<p>
Let's use this strategy to develop a global snapshot algorithm.


<h4 class="w3-text-teal">Global Snapshots using Logical Time</h4>

<p class="w3-text-teal">First step: global snapshot algorithm assuming
local clocks are perfect.</p>
Each agent records its state at time \(T\).
The timestamp of a message is the sender's time when the message is
sent.
An agent records the state of an
incoming channel as the sequence of messages that the agent receives with
timestamps of \(T\) or less that the agent receives when the agent's
time is greater than \(T\). 


<p class="w3-text-teal">Second step: Use logical time instead of real time</p> 
<p>
Each agent records its state at <i>logical</i> time \(T\). An agent records the state of an
incoming channel as the sequence of messages that the agent receives with
timestamps of \(T\) or less that the agent receives at time greater
than <i>logical</i> time \(T\).

<p>
The recorded global state is a collection of the states of agents and
channels that are recorded separately by each of the agents.
There are many ways to collate local information; the simplest is to
send all the local information to a central site.
We postpone discussion of algorithms for collating local information.

<h3 class="w3-text-teal">Heartbeats, NTP and Sequences of
Snapshots</h3>

<h4 class="w3-text-teal">Reference Times: NTP and PTP</h4>
Local clocks may drift away from a true or reference time.
We assume that all clocks tick forward: later clock readings are
always larger than earlier clock readings.
Many distributed systems
synchronize their local clocks to a standard reference clock. 
Logical time may, however, have no relation to real time.
Next, we discuss methods that reduce the drift of local clocks from a
reference time and also 
ensure that local clock times satisfy the logical
time specification.

<h4 class="w3-text-teal">Logical Times and Reducing Clock Drift</h4>
Agents call 
<a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">
NTP (Network Time Protocol)</a> servers to get the reference time.
Agents adapt local clock settings to match NTP.
Timing accuracies of milliseconds can be otained using
NTP, and <a href="https://en.wikipedia.org/wiki/Precision_Time_Protocol">
Precision Time Protocols (PTP)</a> deliver accuracy in the microsecond range.

<p>
We ensure that local clock times satisfy the logical time
specification using the logical time algorithm given earlier.
The steps of the algorithm are given here, again, for convenience.
The logical time of an event is
the time on the clock of the agent on which the event occurs.
Each message is assigned a timestamp which is the time of the sender's
clock when the message is sent.
When an agent receives a message with timestamp \(T\), if the
receiver's clock is at a value less than or equal to \(T\) then the
receiver moves its clock forward to a value greater than \(T\).


<h4 class="w3-text-teal">Heartbeat Messages</h4>
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">
Heartbeat messages
</a>
are used in many distributed systems.
Each agent periodically sends a heartbeat message, with the sender's
time, on each of its outgoing channels.
Heartbeat messages reduce clock drift among agents.
Agents can record global states at heartbeats by using their local
clocks, as described earlier.
The sequence of global states, recorded in successive heartbeats, is
useful in many algorithms. 


<h4 class="w3-text-teal">Properties of local clocks</h4>
Local clocks that use these algorithms have valuable properties:
<ol>
  <li>
  <i>Consistent cuts at \(t\)</i>. For all \(t\), the cut when each
  agent's local clock is at \(t\) is a
  consistent cut.
  Therefore, the global state when local clocks are at \(t\) is a
  state that could have occurred in the computation.
  </li>
  <li>
  <i>Clocks tick forward</i>. For any \(t\) there is a point in the computation at which the
  clocks of all agents have times greater than \(t\).
  </li>
</ol>
<p>
Local clocks do not have to use reference times such as NTP to have
these properties. Synchronization with reference time reduces the
likelihood that an agent will need to move its local clock forward
so that the receiver's time when a message is received is later than
the sender's time when a message is sent. Reference clocks are widely
used in distributed systems, and we might as well use them in
combination with logical time requirements.

<h4 class="w3-text-teal">Example Applications</h4>
The operating system of a distributed system can use local times to detect important
conditions such as termination and deadlock of a computation.
The operating system merely checks the snapshots recorded at each
heartbeat to determine if the snapshot exhibits the specified
property.
If a snapshot shows that the computation has terminated then the
computation has indeed terminated.
If the snapshot doesn't show that the computation has terminated then
check the snapshot at the next heartbeat.






<h3 class="w3-text-teal">Vector Clocks</h3>
The logical clock
algorithm ensures that if there  is 
a path from event \(e'\) to event \(e\) in the timeline then 
\(t(e') < t(e)\);
however, the converse is not necessarily true, and
vector clocks address the converse.

<hr class="new2">
<h5 style="color:blue;">
Vector time specification
</h5>
<p>
<h5 style="color:blue;">
\(t(e') < t(e)\) if and <i>only if</i> there is 
a path from \(e'\) to \(e\).
</h5>
<hr class="new2">


<p>
A vector time for an event \(e\) is a vector \(V(e)\) of length \(N\)
wher \(N\) is the number of agents in the system.
Let \(V_{j}(e)\) be the \(j\)-th element of vector \(V(e)\).

<p>
Each agent has a local clock. For an event \(e\) on the \(j\)-th
agent let \(t_{j}(e)\) be the time on the
\(j\)-th agent's clock when \(e\) occurs.
The only requirement of local clocks is that they tick forward. So
for all events \(e', e\) at the \(j\)-th agent, where \(e\) occurs
after \(e'\):
\(t_{j}(e') < t_{j}(e)\).

<p>
\(V(e)\) is defined as follows. For all agents \(j\) and events \(e\):
\(V_{j}(e) = t_{j}(e')\)
<p>
where \(e'\) be the latest event on the timeline of the \(j\)-th agent
such that there is a path from \(e'\) to \(e\).
If there is no path from events at the \(j\)-th agent to \(e\) then
\(V_{j}(e) = 0\).

<h4 style="color:red;">Example of Vector Clocks</h4>
<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.007.jpeg" alt="Fig7" style="width:100%">
    <figcaption>Fig. 7: Example of Vector Clocks</figcaption>
</figure>
Local times are shown inside the circles representing events while
vector timestamps are shown outside the circles.
<p>
There is a path (with zero hops) from the event on agent \(0\) with
local time \(1\) to the same event with vector time \([1, 0, 0]\).
there are no paths from events on agents 1 and 2 to this event.

<p>
Let's look at event \(e\) with vector timestamp \([2, 2, 1]\). There is a
path to \(e\) from the event on agent 0 with local time \(2\).
There is a path to \(e\) from the same event on agent 1 with local
time \(2\).
Likewise, there is a path to \(e\) from the event on agent 2 with local
time \(1\).

<h4 class="w3-text-teal">Algorithm for Vector Clocks</h4>
The proof that vector times, as defined above, satisfies the vector
time specification is straightforward. The algorithm for assigning
vector times to events is the same as that for scalar times except
that operations are on vectors. For example, the timestamp of a
message is the vector time --- as opposed to the scalar time --- of
the event in which the message is sent.

<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
