
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  
    <!--------------------------------------------------------->
  <h2 class="w3-text-teal">Detecting Database Deadlocks</h2>

  
  <!------------------------------------------------------------------->
  <p class="w3-text-red">
  A database deadlock occurs when the system has a cycle of agents
  where each agent in the cycle remains waiting forever for a
  resource held and required by the next agent in the cycle.

  A database deadlock detection algorithm is executed by the operating
  system to determine whether there exists a cycle of deadlocked agents.

  Detection algorithms are based on global snapshots.
  </p>
  
  <h3 class="w3-text-teal">The Problem</h3>

  <p>
  Agents in a system share a set of files.
  A file can be accessed by at most one agent at a time.
    <p>
    An agent \(u\) is in one of the following states:
    <ol>
      <li>
      State 1: Executing without holding shared files. It may remain in this
  state for ever or it transits to state 2.
      </li>
      <li>
      State 2: Waiting to acquire a nonempty set \(u.needs\) of
      shared files. The agent remains in this state until it holds all
  the files in \(u.needs\) at which point in transits to state 3.
      </li>
      <li>
      State 3: Executing while holding all files in
      \(u.needs\). It remains in this state for only finite time after
  which it transits to state 1.
      </li>
    </ol>


    
    
    <figure>
    <img
    src="DatabaseDeadlockDetection/DatabaseDeadlockDetection.001.jpeg"
    alt="Fig1" style="width:100%">
    <figcaption>Fig.1 - The Life Cycle of an Agent</figcaption>
    </figure>

<h3 class="w3-text-teal">Deadlock</h3>
A cycle of waiting agents is in a deadlock if each agent in the cycle is waiting to
acquire a file that is held and needed by the next agent in the cycle.

    <h3  style="color:red;">Example</h3>
    In the example, a file is identified by its color.
A system has one red, one blue and one green file.
Agents \(x\), \(y\) and \(z\) are deadlocked in the following state.
    Agent \(x\) needs the red and blue file; it is
holding the red file and is waiting
    to acquire the blue file,

    Agent \(y\) needs the blue and green files; it holds the blue file and is waiting
    to acquire the green file.

    Agent \(z\) needs the green and red files; it holds the green file and is waiting
    to acquire the red file.
    
    <figure>
  <img
    src="DatabaseDeadlockDetection/DatabaseDeadlockDetection.002.jpeg"
    alt="Fig2" style="width:100%">
  <figcaption>Fig.2 - An Example of a Deadlock</figcaption>
</figure>

    <h5 class="w3-text-teal">Variables</h5>
Associated with each agent \(v\) is a set of files <i>v.needs</i> that
\(v\) must hold to continue execution and a set of files <i>v.holds</i> that \(v\)
has.

The set of files that \(v\) needs to continue executing is
<i>v.waits</i> which is the set that \(v\) needs but does not
    hold.

    In the example \(z.needs = \{red, green\}\), \(z.holds =
    \{green\}\), and \(z.waits = \{red\}\)

    <p>
    An agent \(v\) is executing without shared files when \(v.needs\) is the
    empty set.
    Agent \(v\) transits from executing without shared files to waiting
    when \(v.needs\) becomes nonempty; if \(v.waits\) is empty then
    \(v\) transits to the state in which it is executing while holding
    the files in \(v.needs\).
    If \(v.waits\) is not empty then \(v\) waits until \(v.waits\)
    becomes nonempty.
 
    <!----------------------------------------------------------------------------->
    <h3 class="w3-text-teal">How Should You Approach the Problem?</h3>
    <!----------------------------------------------------------------------------->


    <h4 class="w3-text-teal">General Method: Monitor System with Repeated Snapshots</h4>

    <p>
    In the general method, the OS  monitors a system by taking repeated global
    snapshots.
    If a global snapshot is a state in which there is a deadlock then
    there is indeed a deadlock.
    And if a computation is deadlocked then repeated snapshots ensure
    that a snapshot is taken after computation deadlocks.

    <h4 class="w3-text-teal">An Alternate Method</h4>
    <p> Algorithms that use global snapshots operate in two phases:
    (1) obtain a global snapshot, and (2) analyze the static structure of
a global snapshot.  For deadlock detection, the problem is to detect
cycles in a (static) graph obtained by the snapshot.

    Next, we describe an algorithm that combines the two phases of the
global snapshot algorithm into a single phase.

We begin by describing an algorithm by which an agent determines if it
is part of a cycle.




<h5 class="w3-text-teal">
A Distributed Algorithm to Determine if an Agent is in a Cycle
</h5>
Next we describe an algorithm by which an agent \(u\) determines if it is
part of a cycle.

A message is a list of vertices that represents a cycle-free path from the
initiator.

The initiator \(u\) sends a message \([u]\) -- a list consisting of
the single element \(u\) on each of its output channels.

<p>
When an agent, other than the initiator, receives a message it sends
messages on its output 
channels if it has not already done so.

When an agent \(w\) gets a message \([u, \ldots, v]\) it sends the
message \([u, \ldots, v, w]\) on each of its output channels.


If the initiator receives a message \([u, \ldots, v]\)  then the
initiator is part of the cycle \([u, \ldots, v, u]\).


<h5 class="w3-text-teal">Combining Cycle Detection and Snapshot
Algorithms</h5>


<p>
A marker, in the extension of the global snapshot algorithm, has
fields <i>m</i> has fields <i>m.waits</i> and <i>m.path</i>.
The field <i>m.path</i>
plays the same role as a message in the algorithm to detect cycles --
<i>m.path</i> is a path of waiting agents.
When an agent \(v\) sends a marker \(m\) it sets \(m.waits = v.waits\).

<p>
A waiting agent \(u\) initiates the
algorithm by taking its local snapshot (recording \(u.waits\)) and
sending markers \(m\) on its output channels where \(m.waits = u.waits\).
Algorithms initiated by different agents are disambiguated by the
identity of the initiator which is the first vertex in \(m.path\).



<p>
If an agent \(v\) receives a marker \(m\) while \(v\) is waiting and \(v\) has
not sent markers already then \(v\) carries out the following steps.
If there is an element common to both \(m.waits\) and \(v.waits\) then
\(v\) takes its local snapshot and
sends a marker \(m'\) on each of its outgoing channels where
\(m'.waits = v.waits\).


<p>
If the initiator \(u\) receives a marker \(m\) where there is an
element common to \(m.waits\) and the recorded snapshot value
\(u.waits\), then \(u\) is part of the deadlocked cycle specified by
the path \(m.path\). 


<p class="w3-text-teal">Proof of correctness</p>
The algorithm is essentially the same as the global snapshot
algorithm, and the proof is similar to that of the
snapshot algorithm.




<h5 style="color:red;">Example</h5>
The example shows the deadlock detection algorithm for the cycle of
waiting processes shown in figure 2.

<p>
Agent \(x\) initiates the algorithm when \(x\) is waiting
by sending a marker \(m\) where
\(m.waits\) is the set consisting of the blue file.

<p>
When \(y\) receives the message, \(y\) is waiting and
\(y\) is holding a file that is in \(m.waits\) and that \(y\) needs; so,
\(y\) sends markers \(m'\) with a waits field that contains the green
file.

<p>
When \(z\) receives \(m'\), \(z\) is waiting, and
\(z\) is holding a file that is in \(m'.waits\) and that \(z\) needs;
so \(z\) sends markers \(m''\) with a waits field that has the red
file.

<p>
When \(x\) receives \(m''\), \(x\) detects deadlock because \(x\) is
waiting and there is a file in the \(m''.waits\) that
\(x\) holds and needs.

<p class="w3-text-teal">Optimization</p>
File managers keep track of which agent holds a given file.
So, an agent waiting for a file sends markers only to the agent
holding that file instead of sending markers to all agents.



<pre>
finished = False

start()
def receive(path, sender):
   if not finished:
       path.append(my_id)
       for receiver in successor_list:
           send(path, receiver)
       finished = True
</pre>



<p>

The algorithm for the initiator is given below.

<pre>
finished = False
path = [my_id]
for receiver in successor_list:
   send(path, receiver)

start()
def receive(path, sender):
   if not finished:
      path.append(my_id)
      print(path)
      finished = True
</pre>

<pre>
finished = False

start()
def receive(message, sender):
   waits = needs - holds
   waiting = (waits != {})
   if message.isinstance(Marker) and waiting and not finished:
      if message.waits & holds & needs:
         extended_path = message.path.append(my_id)
         new_message = Marker(waits, extended_path)
         for receiver in successors:
            send(new_message, receiver)
</pre>
   





<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
