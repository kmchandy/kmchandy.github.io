<title>ChannelSnapshots/PartiallySynchronousAlgorithms.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


    <!--------------------------------------------------------->
    <h2 class="w3-text-teal">Partially Synchronous Algorithms</h2>
    
  In this section we describe a framework that allows us
  to reason about the
  correctness of distributed algorithms assuming that
  agents operate in lock step.
  Synchronous algorithms can have simpler proofs than asynchronous
  algorithms.

  <p>
  The central idea is a <i>sync clock</i>, which is a modification of a
  logical clock.
  Sync and logical clocks assign timestamps to events in the same
  way: the timestamp of an event is the value of 
  the clock when the event occurs.
  Timestamps are a total order; we use integers or pairs (integer,
  process id) as timestamps, where process ids are used to break
  ties.

  <p>
  Sync clocks do not tick backwards; so, the timestamp of a later event at
  an agent is greater than or equal to the timestamp of an earlier
  event at the same agent.
  With logical clocks, the timestamp of a later event at an agent is
  strictly greater than the timestamp of an earlier event at the same
  agent.
  


  <p>
  We use logical and sync clocks to partition the set of
  events in a trajectory 
  into <i>a future</i> and <i>a past</i> at a time \(T\).
  Future events at  \(T\) are
  events with
  timestamps greater than \(T\). Past events at 
  \(T\) are events with timestamp \(T\) or less.
  <h4 class="w3-text-teal">
  No message from future to past. 
  </h4>
  Sync and logical clocks share the following property: 
  For all \(T\), there is no message sent in an event with timestamp
  greater than \(T\) that is received in an event with timestamp of
  \(T\) or less.
  
  <p class="w3-text-teal">
  Consequence of no message from future to past. 
  </p>
  A key consequence of this property is as follows.
  Let \(X\) be a trajectory of a system that starts in a state \(S\)
  and ends in a state \(S'\). Any permutation \(Y\) of the sequence of
  events in \(X\) where each agent's timeline is the same in \(X\) and
  \(Y\), and events in \(Y\) appear in increasing
  order of timestamps, is also a trajectory of the system that starts in
  \(S\) and ends in \(S'\).


  <h4 class="w3-text-teal">
  Additional sync clock property:
  No message from past to future
  </h4>
  <hr class="new2">
  <p style="color:blue;">
  A sync clock has the
  additional property: for all \(T\)  there is no message sent in an
  event with a 
  timestamp \(T\) or less that is received in an event with
  timestamp greater than \(T\). 
  </p>
  <hr class="new2">

<p>
Let \(Y\) be a permutation  of the sequence of events \(X\) in a
trajectory where events in \(Y\) are in increasing order of
timestamps. We partition the set of events in \(Y\) into subsets
called <i>epochs</i> where all events in an epoch have the same
timestamp. The sync clock property that there are no messages from the
past to the future implies that:

<p>
<i>All messages sent in an epoch are received in the same
epoch.</i>
</p>
<p>
So, we can analyze a trajectory as a sequence of epochs where
all channels are empty at the start and end of each epoch.
We can prove properties of a trajectory by analyzing state transitions
where a transition is from the state at the start of an epoch to the
state at the start of the next epoch.
<p>
<i>
Transitions between the starts of successive epochs deal
only with states of agents because channels are empty at these points.
</i>


  
<h4 class="w3-text-teal">Algorithm that Implements Sync Clocks</h4>
Next we describe an algorithm that implements sync clocks and later
discuss the similarities and differences between sync and logical
clocks.

<p>
We associate
<ol>
  <li>
  a local variable <code>P.t</code> with each agent
  <code>P</code>,
  </li>
  <li>
  a field <code>M.t</code> with each message <code>M</code>, and 
  </li>
  <li>
  a value <code>e.t</code> with each event
  <code>e</code>
  </li>
</ol>
where <code>P.t, M.t, e.t</code> are timestamps.


<p>
   Let <code>d</code> be the event in which a message <code>M</code>
   is sent, and let <code>e</code> be the event in which
   <code>M</code> is received. Let
   <code>P</code> and <code>Q</code> be the agents that send and
receive <code>M</code>, respectively.

<p class="w3-text-teal">Sending a Message</p>
    When <code>P</code> sends <code>M</code>, it
    sets <code>M.t</code> and <code>d.t</code> to <code>P.t</code>.
So:
<br>
<code>d.t = M.t</code>
</p>

<p class="w3-text-teal">Message Arrival</p>
When message <code>M</code> arrives at agent <code>Q</code>:
<ol>
  <li>
  if <code>M.t</code> \(<\) <code>Q.t</code> then <code>Q</code>
   discards the message without processing it. The arrival of this
   message has no effect on the system other than the deletion of this
  message.
  </li>
  <li>
    If <code>M.t</code> \(\geq\) <code>Q.t</code> then <code>Q</code>
   may discard or receive <code>M</code> depending on the specific
  algorithm. 
    If <code>Q</code> receives <code>M</code> then
    <code>Q</code> sets <code>Q.t </code> to <code>M.t</code>
   and then
    executes event <code>e</code> that receives <code>M</code>.
  So:
  <br>
  <code>e.t = M.t</code>.
    </li>  
  </ol>
  From these rules, <code>d.t = M.t = e.t</code>. Therefore
   messages sent in an epoch are received in the same epoch.


    
<h3 class="w3-text-teal">Differences between Sync and Logical
  Clocks</h3>
Logical clocks do not change the underlying computation; events in the
  underlying computation remain unchanged. By contrast, sync clocks
  are an integral part of the underlying computation. When a message 
  <code>M</code> arrives at an agent <code>Q</code> the message is
  ignored if \(<code>M.t</code> < <code>Q.t</code>\) --- ignoring a
  message is a change in the underlying computation.

  <p>
  With logical clocks a message received in an event with timestamp
  <code>T</code> is sent in an event with timestamp less than <code>T</code>.
  By contrast, with sync clocks,  a message received in an event with
  timestamp <code>T</code> is sent in an event with the same timestamp
  <code>T</code>.

  <p>
  Logical and sync clocks are used for different purposes as we will
  see when study the Paxos algorithm.
  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->




</body>
</html>
