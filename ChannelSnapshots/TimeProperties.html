<title>ChannelSnapshots/PartiallySynchronousAlgorithms.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


    <!--------------------------------------------------------->
    <h2 class="w3-text-teal">Trajectories as Sequences of Rounds</h2>
    
  In this section we consider distributed systems in
  which messages can get lost.
  We describe a framework that allows us
  to reason about distributed algorithms by analyzing
   trajectories consisting of sequences of rounds where all messages sent
  in a round are received in the same round.

  <p>
  The central idea is a <i>sync clock</i>, which is an extension of a
  logical clock. The time on a sync clock is called a sync time. A
  sync time is a tuple [<i>round number, t</i>] where round number and t
  are total orders, which are integers in the following examples.

  <p>
  A sync clock is a logical clock with the following additional
  requirement.
  <hr class="new2">
  <h5 style="color:blue;">
  A message sent in a round that arrives at the receiver in a later
  round is discarded.
  </h5>
  <hr class="new2">
  A discarded message has exactly
  the same effect as a lost message.
  A lost message does not change the state of the system; a lost
  message is merely deleted from its channel.



  <h4 style="color:red;">Example: Trajectory as a sequence of rounds</h4>

The figure below illustrates a trajectory with agents A and B where
  the trajectory is partitioned into a sequence of rounds. Messages
  sent in a round are received in the same round.

<figure>
    <img src="../ChannelSnapshots/Timelines/Timelines.008.jpeg"
    alt="Fig8" style="width:100%"> 
    <figcaption>Fig. 8: Global Snapshot at Time 2.8 in a Synchronous System</figcaption>
</figure>

  <h1>============OLD=================</h1>

  
   <h2 class="w3-text-teal">Specification of Sync Clocks</h2>
Let \(t(e)\) be the sync time of event \(e\).
<hr class="new2">
  <h5 style="color:blue;">
<ol>
  <li>
If an event \(e\) depends on an
  event \(e'\) in the trajectory --- i.e. if there is a path from
  \(e'\) to \(e\) --- then \(t(e') \leq t(e)\), and
  </li>
  <li>
  The event \(e\) in which a message is sent and the event \(e'\) in
  which that message is received have the same sync times:
  \(t(e) = t(e')\).
  </li>
</ol>
</h5>
<hr class="new2">
The first part of the specification is the same as that for logical
clocks except that the strict inequality (\(<\)) for logical clocks is weakened to
(\(\leq\)) for sync clocks. The second part of the specification
allows us to use rounds.

  <p>
  <i>Sync times are an integral part of the computation</i> in
  contrast to logical times 
  that are a superposition on an underlying computation without
modifying the underlying computation.
Logical clocks merely add timestamps to events without changing the
  sequence of events. Sync clocks are used to add timestamps to events
  and doing so may change a trajectory.

  
<h4 class="w3-text-teal">Algorithm for Sync Clocks</h4>
As with logical clocks, we define the sync time \(A.t\) of an agent
\(A\) at a point in a
trajectory as the sync time of the last event at \(A\) before that
point.
An agent's sync time remains constant between events

<p>
Each
message \(M\) has a timestamp \(M.t\) which is the sync
time of the event in which the message is sent.

<p>
When a message \(M\) is received by an agent \(A\), let 
<ol>
  <li>
  If \(M.t < A.t\) then \(M\) is discarded, without \(A\) taking an
  action.
  A discarded message has the same effect as a lost message: The only
  change in the system state is that the message is deleted.
  </li>
  <li>
  If \(M.t \geq A.t\) then either \(A\) discards \(M\) or executes an
  event \(e\) where \(e.t = M.t\). Whether \(M\) is discarded or not
  depends on the particular algorithm.
  </li>
</ol>

<p>
<h5 class="w3-text-teal">Key Difference between Sync and Logical
  Clocks</h5>
Logical clocks do not change the underlying computation. Events in the
  underlying computation are not changed when logical times are
assigned to them. By contrast, sync times may
 change the underlying computation because messages are lost when they don't arrive
in the same round that they are sent.


  <p>
  Sync clocks do not tick backwards; so, the timestamp of a later event at
  an agent is greater than or equal to the timestamp of an earlier
  event at the same agent.
  With logical clocks, the timestamp of a later event at an agent is
  strictly greater than the timestamp of an earlier event at the same
  agent.
  


  <p>
  We use logical and sync clocks to partition the set of
  events in a trajectory 
  into <i>a future</i> and <i>a past</i> at a time \(T\).
  Future events at  \(T\) are
  events with
  timestamps greater than \(T\). Past events at 
  \(T\) are events with timestamp \(T\) or less.
  <h4 class="w3-text-teal">
  No message from future to past. 
  </h4>
  Sync and logical clocks share the following property: 
  For all \(T\), there is no message sent in an event with timestamp
  greater than \(T\) that is received in an event with timestamp of
  \(T\) or less.
  
  <p class="w3-text-teal">
  Consequence of no message from future to past. 
  </p>
  A key consequence of this property is as follows.
  Let \(X\) be a trajectory of a system that starts in a state \(S\)
  and ends in a state \(S'\). Any permutation \(Y\) of the sequence of
  events in \(X\) where each agent's timeline is the same in \(X\) and
  \(Y\), and events in \(Y\) appear in increasing
  order of timestamps, is also a trajectory of the system that starts in
  \(S\) and ends in \(S'\).


  <h4 class="w3-text-teal">
  Additional sync clock property:
  No message from past to future
  </h4>
  <hr class="new2">
  <p style="color:blue;">
  A sync clock has the
  additional property: for all \(T\)  there is no message sent in an
  event with a 
  timestamp \(T\) or less that is received in an event with
  timestamp greater than \(T\). 
  </p>
  <hr class="new2">

<p>
Let \(Y\) be a permutation  of the sequence of events \(X\) in a
trajectory where events in \(Y\) are in increasing order of
timestamps. We partition the set of events in \(Y\) into subsets
called <i>epochs</i> where all events in an epoch have the same
timestamp. The sync clock property that there are no messages from the
past to the future implies that:

<p>
<i>All messages sent in an epoch are received in the same
epoch.</i>
</p>
<p>
So, we can analyze a trajectory as a sequence of epochs where
all channels are empty at the start and end of each epoch.
We can prove properties of a trajectory by analyzing state transitions
where a transition is from the state at the start of an epoch to the
state at the start of the next epoch.
<p>
<i>
Transitions between the starts of successive epochs deal
only with states of agents because channels are empty at these points.
</i>


  
<h4 class="w3-text-teal">Algorithm that Implements Sync Clocks</h4>
Next we describe an algorithm that implements sync clocks and later
discuss the similarities and differences between sync and logical
clocks.

<p>
We associate
<ol>
  <li>
  a local variable <code>P.t</code> with each agent
  <code>P</code>,
  </li>
  <li>
  a field <code>M.t</code> with each message <code>M</code>, and 
  </li>
  <li>
  a value <code>e.t</code> with each event
  <code>e</code>
  </li>
</ol>
where <code>P.t, M.t, e.t</code> are timestamps.


<p>
   Let <code>d</code> be the event in which a message <code>M</code>
   is sent, and let <code>e</code> be the event in which
   <code>M</code> is received. Let
   <code>P</code> and <code>Q</code> be the agents that send and
receive <code>M</code>, respectively.

<p class="w3-text-teal">Sending a Message</p>
    When <code>P</code> sends <code>M</code>, it
    sets <code>M.t</code> and <code>d.t</code> to <code>P.t</code>.
So:
<br>
<code>d.t = M.t</code>
</p>

<p class="w3-text-teal">Message Arrival</p>
When message <code>M</code> arrives at agent <code>Q</code>:
<ol>
  <li>
  if <code>M.t</code> \(<\) <code>Q.t</code> then <code>Q</code>
   discards the message without processing it. The arrival of this
   message has no effect on the system other than the deletion of this
  message.
  </li>
  <li>
    If <code>M.t</code> \(\geq\) <code>Q.t</code> then <code>Q</code>
   may discard or receive <code>M</code> depending on the specific
  algorithm. 
    If <code>Q</code> receives <code>M</code> then
    <code>Q</code> sets <code>Q.t </code> to <code>M.t</code>
   and then
    executes event <code>e</code> that receives <code>M</code>.
  So:
  <br>
  <code>e.t = M.t</code>.
    </li>  
  </ol>
  From these rules, <code>d.t = M.t = e.t</code>. Therefore
   messages sent in an epoch are received in the same epoch.


    
<h3 class="w3-text-teal">Key Difference between Sync and Logical
  Clocks</h3>
Logical clocks do not change the underlying computation; events in the
  underlying computation remain unchanged. By contrast, sync clocks
  are an integral part of the underlying computation. When a message 
  <code>M</code> arrives at an agent <code>Q</code> the message is
  ignored if <code>M.t</code> \(<\) <code>Q.t</code> --- ignoring a
  message is a change in the underlying computation.

  <p>
  With logical clocks a message sent in an event with timestamp
  <code>T</code> is received in an event with timestamp greater than
  <code>T</code>. 
  By contrast, with sync clocks, a message sent in an event with
  is received in an event with the same timestamp.

  <p>
  Logical and sync clocks are used for different purposes as we will
  see when study the Paxos algorithm.
  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->




</body>
</html>
