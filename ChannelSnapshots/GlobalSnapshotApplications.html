<title>ChannelSnapshots/GlobalSnapshotApplications.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">



<!--------------------------------------------------------->
<h2 class="w3-text-teal">Applications of Global Snapshots</h2>
<!--------------------------------------------------------->


  <!------------------------------------------------------------------->
  
  <p class="w3-text-red">
  This webpage discusses a few of the many applications of global
  snapshots.

  <!-----START SECTION: Applications of Global Snapshots ------------>
  <div id="SECTION">

    <!-----START SECTION: Collecting Local Snapshots ------------>
  <div id="SECTION">
    <a name="CollectingLocalSnapshots"></a>

    
  <!---------------------------------------------------->
  <h4 class="w3-text-teal">Collecting Local Snapshots to form Global
  Snapshots</h4>

  <p>
  The global snapshot algorithm shows how each agent records its own
  local state and the states of its input channels.
  The global snapshot algorithm does not specify how
  local snapshots are put together to form a global
  snapshot.
  </p>
  
  <p>
  One way to collect local snapshots to form a global snapshot is to
  have an operating systems agent act 
  as an <i>observer.</i>
  Each agent sends its local snapshot to the observer which puts the
  local snapshots together to form the global snapshots.
  </p>
  
  <p>
  Successive global snapshot algorithms are disambiguated by using
  timestamps. 
  Messages sent in a global snapshot algorithm initiated by an agent
  <code>X</code> when the local clock at <code>X</code> is at
  <code>t</code> have a timestamp <code>(t, X)</code>.
  Snapshot algorithms initiated by the same agent at different times
  or by different agents have different timestamps.
    </p>
    </div>
        <!-----END SECTION: Collecting Local Snapshots ------------>


    <!-----START SECTION: System Monitoring ------------>
  <div id="SECTION">
    <a name="SystemMonitoring"></a>
    
<!---------------------------------------------------->

  <h3 class="w3-text-teal">System Monitoring</h3>
  <p>
  Systems are monitored by taking global snapshots repeatedly.
  System monitoring is based on the following observation.
  </p>

  <h5 class="w3-text-teal">Observation</h5>
  <p>
  Let \(S_{0}, S_{1}, S_{2}, \ldots, \) be the sequence of states
  of global snapshots recorded by the system.
  There exists a computation that visits each state \(S_{i}\) in order
of increasing \(i\).
</p>

  <p class="w3-text-teal">Proof</p>
  The proof is essentially the same as
<a href="../DISTRIBUTED_SYSTEM_MODELS/Timelines.html#TheoremComputationsAndCuts">
the proof of the theorem
</a>
"Computations and Cuts."
</p>

  <p>
  System monitoring has many applications.
 A system monitor takes global snapshots repeatedly and checks a
  sequence of snapshots to determine if 
some action is required.
Examples of actions are breaking a deadlock or rolling back steps of a
computation and restarting the computation from a snapshot.
    </p>
    </div>
    <!-----END SECTION: System Monitoring ------------>


        <!-----START SECTION: Rollback and Recovery ------------>
  <div id="SECTION">
    <a name="RollbackAndRecovery"></a>

    
<h4 class="w3-text-teal">Rollback and Recovery</h4>
<p>
Let \(S^{*}\) be the most recent snapshot recorded by a system monitor.
From,
<a href="../DISTRIBUTED_SYSTEM_MODELS/Timelines.html#TheoremComputationsAndCuts">
the theorem "Computations and Cuts"
</a>
there exists a computation that starts at the initial state and 
visits \(S^{*}\).
So, if an error is detected in a computation then the computation can be
restarted from \(S^{*}\) rather than rolling all the way back to the
initial state. 
</p>
       <!-----END SECTION: Rollback and Recovery ------------>



    <!-----START SECTION: Detecting Stable Predicates ------------>
  <div id="SECTION">
    <a name="DetectingStablePredicates"></a>
    
<h3 class="w3-text-teal">Detecting Stable Predicates</h3>
<p>
A <i>stable predicate</i> is a predicate with the following property: If the
predicate holds at any point in any computation then it continues to
hold forever thereafter in that computation. Equivalently, if a stable
predicate holds in a state \(s\) then it holds in all states reachable
from \(s\).
    </p>
    
<p>
Examples of stable predicates are: "The computation has
terminated," and "The computation is deadlocked."
If a computation has terminated at some point then it remains 
terminated.
Likewise if a computation has deadlocked then it remains deadlocked.
    </p>

    
<h5 class="w3-text-teal">Specification of Detection Algorithms</h5>
An algorithm to detect a stable property \(P\) has the following
specification.
<ol>
  <li>
  <i>No false positives</i>
  <p>
  If \(P\) holds when the algorithm is initiated then the algorithm
  detects that \(P\) holds.
  </li>
  <li>
  <i>No false negatives</i>
  <p>
  If the algorithm detects that \(P\) holds then \(P\) holds when the
  algorithm terminates.
  </li>
</ol>

For example, an algorithm to detect whether a computation has
deadlocked must satisfy the following conditions.
<ol>
  <li>
  If the computation is deadlocked when the detection algorithm is
  initiated then the detection algorithm must detect that the
  computation is deadlocked.
  </li>
  <li>
  If the detection algorithm detects that computation has deadlocked
  then computation must be deadlocked when the detection algorithm
  terminates. 
  </li>
</ol>


<h4 class="w3-text-teal">A Strategy for Developing Detection
Algorithms</h4>
<p>
A general strategy for developing algorithms that detect stable
properties is as follows.
The operating system takes repeated snapshots of the computation and
determines that the specified stable property holds if it holds in any
snapshot.
</p>

<p>
An alternative strategy is for agents to
exchange information about their local snapshots without sending the
information to an observer.
Distributed algorithms on local snapshots operate in two phases.
In the first phase a global snapshot algorithm is executed.
The local snapshot of each agent and its incoming channels are stored
locally, at the agent, without sending the information to observers.
</p>

<p>
In the second phase a distributed algorithm is executed to determine
if the local information stored at agents satisfies a specified global
property, such as "computation has deadlocked."
These algorithms are often distributed graph algorithms.
</p>

<p>
The development of algorithms that detect properties of states of computations
appear to be difficult because states in the
computation change while the detection algorithm is running.
The two-phases separate the problem into two simpler parts: In phase 1, record
local states during the computation using a global snapshot algorithm.
In phase 2 analyze the <i>static</i> local snapshots.
The algorithm in the second phase operates on unchanging data, and
this simplifies the design of the algorithm.
The two phases can be executed concurrently in many applications.
</p>
</div>
<!-----END SECTION: Detecting Stable Predicates ------------>
</div>

<!-----END SECTION: Applications of Global Snapshots ------------>


<h4 class="w3-text-teal">Next</h4>

<p>
A code skeleton of the algorithm and examples of the global snapshot
algorithm are provided
<a href="ChannelSnapshotsDetails.html">here</a>.

Next  
<a href="LogicalClocks.html">logical clocks</a>.

  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>



</body>
</html>
