<title>ChannelSnapshots/LogicalClocksNew.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  
  <!--------------------------------------------------------->
  <h2 class="w3-text-teal">Local Clocks and Logical Time</h2>
  <!--------------------------------------------------------->
  
  <p class="w3-text-red">
  A logical clock algorithm assigns a value, called the logical time,
  to each event in a computation so that all edges in the dataflow graph of
  the computation are from lower to higher logical times.

  </p>

  <h4 class="w3-text-teal">The Logical Time Property</h4>
The logical clock algorithm assigns a value \(t(e)\) to each event
  \(e\) of a computation so that:
<br>
  For all edges \((e, e')\) of the dataflow graph of the computation:
  \(t(e) < t(e')\). 


  <!---------------------------------------------------------->
  <h5 style="color:red;">Example: Logical Times of Events</h5>
  <!---------------------------------------------------------->
  
  Figure 1 shows the dataflow graph of a computation with agents
  \(A, B, C\) and an event sequence \([0, 1, 2, \ldots, ]\).

  The numbers inside the vertices show the position of the event in
  the sequence.

  The red numbers outside the events are logical times assigned to
  events.

  <p>
  Logical times are arbitrary provided
  every edge is directed from a lower to a higer logical time.
  <figure>
    <img src="Timelines/Timelines.001.jpeg"
  alt="Fig1" style="width:80%"> 
    <figcaption>Fig. 1: Logical Times of Events</figcaption>
  </figure>

  <!---------------------------------------------------------->  
  <hr class="new2">
  <h4 style="color:blue;">
  Consequences of the Logical Time Property
  </h4>
  <ol>
    <li>
    <p style="color:blue;">
    Sequences of events in increasing logical time are computations.
    </li>
    <li>
    <p style="color:blue;">
    For all \(t\), the state at the set of events with 
  logical times at most \(t\) is a global snapshot.
    </li>
 </ol>
 <hr class="new2">

 
 <p class="w3-text-teal">Proof</p>
 Sequences of events in increasing logical time are topological sorts
 of dataflow and are therefore computations.

 <p>
 All edges to events with logical time at most \(t\) are from events
 with logical time at most \(t\). So the set \(H\) of events with
 logical time at most \(t\) is input closed, and therefore the state
 at \(H\) is a global state.

 

<!-------------------------------------------------------->
<h4 class="w3-text-teal">A Logical Clock Algorithm</h4>
<!-------------------------------------------------------->
 Let \(t(e)\) be the logical time assigned to event \(e\).
 
 The following algorithm ensures the logical time property.

  <p>
Let \(e'\) be the event immediately preceding an event \(e\) at an
agent.
<ol>
  <li>
  A message sent in an event \(e\) is assigned a timestamp \(t(e)\).
  </li>
  <li>
  If the timestamp of the message received in an event \(e\) is \(T\) then set
  \(t(e)\) to be any value greater than max(t(e'), T).
  </li>
</ol>


 <!---------------------------------------------------------->
 <h4 class="w3-text-teal">Global Snapshot at Logical Time \(t\)</h4>
 <!---------------------------------------------------------->

<p class="w3-text-teal">
The state of an agent at logical time \(t\)
</p>

The state of an agent at logical time \(t\) is defined at its state
after events with logical time less than or equal to \(t\) and
before events with logical time greater than \(t\).

<p class="w3-text-teal">
The global snapshot at logical time \(t\)
</p>
A global snapshot at logical time \(t\) is the state of each agent and
channel at logical time \(t\).

The state of a channel at logical time \(t\) is the sequence of
 messages sent when the sender's logical time is at most \(t\) and
received when the receiver's logical time exceeds \(t\).

<p class="w3-text-teal">
Algorithm to record the global snapshot at logical time \(t\)
</p>
Each agent takes its local snapshot when its logical clock is at or before
\(t\).

An agent
records the state of an input channel as the sequence of
messages with timestamps atmost \(t\) that the agent
receives when its logical clock exceeds \(t\).
 

<!---------------------------------------------------------->
  <h5 style="color:red;">Example: Snapshot at Logical Time \(t\)</h5>
<!---------------------------------------------------------->
Figure 2 illustrates a global snapshot at logical time 6.5 of the
computation shown in figure 1.

The curved purple line separates events with logical time at most 6.5
from events with logical times that exceed 6.5.

<p>
The point at which the purple line cuts the timeline for agent \(A\)
can be thought of as the point in \(A\)'s computation at which the
logical time is 6.5.

This cut is at any point between events with logical times at most 6.5
and events greater than 6.5, i.e., any point between event numbers 3
and 5.

<figure>
    <img src="Timelines/Timelines.002.jpeg"
  alt="Fig2" style="width:80%"> 
    <figcaption>Fig. 2: States at Logical Time 6.5</figcaption>
</figure>

The states of agents and channels at logical time \(t = 6.5\) are
given by the labels of the edges that cut the purple line.




  <!--------------------------------------------->
  <h3 class="w3-text-teal">Logically Synchronized Clocks</h3>
<!--------------------------------------------->
Many distributed algorithms use clocks with the following two properties.

<ol>
  <li>
  <i>Clocks tick forward forever</i>: For all \(t\), there is a point in
  an infinite computation at which clocks of all agents exceed \(t\).
  </li>
  <li>
  <i>Global snapshots at \(t\)</i>: For all \(t\), local snapshots
  taken by agents of their states and input channels,
  when their clocks are at time \(t\), are global snapshots.
  </li>
</ol>
<p>
We use the two properties in several algorithms.

For example, a simple way to take repeated snapshots is for agents to record 
states periodically with some period \(T\), i.e., when  local clocks are at
multiples of time \(T\).

<p class="w3-text-teal">Hardware Clocks and Time Protocols</p>

Most processors, even those on on-board computers, have local clocks
that keep ticking forwards.

Many systems have atomic clocks or clocks that use Precision or
Network Time Protocols (PTP, NTP), or other synchronization mechanisms
to ensure high accuracy.

<p>
A simple way of making a clock that ticks forward forever is to make each agent
send itself <i>clock tick</i> messages. 

When an agent receives a clock tick message it moves its clock forward
and sends itself another clock tick message.

<p>
We use the logical clock algorithm to ensure the logical time
property.

The receiver's clock is
moved forward if a message is received with a timestamp greater than
or equal to the receiver's clock.

<p>
Clocks, even when they are inaccurate, can be helpful in distributed
algorithms. 










<h4 class="w3-text-teal">Next</h4>
Next look at 
-- <a href="../Paxos/ConsensusImpossible.html">consensus algorithms</a>
or <a href="../table_of_contents.html">other types of algorithms</a>.



<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
