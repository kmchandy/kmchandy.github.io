<title>ChannelSnapshots/LogicalClocksNew.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  
  <!--------------------------------------------------------->
  <h2 class="w3-text-teal">Local Clocks and Logical Time</h2>
  <!--------------------------------------------------------->
  
  <p class="w3-text-red">
  A logical clock algorithm assigns a value, called the logical time,
  to each event in a computation so that all edges in the dataflow graph of
  the computation are from lower to higher logical times.

  </p>

  <h4 class="w3-text-teal">The Logical Time Property</h4>
The logical clock algorithm assigns a value \(t(e)\) to each event
  \(e\) of a computation so that:
<br>
  For all edges \((e, e')\) of the dataflow graph of the computation:
  \(t(e) < t(e')\). 


  <!---------------------------------------------------------->
  <h5 style="color:red;">Example: Logical Times of Events</h5>
  <!---------------------------------------------------------->
  
  Figure 1 shows the dataflow graph of a computation with agents
  \(A, B, C\) and an event sequence \([0, 1, 2, \ldots, ]\).

  The numbers inside the vertices show the position of the event in
  the sequence.

  The red numbers outside the events are logical times assigned to
  events.

  <p>
  Logical times are arbitrary provided
  every edge is directed from a lower to a higer logical time.
  <figure>
    <img src="Timelines/Timelines.001.jpeg"
  alt="Fig1" style="width:80%"> 
    <figcaption>Fig. 1: Logical Times of Events</figcaption>
  </figure>


  

  
<!-------------------------------------------------------->
<h4 class="w3-text-teal">A Logical Clock Algorithm</h4>
<!-------------------------------------------------------->
 Let \(t(e)\) be the logical time assigned to event \(e\).
 
 The following algorithm ensures the logical time property.

  <p>
Let \(e'\) be the event immediately preceding an event \(e\) at an
agent.
<ol>
  <li>
  A message sent in an event \(e\) is assigned a timestamp \(t(e)\).
  </li>
  <li>
  If the timestamp of the message received in an event \(e\) is \(T\) then set
  \(t(e)\) to be any value greater than max(t(e'), T).
  </li>
</ol>

The correctness of the algorithm is self evident.



   <!---------------------------------------------------------->  
  <h4 class="w3-text-teal">
  Consequences of the Logical Time Property
  </h4>
  <ol>
    <li>
    Sequences of events in ascending logical time are computations.
    </li>
    <li>
    For all \(t\): The set of events with logical time at most \(t\)
  is input closed.
    </li>
    <li>
    For all \(t < t'\): There is a computation from the set of events
  with logical time at most \(t\) to the the set of events
  with logical time at most \(t'\).
  </ol>

  <p class="w3-text-teal">Proof</p>
  Result 1 follows because sequences in ascending logical time are
  topological sorts of the dataflow graph.
  Result 2 follows because there is no edge from an event
  with logical time greater than \(t\).
  Result 3 follows from
  <a href="../DISTRIBUTED_SYSTEM_MODELS/Timelines.html">
  properties of dataflow.
  </a>

  <h3 class="w3-text-teal">State at Logical Time \(t\)</h3>
  The state at logical time \(t\) is defined as the state at the set
  of events with logical time at most  \(t\).

  The state of an agent at logical time \(t\) is the label of the
  agent edge from an event with logical time at most \(t\) to an event
  with greater logical time. 

The state of a channel at logical time \(t\) is the sequence of messages sent along the
channel in events with logical time at most \(t\) that are received in
  events at greater logical times. 


<!---------------------------------------------------------->
  <h4 style="color:red;">Example: State at Logical Time \(t\)</h4>
<!---------------------------------------------------------->
Figure 2 illustrates the state at logical time 6.5 of the
computation shown in figure 1.

The curved purple line separates events with logical time at most 6.5
  from events with logical times that exceed 6.5.

  Events with logical time at most 6.5 are colored black, while events
  with logical time greater than 6.5 are colored green.

<figure>
    <img src="Timelines/Timelines.002.jpeg"
  alt="Fig2" style="width:80%"> 
    <figcaption>Fig. 2: States at Logical Time 6.5</figcaption>
</figure>

<p>
The point at which the purple line cuts the timeline for agent \(A\)
can be thought of as the point in \(A\)'s computation at which the
logical time is exactly 6.5.

This cut is at any point on the edge from the event at \(A\) with
  logical time at most 6.5 to the event with logical time greater
  than 6.5.

  In this example the cut is on the edge from event 3 to event 5.

  <p>
  The message edge from event 3 to event 7 represents a message sent
  along the channel from \(A\) to \(B\) at a logical time at most 6.5
that is received at a greater logical time.

The state of the channel \((A, B)\) is the sequence consisting of a
single message which is the label of this edge.

<p>
The states of agents and channels at logical time \(t = 6.5\) are
given by the labels of the edges that cut the purple line.


<h4 class="w3-text-teal">
Global snapshot algorithm to record the state at logical time \(t\)
</h4>
An algorithm to record the state at
logical time \(t\) is obvious.

<ol>
  <li>
Each agent takes its local snapshot -- i.e. records its state -- after
an event with logical time at most \(t\) and before an
  event with logical time greater than \(t\).
  </li>
  <li>
An agent records the state of an input channel as the sequence of
messages with timestamps atmost \(t\) that the agent
  receives when its logical clock exceeds \(t\).
  </li>
</ol>

The purple line in figure 2 represents the global snapshot at logical
time 6.5.


  <!--------------------------------------------->
  <h4 class="w3-text-teal">Using Imperfect Clocks in Distributed Algorithms</h4>
<!--------------------------------------------->
Perfect clocks have many useful properties including the following:
<hr class="new2">
<p style="color:blue;">
<ol>
  <p style="color:blue;">
  <li>
  <p style="color:blue;">
  Clocks tick forward forever: For all \(t\), there is a point in
  an infinite computation at which clocks of all agents exceed \(t\).
  </li>
  <p style="color:blue;">
  <li>
  <p style="color:blue;">
  For all \(t < t'\), there is a computation from the state at 
  time \(t\) to the state at time \(t'\).
  </li>
</ol>
<hr class="new2">
A simple way to take repeated snapshots with perfect clocks is for
  each agent to record its state periodically with a period \(T\) as
  determined by the agent's clock. 

<p>
We implement imperfect clocks that have these two properties.

Processors have hardware clocks that keep ticking forward
forever.
Alternatively, an algorithmic way of implementing a clock that ticks forward
 is to make each agent 
send itself <i>tick</i> messages.
When an agent receives a tick message it moves its clock forward and
sends itself another tick.

<p>
We use the logical clock algorithm to adjust these clocks: move an
agent's clock forwards so that the time at which a message is
received, as determined by the receiver's clock, is later than the
timestamp of the message.
So, these imperfect clocks have the two desired properties of perfect clocks.

<p>
We design algorithms for some problems in two steps. First step:
Design an algorithm assuming that
clocks are perfect. Second step: Show that the algorithm is correct with
imperfect clocks that have these properties.
For example, a simple way to take repeated snapshots with these imperfect clocks is for
  each agent to record its state periodically with a period \(T\) as
  determined by the agent's clock. 


<h5 class="w3-text-teal">Time Protocols</h5>

Many systems have high-fidelity clocks.

Most processors have local clocks that usually limit
 drift from real time.

Atomic clocks are getting cheaper.

Some distributed systems use Precision or
Network Time Protocols (PTP, NTP) to periodically compare local clocks
with a standard time server and thus limit the drift among local clocks.

<p>
We use the logical clock algorithm, to update agent clocks, to get
clocks that are both high fidelity and have the two valuable properties listed
above.

Time is useful in distributed systems even if we cannot depend on
perfect clocks.





<h4 class="w3-text-teal">Next</h4>
Next look at 
-- <a href="../Paxos/ConsensusImpossible.html">consensus algorithms</a>
or <a href="../table_of_contents.html">other types of algorithms</a>.



<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
