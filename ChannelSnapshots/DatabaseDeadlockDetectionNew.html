<title>ChannelSnapshots/DatabaseDeadlockDetection.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  
    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">Detecting Database Deadlocks</h1>

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/ChannelSnapshots/Applications.html">
  Applications of Timelines and Snapshots.
  </a>
  </p>

  <p class="w3-text-red">
  "Computation is deadlocked" is a stable predicate; a
deadlocked computation remains deadlocked.
  A general way of
  detecting a stable predicate is to check whether the predicate holds
  in a global snapshot state.
  We use this strategy to design an algorithm to detect deadlock
  </p>

    <h2 class="w3-text-teal">The Problem</h3>

    <p>
    Agents in a distributed system share a set of files.
  Files are indivisible and are not duplicated or destroyed.
  Agents require exclusive access to files.


  Let \(u_{holds}\) be the set of tokens
    that agent \(u\) holds.

    <p>
    An agent is in one of the following states:
    <ol>
      <li>
      <i>State 1: Executing without using shared files.</i> An agent
    may execute without using shared files for an arbitrary amount of
    time and it may transit to the next state (state 2).
      </li>
      <li>
      <i>State 2: Waiting</i>: In this state an agent is waiting to
    get exclusive access to a nonempty set of shared files. When the
    agent gets access to these files it transits to the next state
    (state 3).
      </li>
      <li>
      <i>State 3: Executing while holding shared files</i>
      In this state an agent executes while holding exclusive access to a set of
    shared files and then transits to state 1 when it no longer needs
    access to any shared files.
      </li>
    </ol>

    <p>
    When an agent gets a request for a file that it holds and does not
    need to execute the agent sends the file to the requester.
    When an agent gets a request for a file that it holds, and does 
    need to execute, the agent continues to hold on to the file until it completes
    executing with the file and transits to state 1.
    <p>
    A computation deadlocks if there is a cycle of waiting agents
    where each agent in the cycle holds and requires a file that is
    required by the previous agent in the cycle.
    
    <p>
    Next, we describe the problem in detail.
    For an agent \(u\) let \(u.holds\) be the set of files that
    \(u\) holds. Let \(u.needs\) be the nonempty set of files
    that \(u\) needs to execute in states 2 and 3, and  \(u.needs\)
    is the empty set in state 1. The set \(u.needs\) remains
    unchanged in states 2 and 3: Agent \(u\) does not begin to need
    additional files while it is waiting or executing, and it
    continues to need all the files in \(u.needs\) until it transits
    to state 1.

    <p>
    When an agent \(u\) gets a request for a file in \(u.holds\)
    which is not in \(u.needs\), agent \(u\) sends the requested file
    to the requester and that file is removed from \(u.holds\).
    If  \(u\) gets a request for a file in \(u.holds\)
    which is in \(u.needs\) then \(u\) does not send the requested
    file while \(u\) is in states 2 and 3; and \(u\) sends the requested
    file when \(u\) enters state 1.

    <p>
    When \(u\) transits from state 1 to state 2, \(u\) sends requests
    for all the files that are in \(u.needs\) and not in \(u.holds\).
    (Ignore how \(u\) determines which agents hold the files that it
    needs.)

    <p>
For an agent \(u\), define \(u.waits\) as the set of files that
\(u\) needs and does not hold:

\(
u.waits = u.needs - u.holds
\)
    

    <p class="w3-text-teal">Deadlock</p>
    The computation is deadlocked if there exists a cycle of agents
    where each agent in the cycle holds a needs a file that the
previous agent in the cycle needs.
Let \(u'\) be the next agent in a deadlocked cycle after an agent
\(u\). Then \(u'\) and \(u\) are in waiting state and
there is a file common to \(u.waits\) and \(u'.needs\).
    

<h3 class="w3-text-teal">An Algorithm</h3>
Let's use the general strategy for detecting stable predicates: Take global
snapshots repeatedly and check whether the stable predicate holds in
the snapshots.

    <p>
The definition of a deadlocked cycle depends only on the local states
of agents and is independent of the states of message channels.
Next, we describe a simpler version of the global snapshot algorithm which
does not record channel states. 

<p class="w3-text-teal">Message Types</p>
The algorithm uses a message type called <i>marker</i>.  A marker \(m\)
has a field \(m.waits\). When an agent \(u\) sends a marker \(m\) it
sets: \(m.waits = u.waits\).

<p class="w3-text-teal">Initiating the Snapshot</p>
Let \(x\) be the agent that initiates the algorithm.
Assume that there is only one initiator. (Multiple
initiators can be handled by tagging messages with the identity of the
initiator.)

<p>
Agent \(x\) initiates the algorithm by
sending a marker \(m\) with field \(m.waits = x.waits\) to all
agents that hold files in \(x.waits\).
Let \(x.waits*\) be the value of \(x.waits\) at this point.

<p class="w3-text-teal">Propagating Markers</p>
When an agent \(u\) receives a marker \(m\), then if
<ol>
  <li>
  \(u.waits\) is not empty, and
  </li>
  <li>
  and there is a file common to both \(m.waits\) and
  \(u.needs\),
  </li>
</ol>
agent \(u\) sends a marker \(m'\) with 
\(m'.waits = u.waits\) to all agents that hold files in \(u.waits\).
<p>
Agent \(u\) takes no action when it receives marker \(m\) if \(u\) is
not waiting or there is no file common to \(m.waits\) and \(u.needs\).

<p class="w3-text-teal">Termination Detection</p>
The initiator \(x\) detects deadlock if it receives a marker \(m\)
where there is a file common to \(m.waits\) and \(x.waits*\).


<p class="w3-text-teal">Correctnes of the Algorithm</p>
The algorithm is a version of the global snapshot algorithm in which
channel states are not recorded, and markers are not propagated by an
agent if it is not part of a deadlock cycle.
  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
