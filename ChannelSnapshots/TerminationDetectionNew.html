<title>TerminationDetection</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

<!--------------------------------------------------------->
<h1 class="w3-text-teal">Termination Detection</h1>
<!--------------------------------------------------------->

  <p class="w3-text-green">
  This page uses material from
  <a
  href="../ChannelSnapshots/ChannelSnapshots.html">
  Global Snapshots and State Detection.</a>
  </p>

  <p class="w3-text-red">
  <i>Central Ideas</i>:
  The consistent cut is the foundation of all detection algorithms.
  A general detection algorithm is to take repeated global snapshots
  and check whether the specified property holds in any
  snapshot. Here, we review the general method applied to the
  specific problem of termination detection, and also describe
  a simple termination detection algorithm based on consistent cuts.
  </p>


    <h3 class="w3-text-teal">Problem Definition</h3>
    An agent is either <i>idle</i> or <i>active</i>. An idle agent
    remains idle until it receives a message at which point it becomes
active. An idle agent does not send messages.

An active agent may send messages. An active agent
may become idle at any point.

<p>
    Initially all agents are active and all channels are empty.

  A computation has
  terminated when all agents
  are idle and all channels are empty. 
  A computation may or may terminate.
 

<p>
    The problem is to develop an algorithm that detects that a computation
has terminated.
The detection algorithm may use messages and agents that are not part of the
  underlying computation.
  The detection algorithm must not modify the underlying computation.

  <p>
  The specification of the algorithm in
  <a
  href="ChannelSnapshots.html">
  Global Snapshots and State Detection.
  </a>
  is repeated below for convenience.

  <h3 class="w3-text-teal">Specification of the Algorithm</h3>
  The algorithm has a boolean variable \(B\) which signals that the
  detection algorithm has detected that computation has terminated.
<ol>
  <li>
  If the computation terminates then the
  algorithm returns \(B = True\) when or after computation terminates.
  </li>
  <li>
  If \(B = True\) at any point then computation has terminated at that
  point. 
  </li>
</ol>

<h3 class="w3-text-teal">The General Method applied to Termination Detection</h3>
<a
  href="ChannelSnapshots.html">
  A general algorithm for detecting stable properties
  </a> is for each agent to send its local
snapshot to an agent, which we call a <i>detector</i>.
The detector puts local snapshots together to get a global
snapshot.
Agents repeatedly send their local snapshots to the detector which
computes an endless sequence of global snapshots.
The detector claims that the specified stable property holds
if it holds in any global snapshot.
An algorithm for termination detection is obtained by checking whether
computation has terminated -- all agents idle and all channels empty
-- in a global snapshot.

<h3 class="w3-text-teal">Algorithm for Termination
Detection without Scheduling Snapshots</h3>
Next, we use the concept of consistent cuts to obtain an
algorithm for termination detection without scheduling repeated snapshots.
Let \(C_{s}\) and \(C_{r}\) be the numbers of messages sent and
received (respectively) along channel \(C\).
Computation has terminated in a state in which all agents are idle and
for all channels \(C\): \(C_{s} = C_{r}\).

<p>
Each time an agent transits from active to idle it sends \(C_{s}\)
for each of its outgoing channels \(C\),
and \(C_{r}\) for each of its incoming channels \(C\), to the
detector.
The detector keeps the latest message that it receives from each
agent.
Let \(C_{s}^{*}\) be the last value of \(C_{s}\) that the detector has
received, and
let \(C_{r}^{*}\) be the last value of \(C_{r}\) that the detector has
received.

<h4 class="w3-text-teal">The Detection Condition</h4>
<h5 style="color:blue;">
The detector detects that computation has terminated if it has
received a message from each agent and for
all channels \(C\): \(C_{s}^{*} = C_{r}^{*}\).
</h5>

<p>
The key difference between this algorithm and the general method is as
follows. In this algorithm an agent only sends channel counts (\(C_{s},
C_{r}\)) to the detector and only when the agent transits from active to idle.
In the general method an agent send its state (active or idle) and states of incoming
channels to the detector periodically where the period is based on
time rather than on whether the agent has become idle.

<h4 class="w3-text-teal">Proof of Correctness</h4>
We first prove part 1 of the specification:
If the computation terminates then the
 detection algorithm sets Boolean variable \(B\) to True when or after computation
terminates.
<p>
We consider the case where computation has terminated.
Let \(C_{s}^{*}\) be the number of messages sent by an agent with
output channel \(C\) when the agent transits from active to idle for
the very last time. Then \(C_{s}^{*}\) is the number of messages sent
on \(C\) when computation terminates.
By the same argument, \(C_{r}^{*}\) is the number of messages received
on \(C\) when computation terminates.
Therefore, \(C_{s}^{*} = C_{r}^{*}\)

<p>
Next, we prove part 2 of the specification:
If \(B = True\) at any point then computation has terminated at that
  point. 
<p>
Define a cut as follows. An
event is in the <i>past</i> exactly when that event occurs at an agent
before that agent sends the counts \(C_{s}^{*}, C_{r}^{*}\) used by
the detector to set \(B\) to \(True\). Because \(C_{s}^{*} =
C_{r}^{*}\) the number of messages received in
the past along each channel equals the number of messages sent in the
past along that channel. So, every message received by an event in the past is
sent by an event in the past. Therefore the cut is consistent. So, the
state corresponding to the cut is a global snapshot, and computation
has terminated since the
snapshot shows that computation has terminated.



<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
