<title>TerminationDetection</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

<!--------------------------------------------------------->
<h1 class="w3-text-teal">Termination Detection</h1>
<!--------------------------------------------------------->

  <p class="w3-text-green">
  This page uses material from
  <a
  href="../ChannelSnapshots/ChannelSnapshots.html">
  Global Snapshots and State Detection.</a>
  </p>

  <p class="w3-text-red">
  <i>Central Ideas</i>:
  The consistent cut is the foundation of all detection algorithms.
  System monitoring by scheduling repeated snapshots can be used to
  solve all detectiion problems. Here, we review system monitoring applied to the
  specific problem of termination detection, and also describe
  another simple termination detection algorithm based on consistent cuts.
  </p>


    <h3 class="w3-text-teal">Problem Definition</h3>
    An agent is either <i>idle</i> or <i>active</i>. An idle agent
    remains idle until it receives a message at which point it becomes
active. An idle agent does not send messages.

An active agent may send messages. An active agent
may become idle at any point.

<p>
    Initially all agents are active and all channels are empty.

  A computation has
  terminated when all agents
  are idle and all channels are empty. 
  A computation may or may terminate.
 

<p>
    The problem is to develop an algorithm that detects that a computation
has terminated.
The detection algorithm may use messages and agents that are not part of the
  underlying computation.
  The detection algorithm must not modify the underlying computation.
  The algorithm has a boolean variable \(B\) which is \(True\) if and
    exactly when the
  detection algorithm has detected that computation has terminated.

  <p>
  The specification of the detection algorithm is that it must
  terminate, and: 
  
<ol>
  <li>
  If the underlying computation terminates then \(B\) becomes \(True\).
  </li>
  <li>
  If \(B = True\) at any point then the underlying computation has terminated at that
  point. 
  </li>
</ol>

<h3 class="w3-text-teal">The General Method applied to Termination
Detection</h3>
<a
  href="ChannelSnapshots.html">System monitoring</a> can be used to
detect every stable property including termination.
Each agent send its local
snapshot at time \(T\) to an agent, which we call a <i>detector</i>.
The detector puts together local snapshots at \(T\) to get the global
snapshot at \(T\).
Agents and the detector obtain global snapshots at increasing values of \(T\).
The detector claims that the underlying computation has terminated if
the global snapshot at \(T\), for any \(T\), shows termination -- all
agents idle and all channels empty. 


<h3 class="w3-text-teal">Algorithm for Termination
Detection without Scheduling Snapshots</h3>
Next, we use the concept of consistent cuts to obtain an
algorithm for termination detection without scheduling repeated snapshots.
Let \(C_{s}\) and \(C_{r}\) be the numbers of messages sent and
received (respectively) along channel \(C\).
Computation has terminated in a state in which all agents are idle and
for all channels \(C\): \(C_{s} = C_{r}\).

<p>
Each time an agent transits from active to idle it sends \(C_{s}\)
for each of its outgoing channels \(C\),
and \(C_{r}\) for each of its incoming channels \(C\), to the
detector.
The detector keeps the latest message that it receives from each
agent.
Let \(C_{s}^{*}\) be the last value of \(C_{s}\) that the detector has
received, and
let \(C_{r}^{*}\) be the last value of \(C_{r}\) that the detector has
received.

<h4 class="w3-text-teal">The Detection Condition</h4>
<h5 style="color:blue;">
The detector detects that computation has terminated if it has
received a message from each agent and for
all channels \(C\): \(C_{s}^{*} = C_{r}^{*}\).
</h5>

<p>
The key difference between this algorithm and the system monitoring method is as
follows. In this algorithm an agent only sends channel counts (\(C_{s},
C_{r}\)) to the detector and only when the agent transits from active to idle.
In the system monitoring method an agent sends its state (active or idle) and states of incoming
channels to the detector repeatedly for increasing times \(T\),
regardless of whether the agent is active or idle.

<h4 class="w3-text-teal">Proof of Correctness</h4>
We first prove part 1 of the specification:
If the underlying computation terminates then the
 detection algorithm sets \(B\) to True.
<p>
Assume that the underlying computation has terminated.
Let \(C_{s}^{*}\) be the number of messages sent by an agent with
output channel \(C\) when the agent transits from active to idle for
the very last time. Then \(C_{s}^{*}\) is the number of messages sent
on \(C\) when computation terminates.
By the same argument, \(C_{r}^{*}\) is the number of messages received
on \(C\) when computation terminates.
Therefore, in the snapshot obtained by the detector, \(C_{s}^{*} =
C_{r}^{*}\), and therefore the detector sets \(B\) to \(True\).

<p>
Next, we prove part 2 of the specification:
If \(B = True\) at any point then computation has terminated at that
  point. 
<p>
At the point \(t\) at which the detector set \(B\) to \(True\), \(C_{s}^{*} =
C_{r}^{*}\) for all channels \(C\). Therefore, for each agent \(A\),
there is a point \(t'\) earlier than \(t\) at which \(A\) sent
\(C_{s}^{*}\) for each of its output channels \(C\) and 
\(C_{r}^{*}\) for each of its input channels \(C\), to the detector.




output
channel \(C\) of an agent \(A\), there is a point \(t'\) earlier than
\(t\) at which \(A\) sent \(C_{s}^{*}\) to the detector.
Likewise, for each input
channel \(C\) of an agent \(A\), there is a point \(t'\) earlier than
\(t\) at which \(A\) sent \(C_{r}^{*}\) to the detector.
An event at \(A\) is in the <i>past</i> exactly when that event occurs
before \(t'\).

<p>
Because \(C_{s}^{*} =
C_{r}^{*}\) the number of messages received in
the past along each channel equals the number of messages sent in the
past along that channel. So, every message received in the past is
sent in the past. Therefore the cut is consistent. So, the
state corresponding to the cut is a global snapshot.
Because the snapshot shows that the underlying computation
has terminated the underlying computation has terminated.



<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
