<title>TerminationDetection</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  

<!--------------------------------------------------------->
  <h2 class="w3-text-teal">Termination Detection</h2>

  <p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/ChannelSnapshots/Applications.html">
  Applications of Timelines and Snapshots.
  </a>
  </p>

  <p class="w3-text-red">
  "Computation has terminated" is a stable predicate: After a
  computation has terminated it remains terminated. A general way of
  detecting a stable predicate is to check whether the predicate holds
  in a global snapshot state.
  We use this strategy to design an algorithm for termination
  detection. 
  </p>
  

<h3 class="w3-text-teal">The Problem</h3>

    <h4 class="w3-text-teal">Active and Idle States of Agents</h4>
    An agent is either <i>idle</i> or <i>active</i>. An idle agent
    remains idle until it receives a message at which point it becomes
active. An idle agent does not send messages.

An active agent may send messages. An active agent
may become idle at any point.

<p>
    Initially all agents are active and all channels are empty.

  <h4 class="w3-text-teal">Terminated State</h4>
  A computation has
  terminated exactly when all agents
  are idle and all channels are empty. 
  A computation may or may terminate.
 After a computation terminates it remains terminated.
 

<p>
    The problem is to develop an algorithm that detects that a computation
has terminated.
The detection algorithm may use messages and agents that are not part of the
  underlying computation.
  The detection algorithm must not modify the underlying computation.

  
<h4 class="w3-text-teal">Specification of the Algorithm</h4>
The detection algorithm returns a Boolean variable where:
<ol>
  <li>
  If the detection algorithm starts after the system has terminated then
  the detection algorithm returns True.
  </li>
  <li>
  If the detection algorithm returns True then the system has terminated when
    the detection algorithm terminates.
  </li>
</ol>

<h3 class="w3-text-teal">Algorithms for Termination Detection</h3>

A general algorithm for detecting stable properties is to repeatedly take
global snapshots and determine if the predicate holds in any
 snapshot.
Let's specialize this algorithm to detect termination.

<p>
Global snapshots are obtained in the following way.
Each agent records its local state (active or idle) and for each incident channel
  \(C\), the number of messages sent \(C_{s}\) and the number of
  messages received \(C_{r}\) along that channel at the point.
From the theory of global snapshots, the local agent recordings form a
global snapshot if for all channels \(C\), \(C_{s} \geq C_{r}\).
So:
<hr class="new2">
<p style="color:blue;">
Any collection of local recordings forms a global snapshot if
\(C_{s} = C_{r}\) for all channels \(C\).
</p>
<hr class="new2">
This suggests the following algorithm.

<p>
Each time that an agent transits from active to idle it records \(C_{s}\)
the number of messages that it sent along each outgoing channel \(C\),  and \(C_{r}\) the number of
messages that it received along each incoming channel \(C\), at that point.
Assume, for the time being, that these records are stored somewhere.
<hr class="new2">
<p style="color:blue;">
If there exists a set of records, one for each agent, such that for
all channels \(C\): \(C_{s} = C_{r}\), where \(C_{s}, C_{r}\) are the
values in the records, then computation has terminated.
</p>
<hr class="new2">
<p>
This is because the set of records forms a global snapshot in which
all agents are idle and all channels are empty.

<p class="w3-text-teal">Collecting Local Snapshots to Form a Global Snapshot</p>
One way to collect local snapshots is to send them to an agent that is
not part of the underlying computation. Let's call this agent the
<i>detector</i>. The detector keeps the last message that it has
received from each agent.
The detector detects that computation has terminated when the detector
has received at least one message from each agent, and for all
channels \(C\): \(C_{s} = C_{r}\) where \(C_{s}, C_{r}\) are the
counts in the latest messages that the detector has received.



<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
