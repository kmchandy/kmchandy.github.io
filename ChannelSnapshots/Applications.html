<title>Applications</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">
  


<!--------------------------------------------------------->
<h2 class="w3-text-teal">Applications of Timelines & Snapshots</h2>

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/DISTRIBUTED_SYSTEM_MODELS/Timelines.html">
  Timelines.
  </a>
  and from 
  <a
  href="https://kmchandy.github.io/ChannelSnapshots/ChannelSnapshots.html">
  Global Snapshots.
  </a>
</p>

  <p class="w3-text-red">
  We use the following heuristic to solve many problems: Design an
  algorithm assuming that all agents can record a global state at the
  same instant; then check whether that algorithm is correct
  using global snapshots instead of true global states.
  </p>

  <h3 class="w3-text-teal">Rollback and Recovery</h3>
  The specification of a rollback and recovery algorithm is as follows.
When an error is detected in a computation,
  restart the computation from a recent saved (global) state
  instead of executing the entire computation again.

  <p>
  If agents could collectively determine the global state at the same
  instant then the algorithm is simple: repeatedly save the
  instantaneous true global state and restart the computation from the
  most recent one.

  In a distributed system, agents cannot collectively determine the
  global state at the same instant.
  Let's use our heuristic: let's see
  whether global snapshots can be used instead of the true
  instantaneous global states.

<p>
The heuristic suggests the following algorithm. Agents
  take global snapshots repeatedly.
If an error is detected, the computation is restarted
  from the most recent global snapshot.
  Let's check whether this algorithm is correct

  

  <p>
  From the theorem of
  <a
  href="https://kmchandy.github.io/ChannelSnapshots/ChannelSnapshots.html">
  global snapshots, </a> there exists a computation from the initial state
  to a snapshot state. Therefore there exists a computation that
  starts at the initial state, then visits the most recent snapshot
state, and then continues with the restarted computation.
So, we can use snapshots instead of a global state that occurred in
  the computation.


<h3 class="w3-text-teal">Detecting Stable Predicates</h3>
<hr class="new2">
<h6 style="color:blue;">
A <i>stable predicate</i> is a predicate with the following property: If the
predicate holds at any point in any trajectory then it continues to
hold forever thereafter in that trajectory. Equivalently, if a stable
predicate holds in a state \(s\) then it holds in all states reachable
from \(s\).
</h6>
<hr class="new2">
<p>
An example of a stable predicate is: "<i>The computation has terminated.</i>"
If a computation has terminated at some point then it remains
terminated thereafter.

<h4 class="w3-text-teal">Specification of the Algorithm</h4>
The specification of an algorithm to detect a stable property is as
follows. The algorithm returns a Boolean value where
<ol>
  <li>
  If the stable property holds when the algorithm is started
  then the algorithm returns true.
  </li>
  <li>
  If the algorithm returns true, then the stable property holds when
  the algorithm terminates.
  </li>
</ol>
If the stable property does not hold when the detection algorithm
starts, but does hold when the algorithm terminates, then
the algorithm may return either true or false.
  

<h4 class="w3-text-teal">Algorithm to Detect a Stable Predicate</h4>
If agents could collectively determine the global state at the same
  instant then the algorithm is simple: agents determine a global
state and check whether the stable predicate holds in that state.
In a distributed system, agents cannot collectively determine the
  global state at the same instant.
  Let's use our heuristic: let's see
  whether global snapshots can be used instead of the true
  instantaneous global states.
<p>
The heuristic suggests the following algorithm:
Take a global snapshot and claim that the stable predicate holds if it
holds in the snapshot state.
Next, let's see if this algorithm is correct.

<p class="w3-text-teal">Outline of Proof of Correctness</p>
Let \(s_{init}\) and \(s_{fini}\) be the states in which the snapshot
algorithm starts and finishes, respectively.
Let \(s_{snap}\) be the global snapshot.
Then from the theorem of global snapshots
 there is a path from \(s_{init}\) to \(s_{snap}\) and then to
\(s_{fini}\). So, if a stable predicate  holds in \(s_{init}\) then it
also holds in \(s_{snap}\).
Likewise,
if a stable predicate holds in \(s_{snap}\) then it also holds in
\(s_{fini}\). Therefore the algorithm satisfies the specification.

<p>
The pages in this section describe algorithms that detect termination and database deadlock.
Other detection algorithms are described later.

<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
