<title>ChannelSnapshots/ChannelSnapshots.html</title>
<title>Snapshots</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">



<!--------------------------------------------------------->
<h1 class="w3-text-teal">Global Snapshots and State Detection</h1>
<!--------------------------------------------------------->

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/DISTRIBUTED_SYSTEM_MODELS/Timelines.html">
  Timelines.
</p>

<a href="GlobalSnapshotAlgorithmVideo.mp4">
<h3 class="w3-text-teal">Video</h3>
  </a>

  <p class="w3-text-red">
  The global snapshot algorithm determines the system state at a
   consistent cut of a computation. All algorithms that detect system
  states are based on the concept of a consistent cut.
  </p>

  <h3 class="w3-text-teal">Specification of a Global Snapshot</h3>
  
  Algorithms by which agents collaborate to record the state of a
  system are not instantaneous. 
Let the states in which the algorithm starts and ends be
\(s_{init}\) and \(s_{fini}\), respectively, and let \(s_{snap}\) be
the global state (the snapshot) recorded by the algorithm.

<hr class="new2">
  <h5 style="color:blue;">
  Specification
  <br>
Determine \(s_{snap}\) so that there exists a trajectory from
  \(s_{init}\) through \(s_{snap}\) to \(s_{fini}\).
</h5>
  <hr class="new2">

  <p>
  From the <a
  href="../DISTRIBUTED_SYSTEM_MODELS/Timelines.html">theorem on
  consistent cuts</a>, 
  this specification is satisfied when \(s_{snap}\) is the state at a
  consistent cut. Let's design an algorithm by which agents
  collaborate to determine a consistent cut.

  <p>
  Each agent takes its own local snapshot, i.e. records its own local
  state, at a point in the computation.
  Define <i>past</i> events at an agent to be the events at that
  agent before the agent takes its own local snapshot.
  An event is in the future if the event occurs at an agent after that
  agent takes its local snapshot.
  The cut is consistent if all edges in the causality
graph from the future are to the future.

  <p>
  Edges in an agent's timeline from events after the agent's snapshot
  are (obviously) to events after the agent's snapshot.
Therefore the cut -- past events are events at an agent before the
  agent takes its local snapshot -- is consistent if it satisfies the
  following condition:

<hr class="new2">
<h5 style="color:blue;">
Consistent cut requirement: 
All messages sent after the sender takes its local snapshot
are received after the receiver takes its local snapshot.
</h5>
<hr class="new2">

<p>
Next, we describe one of many algorithms that satisfy the consistent
cut requirement.
<p>
The algorithm employs a special type of message called a <i>marker</i>,
distinct from all other messages in the system.
Exactly one
<i>marker</i> is sent along each channel.

<h3 class="w3-text-teal">A Global Snapshot Algorithm</h3>
<ol>
  <li>
  The algorithm begins by one or more agents taking their local
  snapshots.
  </li>
  <li>
  When an agent takes its local snapshot it sends a <i>marker</i> on each
  of its outgoing channels.
  </li>
  <li>
  When an agent receives a marker, the agent takes its local snapshot
  if it has not already done so.
  </li>
</ol>

<h5 class="w3-text-teal">Proof: Algorithm satisfies the Consistent Cut
Requirement</h5>
A message sent after the sender
takes its local snapshot is sent after the sender sends
markers.
Because channels are first in first out, a message that is sent after
a marker is sent
is received after the marker is received.
When an agent receives a marker the agent takes its local snapshot if it hasn't done
so.
Therefore, a message sent after the sender
takes its local snapshot is received after the receiver takes its
local snapshot.

<p>
We assume that the directed graph of agents (vertices) and channels
(edges) is strongly connected, and so the algorithm sends a marker on
every channel, and every agent takes its local snapshot.



<h4 style="color:red;">Example</h4>
Figure 1 illustrates the algorithm. In this example, there are three
agents -- A, B, and C -- and there is exactly one channel
 from each agent to every other agent. When agent B takes its
snapshot it sends markers
to agents A and agents C. Markers are shown as green edges.
Agent C takes its snapshot when it receives the marker
which ensures that agent C's snapshot is before event 11.

    <figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.005.jpeg" alt="Fig5" style="width:80%">
    <figcaption>Fig.1: Markers ensure cuts are consistent</figcaption>
</figure>
When agents B and C receive markers they take their snapshots if they
    haven't done so already, and send markers in their turn. These
markers are shown in the next figure.

    <figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.006.jpeg" alt="Fig6" style="width:80%">
    <figcaption>Fig.2: Showing all Markers</figcaption>

<h3 class="w3-text-teal">Snapshots of Channels</h3>
Next we look at an algorithm to record snapshots (states) of channels
at a cut.  The messages in the channel at a cut are the messages sent on the channel in the past and
received on the channel in the future.

<p>
When an agent takes its local snapshot it sends a marker on each of
its outgoing channels.  So, messages sent along a channel in the past are
the messages sent on the channel before the marker is sent along the
channel.
Messages received in the future are the messages received after the
receiver takes its local snapshot.
Therefore:
<hr class="new2">
<h5 style="color:blue;">
The state of a channel at a cut is the sequence of messages
received along the channel after the receiver takes its local snapshot
and before the receiver receives a marker along the channel.
</h5>
<hr class="new2">
<p>
Note: If an agent takes its local snapshot when it receives a marker
along a channel, then the snapshot of the channel is the empty
sequence of messages.

<h4 style="color:red;">Example: Channel Snapshot</h4>
A diagram that illustrates the process by which an agent gets a
snapshot of an incoming channel is shown below. The diagram shows the
timelines for two agents, \(A\) and \(B\).

<p>
Agent \(A\) sends messages \(m_{0}, m_{1}, m_{2}\), then sends a
marker (colored green), and then message \(m_{3}\), to agent \(B\) on a
channel \(x\). All the messages in the diagram are sent on the same
channel.

<p>
The events shown as blue circles on \(A\)'s timeline are
events in which \(A\) sends messages \(m_{0}, m_{1}, m_{2}\) before
\(A\) takes its local snapshot.  The event shown as a black circle
shows \(A\) sending messages \(m_{3}\) after \(A\) takes its local
snapshot. The point at which \(A\) takes its local snapshot is the
point at which the purple wavy line (the cut) crosses \(A\)'s timeline.

    <figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.007.jpeg" alt="Fig7" style="width:100%">
    <figcaption>Fig.7: Snapshot of a channel</figcaption>
    </figure>

The event shown as a yellow circle on \(B\)'s timeline represents the
event in which \(B\) receives messages \(m_{0}\) before \(B\) takes its
own snapshot. The events shown as orange circles represent events in
which \(B\) receives messages \(m_{1}, m_{2}\) after \(B\) takes its
own snapshot and before \(B\) receives the marker. The black event
represents \(B\) receiving message \(m_{3}\) after \(B\) takes its
snapshot.

<p>
The messages that \(A\) sent in the past are \(m_{0}, m_{1}, m_{2}\).
The messages that \(B\) receives in the future are \(m_{1}, m_{2},
m_{3}, \ldots\).
The state of the channel, at the cut, is the sequence of messages \([m_{1},
m_{2}]\) that \(A\) sent in the past and that \(B\) receives in the
future.
This is shown as the sequence of red message lines that
cross the wavy purple line which represents the global snapshot.
These are the messages that \(B\) receives after it takes its local
snapshot and before it receives the marker.

<h4 class="w3-text-teal">Collecting Local Agent and Channel
Snapshots</h4>
Each agent takes its own local snapshot and the snapshots of its
incoming channels.
Some applications require a single agent to collect local
snapshots to form a global snapshot while other applications carry out
computations on local snapshots.
Algorithms that detect system properties by analyzing local snapshots
are given later. 

<h2 class="w3-text-teal">State Detection</h2>
Many applications repeat global snapshots to detect properties of
computations such as "the computation has terminated."
The obvious way of repeating snapshots is to modify the
snapshot algorithm to associate timestamps with snapshots and markers.
The algorithm to obtain the global snapshot associated
with timestamp \(T\) is as follows.
<ol>
  <li>
  When an agent's local clock is at time \(T\) the agent takes its
  local snapshot with timestamp \(T\) if it has not already done so.
  </li>
  <li>
  When an agent takes its local snapshot with timestamp \(T\) it sends
  markers with timestamp \(T\) on all its outgoing channels.
  </li>
  <li>
  When an agent receives a marker with timestamp \(T\) the agent takes
  its local snapshot with timestamp \(T\) if it has not already done
  so.
  </li>
</ol>
Snapshots are taken periodically. Agents can get accurate time/date for
timestamps from reference clocks such as NTP servers.

<h3 class="w3-text-teal">State Detection: Examples</h3>

<p class="w3-text-teal">Rollback and Recovery</p>
If an error occurs the computation is restarted from the most recent
snapshot.

<p class="w3-text-teal">Termination Detection</p>
If a computation terminates at some point then a snapshot taken after
termination will show that computation has terminated.
And if a snapshot shows that computation has terminated, then
computation has indeed terminated.

<p class="w3-text-teal">Detecting Deadlock and other Stable
Properties</p>
Distributed operating systems detect properties that continue to hold
until the operating system changes the state of a computation. An example of
such a property is "computation has deadlocked." If such a property
holds then a later snapshot will show that property
holds. And if a snapshot shows that the property holds then the
property indeed holds at that point.

  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
