<title>ChannelSnapshots/ChannelSnapshots.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>
<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>

<nav
class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5
w3-animate-left" 
id="mySidebar">

<a href="javascript:void(0)"
onclick="w3_close()"
class="w3-right w3-xlarge w3-padding-large w3-hover-black
w3-hide-large"
title="Close Menu">
<i class="fa fa-remove"></i>
</a>

<!--END Heading  ---------------------------->
 
<!-- Start Sidebar----------> 
 
<a class="w3-bar-item w3-button w3-hover-black "
href="./SnapshotsChapterIntroduction.html" > 
Introduction: Timelines, Snapshots, Logical Clocks
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="./Timelines.html" > 
Timelines
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="./ChannelSnapshots.html" > 
Global Snapshots
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="./LogicalClocks.html" > 
Logical Clocks
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="./VectorClocks.html" > 
Vector Clocks
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="./SnapshotIntroductionSelfTest.html" > 
Timelines: Quiz
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="./ChannelSnapshotsSelfTest.html" > 
Snapshots: Quiz
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="./ChannelSnapshotsAssignment/ChannelSnapshotsAssignment.html" > 
Snapshots: Assignment
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="./ChannelSnapshotsAssignment/ChannelSnapshotsAssignmentSolution.html" > 
Snapshots: Solution
</a>

</nav>
<!-- End Sidebar---------->
 
<!-- Start overlay ---------------------------------->

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large"
  onclick="w3_close()"
  style="cursor:pointer"
  title="close side menu"
  id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

<!-- End overlay ---------------------------------->


<!--------------------------------------------------------->
<h1 class="w3-text-teal">Snapshots of Distributed Systems</h1>
<!--------------------------------------------------------->

<h4 class="w3-text-teal">
This module describes the global snapshot algorithm which can be used
to determine a global state of a system
</h4>

<a href="GlobalSnapshotAlgorithmVideo.mp4">
<h3 class="w3-text-teal">Video</h3>
</a>

The global snapshot algorithm determines a global state of a
system. The algorithm cannot be instantaneous because it requires
collaboration among multiple agents. 
Let the states in which the algorithm starts and ends be
\(s_{init}\) and \(s_{fini}\), respectively, and let \(s_{snap}\) be
the snapshot determined by the algorithm.

<h4 class="w3-text-teal">Specification of the Global Snapshot</h4>
\(s_{snap}\) must be the
<a href="">state of a consistent cut.</a>

<p>
An important property that follows the <a href="">theorem and
corollary on consistent cuts</a> and from the specification is:
<hr class="new2">
    <h5 style="color:blue;">
There exists a trajectory from \(s_{init}\) through \(s_{snap}\) to
\(s_{fini}\).
</h5>
<hr class="new2">

The diagram below illustrates this property. 
\(s_{init}\) is obtained
from the timeline diagram at points crossed by the vertical line representing the
instant at which the snapshot is initiated, and 
\(s_{fini}\) by the vertical line at the
instant at which the snapshot algorithm completes. The snapshot state,
\(s_{snap}\), is the state at a consistent cut where the events before
the snapshot algorithm is initiated are a subset of the events before the cut,
and the events after the snapshot algorithm terminates are a subset of
the events after the cut.

<figure>
    <img src="PropertiesOfGlobalSnapshots_1.jpg"
alt="Fig1" style="width:80%"> 
    <figcaption>Fig.1: Initial, snapshot and final states</figcaption>
</figure>

<h4 class="w3-text-teal">Stable Predicates and Snapshots</h4>
If a
<a href="../ReviewOfBasics/Invariant/Invariant.html">
stable predicate \(P\)</a>
holds at any point in a trajectory then it continues to hold
therafter. So, if \(P\) holds in \(s_{init}\) then \(P\) holds in
\(s_{snap}\), and if \(P\) holds in \(s_{snap}\) then \(P\) holds in
\(s_{fini}\). To summarize, for any stable predicate \(P\):
<ol>
  <li>
  If \(P\) holds in the snapshot state then \(P\) holds when the snapshot
  algorithm terminates.
  <br>
  \(
  P(s_{snap}) \; \Rightarrow \; P(s_{fini})
  \)
  </li>
  <li>
  If \(\neg P\) holds in the snapshot state then \(\neg P\) holds when the snapshot
  algorithm is initiated.
  <br>
  \(
  \neg P(s_{snap}) \; \Rightarrow \; \neg P(s_{init})
  \)
  </li>
</ol>
The above two rules are asymmetric: the first relates the snapshot
and final state; while the second relates the snapshot
and initial state.

<p>
The snapshot algorithm can be used to detect a stable property such as:
"computation has terminated."

If the snapshot shows that computation has terminated
then computation has indeed terminated. If, however, computation has
not terminated in the snapshot state then we can only conclude that the
computation had not terminated when the algorithm was
<i>initiated</i>. It is possible that computation terminated after
the snapshot algorithm was initiated and before it terminated. So to
detect termination we have to run the snapshot algorithm repeatedly.

<h4 class="w3-text-teal">A Brief Review of Consistent Cuts</h4>
A consistent cut of a timeline diagram is a partition of the events in
the diagram into two subsets called <i>past</i> and <i>future</i>, and
in which there is no message from a future event
to a past event.

<h4 style="color:red;">Review: Examples of Cuts</h4>
<figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.001.jpeg"
alt="Fig1" style="width:80%"> 
    <figcaption>Fig.1: A consistent cut</figcaption>
</figure>
Figure 1 shows a consistent cut, and figure 2 shows an inconsistent one.

<figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.002.jpeg" alt="Fig2" style="width:80%">
    <figcaption>Fig.2: An inconsistent cut</figcaption>
</figure>

    <p>
    We use the phrase "an agent B takes its local snapshot" for "an
agent B records B's state."
A key question is <i>when</i> should an agent take
its own local snapshot to ensure that the collection of local
snapshots form a consistent cut? 

<h4 style="color:red;">Examples of Local Snapshots</h4>
In the next two figures, the points at which each agent takes its
local snapshot are shown as yellow circles. Past events are those
earlier than the points at which agents take their local
snapshots. Figure 3 shows agent snapshot points corresponding to a
consistent cut, and figure 4 shows inconsistent snapshot points. 
<figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.003.jpeg"
alt="Fig3" style="width:80%"> 
    <figcaption>Fig.3: Consistent Local Snapshots</figcaption>
</figure>
<figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.004.jpeg" alt="Fig4" style="width:80%">
    <figcaption>Fig.4: Inconsistent Local Snapshots</figcaption>
</figure>
The global snapshot algorithm can have local snapshots, such as those in
figure 3, that result in consistent cuts. And the algorithm must
disallow local snapshots, such as in figure 4, that result in
inconsistent cuts.

<h3 class="w3-text-teal">Theorem: Channel Counts and Consistent
Cuts</h3>
When an agent takes its local snapshot, for each outgoing channel
\(C\) of the agent let \(C_{s}\) be the number of
messages that the agent has sent along \(C\), and for each incoming channel
\(C\) let \(C_{r}\) be the number of
messages that it has received along \(C\).
<hr class="new2">
<h5 style="color:blue;">
The points at which local snapshots are taken forms a
<i>consistent</i> cut if and only if, for all channels \(C\):
<p>
\(C_{s} \geq C_{r}\)
</h5>
<hr class="new2">
The proof follows directly from the definition of consistent cuts. We
will show that a
message sent in the future is received in the future.
<p>
A message received along a channel \(C\) in the future is a message received after
\(C_{r}\) messages have been received along the channel.
A message sent along a channel \(C\) in the future is sent after
\(C_{s}\) messages have been sent along the channel.
Because channels are first-in-first-out this message is received after 
\(C_{s}\) messages have been received along the channel, and therefore
the receive event is also in the future.

    <h3 class="w3-text-teal">Global Snapshot Algorithm</h3>
The algorithm employs a special kind of message called a <i>marker</i>
which is distinct from all other messages in the system.
Each agent takes its local snapshot exactly once and exactly one
marker is sent along each channel.

<p>
The steps are:
<ol>
  <li>
  The algorithm begins by one or more agents taking their local snapshots.
  </li>
  <li>
  When an agent takes its local snapshot it sends a <i>marker</i> on each
  of its outgoing channels.
  </li>
  <li>
  When an agent receives a marker, the agent takes its local snapshot
  if it has not already done so.
  </li>
</ol>
We assume that there is a path of directed channels from each agent to every
other agent so that all agents receive markers eventually.

<h3 style="color:red;">Example</h3>
Figure 5 illustrates the algorithm. In this example, there is exactly one channel
between from each agent to each different agent. When B takes its
snapshot it sends markers
to A and C. Markers are shown as green edges.
Agent C takes its snapshot when it receives the marker
which ensures that C's snapshot is before event 11.

    <figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.005.jpeg" alt="Fig5" style="width:80%">
    <figcaption>Fig.5: Markers ensure cuts are consistent</figcaption>
</figure>
When agents B and C receive markers they take their snapshots if they
    haven't done so already, and send markers in their turn. These
markers are shown in the next figure.



    <figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.006.jpeg" alt="Fig6" style="width:80%">
    <figcaption>Fig.6: Showing all Markers</figcaption>

<h4 class="w3-text-teal">Proof of correctness</h4>
The points at which agents take their snapshots form a cut where
events on an agent's timeline before the agent takes its snapshot are
past events.  A cut is consistent exactly when all messages sent in
the future are received in the future.
<p>
Let \(m\) be a message sent in a future event. We will prove that
\(m\) is received in a future event.

<p>
Because \(m\) is sent in a future event, \(m\) is sent after the
sender takes its snapshot.  When an agent takes its snapshot it sends
markers on all its outgoing channels.  So, \(m\) is sent along a
channel after the sender sends a marker on that channel.

<p>
Channels are first-in-first-out.  So the receiver gets \(m\) after
receiving a marker.  And so the receiver gets \(m\) after the receiver
takes its snapshot.  Events after an agent takes its snapshot are
future events.  Therefore \(m\) is received in the future.

<h3 class="w3-text-teal">Snapshots of Channels</h3>
Next we look at how the algorithm records snapshots of channels.  From
the timeline theorem, the sequence of messages in the channel in a
global snapshot are the messages sent on the channel in the past and
received on the channel in the future.

<p>
Messages sent in the past are messages sent before the sender takes
its snapshot.  Messages received in the future are messages received
after the receiver takes its snapshot.  So, the messages in the
channel in a snapshot are the messages sent before the sender takes
its snapshot and received after the receiver takes its snapshot.

<p>
When an agent takes its local snapshot it sends a marker on each of
its outgoing channels.  So, messages sent along a channel in the past
are messages sent before a marker is sent along that channel.

<p>
Because channels are first-in-first-out, messages sent along a channel
in the past are messages received along the channel before a marker is
received along that channel. Therefore, the messages in a channel in
a snapshot are the messages that the receiver receives along the
channel after the receiver takes its local snapshot and before the
receiver receives a marker on that channel.

<h4 class="w3-text-teal">Algorithm to Record Channel States</h4>
Let \(c\) be a channel, and let \(c\) be directed towards an agent
\(B\).
The snapshot of \(c\) is determined by \(B\) as the sequence of
messages that \(B\) receives after \(B\) takes its local snapshot and
before \(B\) gets a marker along \(c\).

<p>
Note: If \(B\) takes its local snapshot when it receives a marker
along \(c\), then the snapshot of \(c\) is the empty sequence.

<h3 style="color:red;">Example: Channel Snapshot</h3>
A diagram that illustrates the process by which an agent gets a
snapshot of an incoming channel is shown below. The diagram shows the
timelines for two agents, \(A\) and \(B\).

<p>
Agent \(A\) sends messages \(m_{0}, m_{1}, m_{2}\), then sends a
marker (colored green), and then message \(m_{3}\), to agent \(B\) on a
channel \(x\). All the messages in the diagram are sent on the same
channel.

<p>
The events shown as blue circles on \(A\)'s timeline are
events in which \(A\) sends messages \(m_{0}, m_{1}, m_{2}\) before
\(A\) takes its local snapshot.  The event shown as a black circle
shows \(A\) sending messages \(m_{3}\) after \(A\) takes its local
snapshot. The point at which \(A\) takes its local snapshot is the
point at which the purple wavy line (the cut) crosses \(A\)'s timeline.

    <figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.007.jpeg" alt="Fig7" style="width:100%">
    <figcaption>Fig.7: Snapshot of a channel</figcaption>
    </figure>

The event shown as a yellow circle on \(B\)'s timeline represents the
event in which \(B\) receives messages \(m_{0}\) before \(B\) takes its
own snapshot. The events shown as orange circles represent events in
which \(B\) receives messages \(m_{1}, m_{2}\) after \(B\) takes its
own snapshot and before \(B\) receives the marker. The black event
represents \(B\) receiving message \(m_{3}\) after \(B\) takes its
snapshot.

<p>
The messages that \(A\) sent in the past are \(m_{0}, m_{1}, m_{2}\).
The messages that \(B\) receives in the future are \(m_{1}, m_{2},
m_{3}, \ldots\).
The state of the channel, at the cut, is the sequence of messages \([m_{1},
m_{2}]\) that \(A\) sent in the past and that \(B\) receives in the
future.
This is shown as the sequence of red message lines that
cross the wavy purple line which represents the global snapshot.
These are the messages that \(B\) receives after it takes its local
snapshot and before it receives the marker.

<p class="w3-text-teal">Collecting Local Agent and Channel Snapshots</p>
Algorithms by which agents collect local snapshots of agents and
channels and then form global snapshots are presented later.
One of many applications of global snapshots is to checkpoint a
distributed computation so that the computation can be restarted from
the checkpoint if a transient event occurs.

<h4 style="color:blue;">Review</h4>
<ol>
  <li>
  The specification of the global snapshot algorithm is that the state
  \(s_{snap}\) obtained by the algorithm must be the state of a
  consistent cut. Why is this specification useful?
  </li>
  <li>
  Related question. A consequent property is:
  There exists a trajectory from \(s_{init}\) through \(s_{snap}\) to
  \(s_{fini}\). How do you think this property can be used?
  </li>
  <li>
  Prove the theorem on channel counts to yourself:
  The points at which local snapshots are taken forms a
  <i>consistent</i> cut if and only if, for all channels \(C\):
  \(C_{s} \geq C_{r}\).
  </li>
  <li>
  How does the global snapshot algorithm record states of channels?
  </li>
</ol>
  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
