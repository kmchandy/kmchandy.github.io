<!DOCTYPE html>
<html lang="en">
<title>ChannelSnapshots</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
</style>
<body>


<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()"><i class="fa fa-bars"></i></a>
    <a href="../index.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">About the Course</a>
    <a href="../table_of_contents.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">Table of Contents</a>
    <a href="../cross_reference.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Index</a>
  </div>
  </div>
 

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left" id="mySidebar">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="Close Menu">
    <i class="fa fa-remove"></i>
  </a>

  <!-------------------------->
  <h3 class="w3-bar-item"><b>An Introduction to Distributed
  Algorithms</h3>
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="ChannelSnapshots.html">Global Snapshots with Channels</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="ChannelSnapshotsExample.html">Examples</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="ChannelSnapshotsSelfTest.html">Self Test</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="ChannelSnapshotsExercises.html">Exercises</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="ChannelSnapshots.html">Explorations</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="../Channels/Channels.html">
  Next: Termination Detection</a> 
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="../Channels/Channels.html">Previous:
  Message-Passing Channels
  </a>
  
</nav>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
  <div class="w3-row w3-padding-64">
  <div class="w3-twothird w3-container">

    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">Global Snapshots and Logical Clocks with Channels</h1>

    This module adapts the algorithm given in 
    <a href="../GlobalSnapshots/GlobalSnapshots.html"> the module on
    global snapshots</a> to the case where all shared variables are
    channels. The adapted algorithm is simpler.

    We also review 
    <a href="../LogicalClocks/LogicalClocks.html"> timestamps and
    logical clocks</a> for the case of channels.

    
    <h4 class="w3-text-teal">Global Snapshot</h4><p>
    These paragraphs are largely a repetition of <a
    href="../GlobalSnapshots/GlobalSnapshots.html">the description of
    snapshots for the general case</a>. The repetition
    helps, however, in understanding why the channel algorithm
    is simpler.

    <p class="w3-text-teal">Specification</p>
    The specification of a global snapshot is as follows: If a global
    snapshot algorithm is initiated in a state 
    \(s\) and ends in state \(s'\), and the global snapshot obtained
    is \(c\), then there must exist a trajectory that starts in \(s\), then visits state
    \(c\), and ends in the state \(s'\).

    <p>
    From the specification, the state at a valid cut is a global
    snapshot. So, let's design an algorithm
    that determines a valid cut.
    First let's understand what causes a cut to be
    invalid. Here's the example from the previous module.

    <figure>
    <img src="ChannelSnapshots_1.jpg" alt="Fig1" style="width:80%">
    <figcaption>Fig.1: An invalid cut of a timeline</figcaption>
    </figure>

    <p>
    The point at which agents take their snapshots are the points
    at which the curvy purple line crosses the agent timelines; these
    points are marked as yellow circles.
    This cut is invalid because there is an edge \((10, 11)\) from an
    event \(10\) <i>after</i> agent \(B\) takes its snapshot to an event
    \(11\) <i>before</i> agent \(C\) takes its snapshot.
Next, let's look at
    an algorithm that avoids this situation. The algorithm has the
    following rules.

<h3 class="w3-text-teal">Global snapshot algorithm with channels</h3>
<ol>
  <li>
  The algorithm begins by at least one agent recording its state. An
  agent can record its state at any point if it hasn't done so
  already.
  </li>
  <li>
  When an agent records its state it sends a special message on each
  of its outgoing channels. We call this message a <i>marker</i>. A
  marker is distinct from all other messages.
  </li>
  <li>
  An agent that hasn't recorded its state does so when it receives a
  marker.
  </li>
  <li>
  An agent records the states of all channels directed towards it. The
  state of a channel recorded by the agent is the sequence of messages
  that the agent receives along the channel after the agent records
  its state and before it receives a marker along the channel.
  </li>
</ol>


    <figure>
    <img src="ChannelSnapshots_2.jpg" alt="Fig2" style="width:80%">
    <figcaption>Fig.2: Markers ensure cuts are valid</figcaption>
    </figure>

<h3 class="w3-text-teal">Snapshots of Channels</h3>
The snapshot of a channel \(C\) from an agent \(A\) to an
agent \(B\) is the sequence of messages that \(A\) sends along \(C\)
before \(A\) takes its local snapshot that are received by \(B\) after
\(B\) takes its local snapshot. The proof that the algorithm records
this state for channel \(C\) is given next.

<p>Proof</p>

As described in step 4, \(B\) records the state of its incoming
channel \(C\) as the sequence of messages that \(B\) receives along
\(C\) after \(B\) records its state and before \(B\) receives a marker
along channel \(C\). From the algorithm, the messages that \(A\) sends
before it sends the marker are the messages that \(A\) sends before
\(A\) takes its local snapshot.  Since channels are
first-in-first-out, the sequence of messages that \(B\) receives along
\(C\) before \(B\) receives a marker along \(C\) is the sequence of
messages that \(A\) sends along \(C\) before \(A\) takes its local
snapshot. The result follows.

<h3 style="color:red;">Example</h3>
A diagram that illustrates the process by which an agent gets a
snapshot of an incoming channel is shown below. The diagram shows the
timelines for two agents, \(A\) and \(B\).

<p>
Agent \(A\) sends messages \(m_{0}, m_{1}, m_{2}\), then sends a
marker (colored green), and then message \(m_{3}\), to agent \(B\) on a
channel \(C\). All the messages in the diagram are sent on the same
channel.

<p>
The events shown as blue circles on \(A\)'s timeline are
events in which \(A\) sends messages \(m_{0}, m_{1}, m_{2}\) before
\(A\) takes its local snapshot.  The event shown as a black circle
shows \(A\) sending messages \(m_{3}\) after \(A\) takes its local
snapshot. The point at which \(A\) takes its local snapshot is the
point at which the purple wavy line crosses \(A\)'s timeline.

    <figure>
    <img src="ChannelSnapshots_3.jpg" alt="Fig3" style="width:100%">
    <figcaption>Fig.3: Snapshot of a channel</figcaption>
    </figure>

The event shown as a yellow circle on \(B\)'s timeline represents the
event in which \(B\) receives messages \(m_{0}\) before \(B\) takes its
own snapshot. The events shown as organge circles represent events in
which \(B\) receives messages \(m_{1}, m_{2}\) after \(B\) takes its
own snapshot and before \(B\) receives the marker. The black event
represents \(B\) receiving message \(m_{3}\) after \(B\) takes its
snapshot.

<p>
The snapshot of the channel is the sequence of messages \([m_{1},
m_{2}]\). This is shown as the sequence of red message lines that
cross the wavy purple line which represents the global snapshot. The
diagram shows that this sequence is the one obtained by the algorithm.



<h2 class="w3-text-teal">Logical clocks with channels</h2>
Logical clocks with channels are as described in
<a href="../LogicalClocks/LogicalClocks.html">the module on logical
clocks for the general case.</a> The key idea is repeated here for
convenience.

<p>
The algorithm allocates a time to each point in each
agent's timeline. So, the algorithm also allocates a time at which
each agent sends and receives each message.

<p>
Agents may have internal
events in which it doesn't send or receive a message. Internal events
are arbitrary.
An example of an
internal event is one in which a local physical clock ticks forward.

<p class="w3-text-teal">The algorithm</p>
When an agent with a local timestamp of \(t\) is about to send a
message it appends the timestamp \(t+1\) to the message. When an agent
with timestamp \(t\) 
receives a message with timestamp \(t'\), the agent sets its timestamp
to the larger of \(t\) and \(t'\).


<h3 style="color:red;">Example</h3>
The figure below shows an example of timestamps or logical-clock
values. Each point on the timeline graph for each agent is assigned a
timestamp. The top timeline is for agent \(A\) and the bottom one for
agent \(B\). The timestamps for both agents initially is 0.

<p>
Agent \(A\) executes two internal events and then sends a message
along a channel \(C\) to agent \(B\). The points in \(A\)'s timeline
after the first event and before the second event have timestamp 1.
Likewise, the points in \(A\)'s timeline
after the second event and before the third event have timestamp 2.
When \(A\) then sends a message it timestamps the message with 3. This
is shown by the red message line.

<figure>
    <img src="ChannelSnapshots_4.jpg" alt="Fig4" style="width:80%">
    <figcaption>Fig.4: Assigning times to points on timelines</figcaption>
</figure>


<p>
Agent \(B\) executes a single internal event and then receives the
message that \(A\) sent. The timestamp on \(B\)'s timeline immediately
after \(B\) executes its first event is 1. When \(B\) receives the
message with timestamp 3, it sets the timestamp at that point on its
timeline to 3. We can assign timestamps arbitrarily to the edge
after \(B\) sets its timeline to 1 and before it sets its timeline to
3. For example, we can pick any point on the edge at which the
timestamp increases from 1 to 2, and likewise, pick any point at which
the timestamp increases from 2 to 3. The points of these transitions
doesn't matter because the state remains unchanged through these
points.

<p>
The explanation of the remaining timestamps is not given because it is
straightforward. 

<figure>
    <img src="ChannelSnapshots_5.jpg" alt="Fig5" style="width:80%">
    <figcaption>Fig.5: Timestamp of t corresponds to a valid cut</figcaption>
</figure>

The figure above shows that each timestamp of \(t\) corresponds to a
valid cut. And, the sequence of global states corresponding to
timestamps \(0, 1, 2, \ldots \) is a trajectory of the system.

<p>
Each cut is shown by a wavy purple line. The cut corresponding to
timestamp \(t\) passes through points on agent timelines with value
\(t\). Only the cuts for timestamps \(0, \ldots, 4 \) are shown.



  <footer id="myFooter">

    <div class="w3-container w3-theme-l1">
      <h4>An Introduction to Distributed Algorithms by K. Mani Chandy,
      <br>
      Simon Ramo Professor, Emeritus, California Institute of Technology</h4>
    </div>
  </footer>


      


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>

