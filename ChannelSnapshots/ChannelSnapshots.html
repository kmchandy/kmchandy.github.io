<title>ChannelSnapshots/ChannelSnapshots.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">



<!--------------------------------------------------------->
<h1 class="w3-text-teal">A Global Snapshot Algorithm</h1>
<!--------------------------------------------------------->


  
  <!------------------------------------------------------------------->
  
  <p class="w3-text-red">

  A global snapshot is the system state at an input-closed set of
  events.

  Many distributed algorithms are based on monitoring systems by
  scheduling repeated global snapshots.

  </p>
 
  <!-----------------------------------------------------------------------------> 
  <h3 class="w3-text-teal">Global Snapshot</h3> 
  <!----------------------------------------------------------------------------->
  <p>
We describe an algorithm by which agents collaborate to determine
the global state at an input-closed set of events; this state is
  called a <i>global snapshot</i>.

  <p>
  Global snapshots are used in many distributed algorithms.
  
  When a transient error is detected in a computation the operating
  system rolls the computation back to the most recent global snapshot
  of the computation instead of rolling the computation back to its
  initial state.

  An operating system detects whether a client has
  terminated execution by inspecting a global snapshot of the client's
  computation.


  <!-----------------------------------------------------------------------------> 
  <h5 class="w3-text-teal">The Operating System Records Global
  Snapshots of its Clients</h5> 
<p>
The global snapshot algorithm is executed by a distributed operating
  system (OS) on behalf of a client.
  
  Each client agent has an OS agent that supervises it.

  OS agents use the same processors and channels as clients do.
  
  OS agents can record, but not modify, states of their clients.
  
  OS agents can send and receive OS messages that are not seen
by clients.

<p>
The figure is a representation of two OS agents that manage their
client agents.

Messages sent by a client are recorded by the OS and passed through
to destination clients.

The OS sends messages on the same channels as clients, but the OS
traps these messages so that the client does not see them.


<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.001.jpeg" alt="Fig1"
    style="width:80%"> 
    <figcaption>Fig.1: OS and Clients use the same Channels</figcaption>
</figure> 

  <p>
  Execution of an OS agent on a processor may delay a client's
  events on the same processor, and thus change the order in which the
  client's events are executed. 

The OS may change the client's computation.

<i>OS algorithms must not change the client's dataflow.</i>
  
  <p>
  One way to record a global snapshot is for the OS to stop a client
  computation, then take a global snapshot, and then  restart the
client computation.

We describe a snapshot algorithm that does not stop the client.

<p>
Hereafter, when we refer to an agent we mean an OS agent that operates
on behalf of a client agent.
 
<!----------------------------------------------------------------------------->
<h5 class="w3-text-teal">Local Snapshots of Agents</h5>
<!----------------------------------------------------------------------------->

Each agent records its own local state, at
some point in the computation, and does so exactly once.

An agent's record of its local state is called the <i>agent's local
snapshot.</i>

An agent's events before it takes its local snapshot are called
pre-snapshot events, and events after the local snapshot are
called post-snapshot events.


<!--------------------------------------------------------->
<h4 style="color:red;">Example: Snapshots change Client's Computation
</h4>
Figure 2 is a representation of a computation with event sequence
\([0, 1, 2, \ldots, ]\) and agents \(X, Y, Z\).

The computation is shown as a dataflow graph.

Events later in the computation are placed to the
right of earlier events.

Message edges from each agent to itself are not shown.

This computation does not show the effect of OS operations.


<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.002.jpeg" alt="Fig2"
    style="width:80%"> 
<figcaption>
Fig.2: Representation of a Computation without Snapshots
</figcaption> 
</figure> 


<p>
Figure 3 shows how a client's computation is changed when the OS takes
snapshots. 

The local snapshots taken by agents are shown as a yellow
circle on the agents' timelines.

The OS delays event 3 so that it occurs after events 4, 5, 6, and 7,
as shown in the figure.

The OS changes the computation, but it does not change the dataflow.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.003.jpeg" alt="Fig2"
    style="width:80%"> 
    <figcaption>Fig.3: Impact of OS on a Client's Computation</figcaption>
</figure> 

In figure 2, the pre-snapshot events are 0, 1, 2, 4, 6.

There is only one message received in a pre-snapshot
event, namely the message represented by the edge (0, 2).

So, every message received in a pre-snapshot event is sent in a
pre-snapshot event.

The figure shows that the set of pre-snapshot events is input closed.


<!--------------------------------------------------------->
<h4 style="color:red;">Example: Pre-Snapshot Event Set that is not Input
Closed</h4> 
The pre-snapshot events in figure 3 are 0, 1, 2, 5, 7.

The dataflow graph has a message edge directed from a
post-snapshot event, 6, to a  pre-snapshot event, 7.

This set of pre-snapshot events is not input closed.
<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.004.jpeg" alt="Fig4"
    style="width:80%"> 
    <figcaption>Fig.4: Example: Set of Pre-Snapshot Events that is
    not Input-Closed</figcaption>
</figure>
The figures suggest the following theorem.


  <h3 class="w3-text-teal">The Global Snapshot Theorem</h3>
<p class="w3-text-teal">
The set of pre-snapshot events is input-closed if each message received
in a pre-snapshot event is sent in a pre-snapshot event.
</p>

  
<p class="w3-text-teal">Proof</p>
 

From the definition of local snapshots, an agent edge to a
pre-snapshot event at an agent \(u\) is from a
pre-snapshot event at \(u\).

From the condition of the theorem, a message edge to a pre-snapshot
event is from a pre-snapshot event.

<h3 class="w3-text-teal">Alternate Versions of the Global Snapshot
Theorem</h3>
A set of pre-snapshot events is (obviously) not input-closed if a
message sent in a post-snapshot event is received in a pre-snapshot
event.

<p>
The global snapshot theorem is used so often that we highlight it, and
give alternative versions of it.

<hr class="new2">
<p style="color:blue;">
The set of pre-snapshot events is input-closed if and only
if any one of the following conditions holds.
<ol>
  <li>
  <p style="color:blue;">
Each message received in a pre-snapshot event is sent in a
pre-snapshot event.
  </li>
  <li>
<p style="color:blue;">
Each message sent in a post-snapshot event is received in a
  post-snapshot event.
  </li>
  <li>
  <p style="color:blue;">
  For all channels \(C\),  \(\; C_{s} \geq C_{r}\), where \(C_{s}, C_{r}\)
  are the numbers of messages 
  sent and received (respectively) on the channel in pre-snapshot
  messages.
  </li>
  <li>
  <p style="color:blue;">
  In graphical terms, all edges that cross the boundary separating
  pre- and post-snapshot events in the dataflow graph are directed
  from pre- to post-snapshot events.
  </li>
</ol>
</p>
<hr class="new2">


<h3 class="w3-text-teal">A Global Snapshot Algorithm</h3>

The global snapshot theorem suggests the following algorithm which
uses a special OS message called a <i>marker</i>.

<ol>
  <li>
  The algorithm begins by one or more agents taking their local
  snapshots.
  </li>
  <li>
  When an agent takes its local snapshot it sends a marker on each
  of its outgoing channels. 
  </li>
  <li>
  When an agent receives a marker, the agent takes its local snapshot
  if it has not already done so. 
  </li>
</ol>

<p class="w3-text-teal">Proof of Correctness</p>
From rule 2, all messages sent on a channel after a marker is sent on
the channel are sent in post-snapshot events.  From rule 3, all
messages received on a channel after a marker is received on the
channel are received in post-snapshot events.  Therefore, all messages
sent in post-snapshot events are received in post-snapshot events.
From version 2 of the global snapshot theorem, the set of pre-snapshot
events is input closed.


<h5 class="w3-text-teal">Snapshots of Channels</h5>
The messages in a channel at the state of an input-closed event set are the
messages sent by events in the set and received by events outside the
the set.

So, the state of a channel in a snapshot is the sequence of
messages received along the channel after the receiver takes its local
snapshot and before the receiver receives a marker along the channel.

<p>
Note: If an agent takes its local snapshot when it receives a marker
along a channel, then the snapshot of the channel is the empty
sequence of messages.


<p class="w3-text-teal">All agents take their local snapshots</p>
After any agent \(v\) initiates the algorithm, all agents that are
reachable from \(v\) will receive a marker and take their local
snapshots.

All agents take their local snapshots if every agent is reachable from
an initiator along a sequence of channels.



<p class="w3-text-teal">Collecting Local Agent and Channel
Snapshots</p>
Each agent takes its own local snapshot and the snapshots of its
incoming channels.

In some algorithms, agents send snapshots of their states and 
input channels to a collector agent.

The collector forms the global snapshot by composing the local state
information that it receives.

Other algorithms carry out distributed computations on local
snapshots without sending data to a collector.

We will design both kinds of algorithms.




<!---------------------------------------------------------->
<h4 style="color:red;">Example: Steps in a Global Snapshot
Algorithm: Initiation</h4>
<!---------------------------------------------------------->

Figure 5 illustrates the first step of the algorithm.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.005.jpeg" alt="Fig5"
    style="width:100%"> 
    <figcaption>Fig.5: Agent Sends Markers when it Takes its Local
    Snapshot</figcaption> 
</figure>

Agent Y takes its local snapshot shown as a yellow vertex on Y's
timeline.

When Y takes its snapshot it sends markers on its output channels.

The markers are shown as green edges in the figure.


<p>
When agents X and Z each receive the markers, they take their local
snapshots because they haven't taken snapshots earlier.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.006.jpeg" alt="Fig6"
    style="width:100%"> 
<figcaption>
Fig.6: Agents Take Local Snapshots when they Receive Markers
</figcaption>
</figure>

The actions by X and Z of taking their snapshots are shown as yellow
vertices on their timelines in figure 6.


<!--------------------------------------------------->
<h4 style="color:red;">Example: Agents take Snapshots upon Receiving Markers</h4> 
<!--------------------------------------------------->
<p>
When X and Z take their snapshots they send markers out on their
output channels.

The markers sent by X are shown in figure 7.

The markers sent by Z are not shown in the figure.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.007.jpeg" alt="Fig7"
    style="width:100%"> 
    <figcaption>Fig.7: When an Agent takes its Snapshot it sends Markers.
    </figcaption>
</figure>



<!--------------------------------------------------->
<h4 style="color:red;">Example: Snapshot of a Channel</h4> 
<!--------------------------------------------------->
<p>
Figure 8 shows how agent Y determines the state of the channel from X
to Y in the global snapshot.

Y starts recording the messages it receives along this channel after Y
takes its snapshot and stops the recording when it receives a marker
on this channel

The only message in this interval is the message corresponding to edge
(6, 7).


<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.008.jpeg" alt="Fig8"
    style="width:100%"> 
<figcaption>
Fig.8: Example: Recording a Channel State
</figcaption>
</figure> 

The message corresponding to edge \((0, 2)\) is from X to Y but is not
in the snapshot of 
the channel because both \(0\) and \(2\) are pre-snapshot events.

Likewise, the message corresponding to edge \((12, 13)\) is from X to
Y but is not in the snapshot of
the channel because both \(12\) and \(13\) are post-snapshot events.

The message corresponding to edge \((6, 7)\) was sent in a
pre-snapshot event and received in a post-snapshot event, and so it is
in the snapshot of the channel.



<!--------------------------------------------------------------->
<h4 class="w3-text-teal">Key Properties of Global Snapshot Algorithms</h4>
<!--------------------------------------------------------------->

<p>
Let \(H_{pre}\) be any set of events that are completed before a snapshot
algorithm is initiated.

Let \(H_{post}\) be a set of events that have been completed after a snapshot
algorithm is initiated.

Let the snapshot be the state at an input-closed event set \(H_{snap}\).

Then \(H_{pre} \subseteq H_{snap} \subseteq H_{post}\).

From
<a href="../DISTRIBUTED_SYSTEM_MODELS/Timelines.html">
computations between sets of operations
</a>
there are computations from \(H_{pre}\) to \(H_{snap}\), and from
\(H_{snap}\) to \(H_{post}\).


<p>
These results are used so frequently that we highlight them here.

<hr class="new2">
<h5 style="color:blue;">

<ol>
  <li>
  There exists a computation from the state in which the
  global snapshot algorithm is initiated to the global snapshot. 
  </li>
  <li>
  There exists a computation from the global
  snapshot to the state at which the global snapshot
  algorithm terminates.
  </li>
</ol>
</h5>
<hr class="new2">
Though OS operations may change a client's computation, there exists a client
computation that includes OS operations.


<!--------------------------------------------->
  <h3 class="w3-text-teal">System Monitoring</h3>
<!--------------------------------------------->
<p>
<i>
Monitoring systems by taking repeated snapshots is the basis of
many distributed algorithms.
</i>

<p>
We give some examples of algorithms based on system monitoring.

<p class="w3-text-teal">Rollback and Recovery</p>
From the first key property of global snapshots:
There exists a computation from the initial state of the computation
to a global snapshot.

So, when a transient error occurs, a rollback and recovery algorithms
restarts the computation at the most recent snapshot instead of restarting
it from the beginning.

<p class="w3-text-teal">Detecting Stable Properties</p>
If a stable property holds at any point in any computation then it
continues to hold forever in that computation.

For example, if a computation has terminated then it remains
terminated.

Likewise, if a cycle of agents is deadlocked then it remains deadlocked.

We discuss stable properties in detail later.

<p>
One way to detect stable properties is to monitor the system by
taking snapshots repeatedly.

If the system deadlocks then all snapshots taken after the deadlock occurs
show that the system has deadlocked.

If a snapshot shows that the system has deadlocked then the
system is indeed deadlocked at that point.

<p>
This method for detecting stable properties has two phases (1)
obtain a global snapshot, and (2) analyze the global snapshot.

The first phase reduces analysis of a dynamic system into the analysis
of static snapshot.

The second phase analyzes static data structures.


<h4 class="w3-text-teal">Next</h4>
Next  
<a href="LogicalClocks.html">logical clocks</a>.

  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>



</body>
</html>
