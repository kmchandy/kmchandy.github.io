<title>ChannelSnapshots/ChannelSnapshots.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">



<!--------------------------------------------------------->
<h1 class="w3-text-teal">Global Snapshots and State Detection</h1>
<!--------------------------------------------------------->

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/DISTRIBUTED_SYSTEM_MODELS/Timelines.html">
  Timelines.
</p>

<a href="GlobalSnapshotAlgorithmVideo.mp4">
<h3 class="w3-text-teal">Video</h3>
  </a>

  
  <!------------------------------------------------------------------->
  <h4 class="w3-text-red">
  <i>Central Ideas</i></h4>

  <p class="w3-text-red">
  (1) Global snapshots: states at consistent cuts. (2) System
  monitoring. (3) Detection algorithms.
  
  <p class="w3-text-red">
  A global snapshot is the state at a consistent cut.

  Algorithms for obtaining global snapshots use marker or timestamp
  messages so that messages sent in the past are received in the past.

  Systems can be monitored by scheduling global snapshots at times \(t\) for
  increasing \(t\).

  System monitoring can be used to solve all detection problems -- for
  example to detect whether agents deadlock or computations terminate.
  
  <!------------------------------------------------------------------->
  <h3 class="w3-text-teal">Specification of a Global Snapshot</h3>
  <hr class="new2">
  <h6 style="color:blue;">
  A global snapshot is any state \(S\) such that there exists a computation
  that starts in the state in which the snapshot algorithm starts,
  visits \(S\),
  and later visits the state in which the snapshot algorithm ends.
  </h6>
  <hr class="new2">
  
  <p>
  A global snapshot algorithm determines a global state of the
  system during a computation, without stopping or modifying the
  computation.
  The algorithm cannot, for instance, stop the distributed
  computation, record the state (i.e., the snapshot), and then restart
  the computation.
  <p>
  Let the states in which the algorithm starts and ends be
\(s_{init}\) and \(s_{fini}\), respectively, and let \(s_{snap}\) be
  the global state (the snapshot) recorded by the algorithm.
  The specification of \(s_{snap}\) is:

  <h5 style="color:blue;">
There exists a computation that starts in 
  \(s_{init}\) and then visits \(s_{snap}\) and later visits
  \(s_{fini}\).
  </h5>
  There may be an arbitary number of events between \(s_{init}\) and
  \(s_{snap}\), and an arbitary number of events between \(s_{snap}\) and
  \(s_{fini}\).

  <p>
  Though \(s_{snap}\) is determined while a computation
  is running, \(s_{snap}\) may not have occurred in the computation. The
  specification merely says that there <i>exists</i> a computation from
  \(s_{init}\) through \(s_{snap}\) to \(s_{fini}\), and this
  computation may not be the computation during which the snapshot is
  taken.
  What is the point of computing \(s_{snap}\) during a computation if
  it never occurred in the computation? We will answer this question later.


  <!-----------------------------------------------------------------------------> 
  <h3 class="w3-text-teal">A Global Snapshot is the State at a
  Consistent Cut</h3> 

  <p>
  From the <a
  href="../DISTRIBUTED_SYSTEM_MODELS/Timelines.html">theorem on
consistent cuts</a>:
A global snapshot is the state of a system at a consistent cut of a
computation. So, let's design an algorithm by which agents
collaborate to determine a consistent cut.

</p>
  Each agent takes its own local snapshot, i.e. records its own local
  state, at a point in the computation.
  Define <i>past</i> events to be the events at an
  agent before the agent takes its own local snapshot.

  <p>
  Edges in an agent's timeline from events after the agent's snapshot
  are (obviously) to events after the agent's snapshot.
Therefore the cut is consistent if it satisfies the
  following condition:

<hr class="new2">
<h6 style="color:blue;">
Consistent cut requirement:
<br>
All messages sent after the sender takes its local snapshot
are received after the receiver takes its local snapshot.
</h6>
<hr class="new2">

<p>
Next, we use the consistent cut requirement to design a global
snapshot algorithm. 
The algorithm employs a special type of message called a <i>marker</i>,
distinct from all other messages in the system.
Exactly one
<i>marker</i> is sent along each channel.

<h3 class="w3-text-teal">A Global Snapshot Algorithm</h3>
<ol>
  <li>
  The algorithm begins by one or more agents taking their local
  snapshots.
  </li>
  <li>
  When an agent takes its local snapshot it sends a <i>marker</i> on each
  of its outgoing channels.
  </li>
  <li>
  When an agent receives a marker, the agent takes its local snapshot
  if it has not already done so.
  </li>
</ol>

<h5 class="w3-text-teal">Proof: Algorithm satisfies the Consistent Cut
Requirement</h5>
A message sent after the sender
takes its local snapshot is sent after the sender sends
markers.
Because channels are first in first out, a message that is sent after
a marker is sent
is received after the marker is received.
When an agent receives a marker the agent takes its local snapshot if it hasn't done
so.
Therefore, a message sent after the sender
takes its local snapshot is received after the receiver takes its
local snapshot.

<p>
We assume that the directed graph of agents (vertices) and channels
(edges) is strongly connected, and so the algorithm sends a marker on
every channel, and every agent takes its local snapshot.



<h4 style="color:red;">Example</h4>
Figure 1 illustrates the algorithm. In this example, there are three
agents -- A, B, and C -- and there is exactly one channel
 from each agent to every other agent. When agent B takes its
snapshot it sends markers
to agents A and agents C. Markers are shown as green edges.
Agent C takes its snapshot when it receives the marker
which ensures that agent C's snapshot is before event 11.

    <figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.005.jpeg" alt="Fig5" style="width:80%">
    <figcaption>Fig.1: Markers ensure cuts are consistent</figcaption>
</figure>
When agents B and C receive markers they take their snapshots if they
    haven't done so already, and send markers in their turn. These
markers are shown in the next figure.

    <figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.006.jpeg" alt="Fig6" style="width:80%">
    <figcaption>Fig.2: Showing all Markers</figcaption>

<h3 class="w3-text-teal">Snapshots of Channels</h3>
Next we look at an algorithm to record snapshots (states) of channels
at a cut.  The messages in the channel at a cut are the messages sent on the channel in the past and
received on the channel in the future.

<p>
When an agent takes its local snapshot it sends a marker on each of
its outgoing channels.  So, messages sent along a channel in the past are
the messages sent on the channel before the marker is sent along the
channel.
Messages received in the future are the messages received after the
receiver takes its local snapshot.
Therefore:
<hr class="new2">
<h6 style="color:blue;">
The state of a channel at a cut is the sequence of messages
received along the channel after the receiver takes its local snapshot
and before the receiver receives a marker along the channel.
</h6>
<hr class="new2">
<p>
Note: If an agent takes its local snapshot when it receives a marker
along a channel, then the snapshot of the channel is the empty
sequence of messages.

<h4 style="color:red;">Example: Channel Snapshot</h4>
A diagram that illustrates the process by which an agent gets a
snapshot of an incoming channel is shown below. The diagram shows the
timelines for two agents, \(A\) and \(B\).

<p>
Agent \(A\) sends messages \(m_{0}, m_{1}, m_{2}\), then sends a
marker (colored green), and then message \(m_{3}\), to agent \(B\) on a
channel \(x\). All the messages in the diagram are sent on the same
channel.

<p>
The events shown as blue circles on \(A\)'s timeline are
events in which \(A\) sends messages \(m_{0}, m_{1}, m_{2}\) before
\(A\) takes its local snapshot.  The event shown as a black circle
shows \(A\) sending messages \(m_{3}\) after \(A\) takes its local
snapshot. The point at which \(A\) takes its local snapshot is the
point at which the purple wavy line (the cut) crosses \(A\)'s timeline.

    <figure>
    <img src="ChannelSnapshots_Figures/ChannelSnapshots_Figures.007.jpeg" alt="Fig7" style="width:100%">
    <figcaption>Fig.7: Snapshot of a channel</figcaption>
    </figure>

The event shown as a yellow circle on \(B\)'s timeline represents the
event in which \(B\) receives messages \(m_{0}\) before \(B\) takes its
own snapshot. The events shown as orange circles represent events in
which \(B\) receives messages \(m_{1}, m_{2}\) after \(B\) takes its
own snapshot and before \(B\) receives the marker. The black event
represents \(B\) receiving message \(m_{3}\) after \(B\) takes its
snapshot.

<p>
The messages that \(A\) sent in the past are \(m_{0}, m_{1}, m_{2}\).
The messages that \(B\) receives in the future are \(m_{1}, m_{2},
m_{3}, \ldots\).
The state of the channel, at the cut, is the sequence of messages \([m_{1},
m_{2}]\) that \(A\) sent in the past and that \(B\) receives in the
future.
This is shown as the sequence of red message lines that
cross the wavy purple line which represents the global snapshot.
These are the messages that \(B\) receives after it takes its local
snapshot and before it receives the marker.

<h4 class="w3-text-teal">Collecting Local Agent and Channel
Snapshots</h4>
Each agent takes its own local snapshot and the snapshots of its
incoming channels.
Some applications require a single agent to collect local
snapshots to form a global snapshot while other applications carry out
computations on local snapshots.
Algorithms that detect system properties by analyzing local snapshots
are given later.


<!--------------------------------------------------------------->
<!--------------------------------------------------------------->
<!--------------------------------------------------------------->

<h2 class="w3-text-teal">Monitoring Systems by Scheduling Snapshots</h2>
Sequences of checkpoints taken repeatedly at scheduled times
<a href="https://en.wikipedia.org/wiki/Cron">(cron jobs)</a>
help in monitoring systems.
A checkpoint of a distributed system is a global snapshot, and
scheduling repeated snapshots helps in many applications including
monitoring. 
The global snapshot taken
at time \(T\) is assigned timestamp \(T\) to
distinguish it from snapshots taken at other times.
The algorithm to get the snapshot at time
\(T\) is identical to the marker algorithm except that markers and
snapshots are assigned timestamp \(T\).


<!--------------------------------------------------------------->
<!--------------------------------------------------------------->
<h3 class="w3-text-teal">Algorithm to get the Snapshot at time \(T\)</h3>
All snapshots and markers in the algorithm below have timestamp
\(T\). 
<ol>
  <li>
  When an agent's clock reaches \(T\) the agent takes its local snapshot and sends
  markers on all its output channels. 
  </li>
  <li>
  When an agent receives a marker with timestamp \(T\), if the agent's
  local clock is earlier than \(T\) then the agent moves its local
  clock forward to \(T\), and (rule 1) the agent takes its local
  snapshot and sends markers on all its output channels.
  </li>
</ol>
Channel snapshots are computed as in the marker algorithm.

<h5 class="w3-text-teal">System Monitoring</h5>
Algorithms that schedule snapshots at \(T\) for increasing values of
\(T\) are <i>system monitoring algorithms.</i>
Agents clocks with a standard time server, such as
NTP, to ensure that the times at which snapshots are taken are close
to the true schedules times.


<h1 class="w3-text-teal">Applications of Snapshots</h1>
Next we give a few examples of snapshot applications.

<h4 class="w3-text-teal">Rollback and Recovery</h4>
If an error is detected during the execution of a computation then a
rollback and recover algorithm rolls the computation back to the most
recent checkpoint (global snapshot) and restarts the computation from
that point. 


<h3 class="w3-text-teal">The Detection Problem</h3>
The detection problem is to design an algorithm that detects
whether a computation is in a <i>stable</i> set of
states.

<p class="w3-text-teal">Stable set of States</p>
A <i>stable</i> set of states is a set \(P\) such that every transition from a
state in \(P\) is to a state in \(P\). There is no transition from
inside \(P\) to outside \(P\), and so after a computation visits a
state in \(P\) the computation remains forever in \(P\). The set of
states in which agents are deadlocked is  an example of a stable set:
there is no transition from a deadlocked state to a non-deadlocked
state.


<h3 class="w3-text-teal">Global Snapshots and State Detection</h3>
Let's look again at the specification of a global snapshot.
Let \(S_{init}\) and \(S_{fini}\) be the states of the computation at
which the snapshot algorithm starts and ends, respectively and let
\(S_{snap}\) be snapshot obtained by the algorithm.  There exists a computation that
visits \(S_{init}\), later visits \(S_{snap}\) and then later visits
\(S_{fini}\). So, for any stable set \(P\), if \(S_{init}\) is in
\(P\) then so is \(S_{snap}\).  Likewise, if \(S_{snap}\) is in \(P\)
then so is \(S_{fini}\).

<h5 class="w3-text-teal">Property of Global Snapshots</h5>
<hr class="new2">
<h6 style="color:blue;">
For any stable set \(P\) of states:
<ol>
  <li>
  If the snapshot algorithm starts when the system is in \(P\)
  then the snapshot is in \(P\).
  </li>
  <li>
  If the snapshot is in \(P\) then system is in \(P\) when the
  snapshot algorithm ends.
  </li>
</ol>
</h6>
<hr class="new2">

<p>
What do we know about the snapshot if the snapshot algorithm is
initiated when the system is outside a stable set \(P\) and enters
\(P\) while the snapshot algorithm is still running? In this case, the
specification doesn't tell us whether the snapshot will be in \(P\) or
not.

<p>
If the snapshot is in \(P\) then the system is in \(P\) when the
snapshot algorithm <i>ends</i>.  If the snapshot is not in \(P\) then
the system is not in \(P\) when the snapshot algorithm <i>begins</i>,
but we don't know whether the system is in \(P\) when the snapshot
algorithm <i>ends</i>.

<p>
If a snapshot is not in \(P\) then more
snapshots must be taken to detect whether the system may have entered
\(P\) after the last snapshot was initiated.
A general method to detect whether a system is in a stable set of
states is to monitor the system by scheduling repeated snapshots.


<h3 class="w3-text-teal">System Monitoring Solves All Detection
Problems</h3>
System monitors take
global snapshots repeatedly -- for example at scheduled times.
If the system state at any point in a computation is in a stable set \(P\)
then a later snapshot will be in \(P\).
And if any snapshot is in 
\(P\) then the system state at that point is in \(P\).

<h5 class="w3-text-teal">Examples of Detection Problems</h5>
System monitoring can be used to solve all detection problems
including those that detect whether:
<ol>
  <li> computation has terminated, </li>
  <li> computation has deadlocked, </li>
  <li> amount of crypto coins exceeds a constant \(n\), assuming the
  coins aren't destroyed </li>
  <li> clocks of all agents exceed a constant \(t\), assuming that
  clocks don't go backward.  </li>
</ol>
There may, however, be more efficient solutions for specific problems.
We discuss some of these problems in the following pages.

<h3 class="w3-text-teal">Specification of Detection Algorithms</h3>
A detection algorithm detects whether the state of a computation is in
a stable set \(P\). The algorithm uses a Boolean variable \(B\) which
is initially False and which is set to True when
the algorithm detects that the system is in \(P\) and remains True.
Once \(B\) becomes True it remains True forever thereafter. The
specification is:
<hr class="new2">
<h6 style="color:blue;">
<ol>
  <li>
  If at any point in a computation the system state is in \(P\) then
  there is a point in the computation after which \(B\) remains True.
  </li>
  <li>
  If \(B = True\) at any point in a computation then the system state
  at that point is in \(P\).
  </li>
</ol>
</h6>
<hr class="new2">
Next, we look at different detection algorithms that detect 
different stable sets. Detection algorithms, regardless
of application, are similar.


<h4 class="w3-text-red">
<i>Central Ideas: Review</i></h4>
<p class="w3-text-red">

A global snapshot is the state at a consistent cut.
Global snapshots can be obtained by 
taking a snapshot at timestamp \(T\) and the marker
algorithm.
Detection algorithms detect when the system state is in a stable set
of states.
System monitors that take repeated scheduled snapshots can be used to solve
detection problems. 

<p class="w3-text-red">
<i>Concepts</i>:
Timelines -> causality graphs -> consistent cuts -> global snapshot
algorithms -> detection algorithms.


<h4 class="w3-text-teal">Next</h4>
Next either look at two examples
 -- <a href="TerminationDetectionNew.html">termination</a> and
<a href="DatabaseDeadlockDetection.html">database deadlock</a>
detection --
of snapshots or
move to the next topic, 
<a href="LogicalClocksNew.html">logical clocks</a>.

  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>



</body>
</html>
