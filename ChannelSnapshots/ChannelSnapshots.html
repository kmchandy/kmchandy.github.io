<title>ChannelSnapshots/ChannelSnapshots.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">



<!--------------------------------------------------------->
<h1 class="w3-text-teal">A Global Snapshot Algorithm</h1>
<!--------------------------------------------------------->


  
  <!------------------------------------------------------------------->
  
  <p class="w3-text-red">

  A global snapshot is the system state at an input-closed set of
  events.

  Many distributed algorithms are based on monitoring systems by
  scheduling repeated global snapshots.

  </p>
 
  <!-----------------------------------------------------------------------------> 
  <h3 class="w3-text-teal">Global Snapshot</h3> 
  <!----------------------------------------------------------------------------->
  <p>
We describe an algorithm by which agents collaborate to determine
the global state at an input-closed set of events; this state is
  called a <i>global snapshot</i>.

  Global snapshots are used in many distributed algorithms.

  <p>
The global snapshot algorithm is an example of an algorithm that is
  executed by a distributed operating system (OS) on behalf of a
  client.

  Next, we describe features of the OS that are relevant to the
  snapshot algorithm.
  
  <!-----------------------------------------------------------------------------> 
  <h4 class="w3-text-teal">The Distributed Operating System</h4> 
<p>

  
  Each client agent has an OS agent that supervises it.

  OS agents use the same processors and channels as clients do.
  
  OS agents can record, but not modify, states of their clients.
  
  OS agents can send and receive OS messages that are not seen
by clients.

<p>
The figure is a representation of two OS agents that manage their
client agents.

Messages sent by a client are recorded by the OS and passed through
to destination clients.

The OS sends messages on the same channels as clients, but the OS
traps these messages so that the client does not see them.


<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.001.jpeg" alt="Fig1"
    style="width:80%"> 
    <figcaption>Fig.1: OS and Clients use the same Channels</figcaption>
</figure> 

  <p>
  Execution of an OS agent on a processor may delay a client's
  events on the same processor, and thus change the order in which the
  client's events are executed. 

<i>The OS may change a client's computation but
the OS must not change the client's dataflow.</i>
  
  <p>
  One way to record a global snapshot is for the OS to stop a client
  computation, then take a global snapshot, and then  restart the
client computation.

Our goal is to design an algorithm that does not stop the client.

<p>
Hereafter, when we refer to an agent we mean an OS agent.

Likewise, messages are sent and received by the OS and are invisible
to clients.



 
<!----------------------------------------------------------------------------->
<h4 class="w3-text-teal">How Should We Approach the Problem?</h4>
<!----------------------------------------------------------------------------->
The problem is to design an algorithm to record the state at an
input-closed set of events.

What solution strategies should we use?

When dealing with input-closed sets of events start with
<a href="Timelines.html">the theorem about past and future</a>.


<p>
In any snapshot algorithm, each agent must record its own local state at some
point in its computation because another agent cannot do so.

Let's look at the points at which agents take their local snapshots --
i.e., record their states.

The <i>past</i> is defined as the set of events at agents before these points.

So, an event at an agent, before the agent takes its snapshot, is in the
past.
And an event at an agent, after the agent takes its snapshot, is in the
future.

<p>
The theorem says that every message sent in the future must be
received in the future.

This gives us the key to the solution.

<hr class="new2">
<p style="color:blue;">
Local snapshots taken by agents form a global snapshot if
every message sent after the sender takes its local snapshot is
received after the receiver takes its local snapshot.
</p>
<hr class="new2">


 
<!----------------------------------------------------------------------------->
<h4 class="w3-text-teal">The Global Snapshot Algorithm</h4>
<!----------------------------------------------------------------------------->
The algorithm follows directly from the key insight.

The insight tells us that we must distinguish messages sent before the
sender takes its snapshot from those sent after the snapshot.

We use a special message called a <i>marker</i> for this purpose.

Markers are used only by the OS and are not seen by clients.

<p class="w3-text-teal">The algorithm</p>
<ol>
  <li>
  The algorithm begins by one or more agents taking their local
  snapshots.
  </li>
  <li>
  When an agent takes its local snapshot it sends a marker on each
  of its outgoing channels. 
  </li>
  <li>
  When an agent receives a marker, the agent takes its local snapshot
  if it has not already done so. 
  </li>
</ol>

<p class="w3-text-teal">Proof of correctness</p>
Channels are first in first out.

So, messages sent on a channel after a marker is sent on the channel
are received after the marker is received.

<p>
From rule 2, messages sent on a channel after a marker on the channel
are messages sent after the sender takes its snapshot.

From rule 3, messages received after a marker are messages received
after the receiver takes its snapshot.

So, messages sent after the sender takes its snapshot are received
after the receiver takes its snapshot.


<h5 class="w3-text-teal">Snapshots of Channels</h5>
The messages in a channel at the state of an input-closed event set are the
messages sent by events in the set and received by events outside the
the set.

So, the state of a channel in a snapshot is the sequence of
messages received along the channel after the receiver takes its local
snapshot and before the receiver receives a marker along the channel.

<p>
Note: If an agent takes its local snapshot when it receives a marker
along a channel, then the snapshot of the channel is the empty
sequence of messages.


<h5 class="w3-text-teal">Termination of the Algorithm</h5>
After any agent \(v\) initiates the algorithm, all agents that are
reachable from \(v\) will receive a marker and take their local
snapshots.

All agents take their local snapshots if every agent is reachable from
an initiator along a sequence of channels.



<p class="w3-text-teal">Collecting Local Agent and Channel
Snapshots</p>

In some algorithms, agents send snapshots of their states and 
input channels to a collector agent which forms a global snapshot by
composing the local state information that it receives.

Other algorithms carry out distributed computations on local
snapshots without sending data to a collector.

Later we give examples of both kinds of algorithms.





<!--------------------------------------------------------------->
<h4 class="w3-text-teal">Properties of Global Snapshot Algorithms</h4>
<!--------------------------------------------------------------->
A global snapshot is an intermediate state in a computation between
the points at which the snapshot algorithm starts and ends.

This result is used frequently.


<hr class="new2">
<p style="color:blue;">

<ol>

  <li>
  <p style="color:blue;">  
  There exists a computation from the state in which the
  global snapshot algorithm is initiated to the global snapshot. 
  </li>
  <li>
  <p style="color:blue;">
  There exists a computation from the global
  snapshot to the state at which the global snapshot
  algorithm terminates.
  </li>
</ol>
</p>
<hr class="new2">

<p class="w3-text-teal">Proof</p>
Let the snapshot be the state at an input-closed event set \(H\), and
let \(H'\) be an input-closed event set.

If \(H' \subset H\) then
there is a computation from the state at \(H'\) to the snapshot.

Likewise, if \(H \subset H'\) then
there is a computation from snapshot to the state at \(H'\).





<!--------------------------------------------->
  <h4 class="w3-text-teal">Applications of Global Snapshots: System Monitoring</h4>
<!--------------------------------------------->
<p>
<i>
Monitoring systems by taking repeated snapshots is the basis of
many distributed algorithms.
</i>

<p>
Next we give a few examples of system monitoring.

<p class="w3-text-teal">Rollback and Recovery</p>

There exists a computation from the initial state of the computation
to a global snapshot.

So, when a transient error occurs, a rollback and recovery algorithms
restarts the computation at the most recent snapshot instead of restarting
it from the beginning.

<p class="w3-text-teal">Detecting Stable Properties</p>
If a stable property holds at any point in any computation then it
continues to hold forever in that computation.

For example, if a computation has deadlocked then it remains
deadlocked.

We discuss stable properties in detail later.

One way to detect stable properties is to monitor the system by
taking snapshots repeatedly.

If the system deadlocks then all snapshots taken after the deadlock occurs
show that the system has deadlocked.


<!--------------------------------------------------------->
<h2 style="color:red;">Examples</h2>
<!--------------------------------------------------------->
The remainder of this webpage consists of examples.

<!--------------------------------------------------------->
<h4 style="color:red;">Example: Snapshots may change a Client's Computation
</h4>
<!--------------------------------------------------------->
This example shows that the OS algorithm may change a client's
computation though it does not change the client's dataflow.

<p>
Figure 2 is a representation of a computation with event sequence
\([0, 1, 2, \ldots, ]\) and agents \(X, Y, Z\) without a concurrent OS
algorithm, and figure 3 shows how the OS changes this computation.

Events later in the computation are placed to the
right of earlier events.


<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.002.jpeg" alt="Fig2"
    style="width:80%"> 
<figcaption>
Fig.2: Representation of a Computation without Snapshots
</figcaption> 
</figure> 


<p>
Figure 3 shows how a client's computation is changed when the OS takes
snapshots. 

The local snapshots taken by agents are shown as a yellow
circle on the agents' timelines.

The OS delays event 3 so that it occurs after events 4, 5, 6, and 7,
as shown in the figure.

The OS changes the computation, but it does not change the dataflow.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.003.jpeg" alt="Fig2"
    style="width:80%"> 
    <figcaption>Fig.3: The OS changes a Client's Computation</figcaption>
</figure> 

In figure 3, the pre-snapshot events are 0, 1, 2, 4, 6.

There is only one message received in a pre-snapshot
event, namely the message represented by the edge (0, 2).

So, every message received in a pre-snapshot event is sent in a
pre-snapshot event.

The figure shows that the set of pre-snapshot events is input closed.


<!---------------------------------------------------------->
<h4 style="color:red;">Example: Steps in a Global Snapshot
Algorithm: Initiation</h4>
<!---------------------------------------------------------->

Figure 4 illustrates the first step of the algorithm.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.005.jpeg" alt="Fig4"
    style="width:100%"> 
    <figcaption>Fig.4: Agent Sends Markers when it Takes its Local
    Snapshot</figcaption> 
</figure>

Agent Y takes its local snapshot shown as a yellow vertex on Y's
timeline.

When Y takes its snapshot it sends markers on its output channels.

The markers are shown as green edges in the figure.


<p>
When agents X and Z each receive the markers, they take their local
snapshots because they haven't taken snapshots earlier.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.006.jpeg" alt="Fig5"
    style="width:100%"> 
<figcaption>
Fig.5: Agents Take Local Snapshots when they Receive Markers
</figcaption>
</figure>

The actions by X and Z of taking their snapshots are shown as yellow
vertices on their timelines in figure 5.


<!--------------------------------------------------->
<h4 style="color:red;">Example: Agents take Snapshots upon Receiving Markers</h4> 
<!--------------------------------------------------->
<p>
When X and Z take their snapshots they send markers out on their
output channels.

The markers sent by X are shown in figure 7.

The markers sent by Z are not shown in the figure.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.007.jpeg" alt="Fig6"
    style="width:100%"> 
    <figcaption>Fig.6: When an Agent takes its Snapshot it sends Markers.
    </figcaption>
</figure>



<!--------------------------------------------------->
<h4 style="color:red;">Example: Snapshot of a Channel</h4> 
<!--------------------------------------------------->
<p>
Figure 8 shows how agent Y determines the state of the channel from X
to Y in the global snapshot.

Y starts recording the messages it receives along this channel after Y
takes its snapshot and stops the recording when it receives a marker
on this channel

The only message in this interval is the message corresponding to edge
(6, 7).


<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.008.jpeg" alt="Fig7"
    style="width:100%"> 
<figcaption>
Fig.7: Example: Recording a Channel State
</figcaption>
</figure> 

The message corresponding to edge \((0, 2)\) is from X to Y but is not
in the snapshot of 
the channel because both \(0\) and \(2\) are pre-snapshot events.

Likewise, the message corresponding to edge \((12, 13)\) is from X to
Y but is not in the snapshot of
the channel because both \(12\) and \(13\) are post-snapshot events.

The message corresponding to edge \((6, 7)\) was sent in a
pre-snapshot event and received in a post-snapshot event, and so it is
in the snapshot of the channel.


<h4 class="w3-text-teal">Next</h4>
Next  
<a href="LogicalClocks.html">logical clocks</a>.

  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>



</body>
</html>
