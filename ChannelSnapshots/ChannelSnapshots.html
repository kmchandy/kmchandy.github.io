<title>ChannelSnapshots/ChannelSnapshots.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">



<!--------------------------------------------------------->
<h1 class="w3-text-teal">A Global Snapshot Algorithm</h1>
<!--------------------------------------------------------->

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/DISTRIBUTED_SYSTEM_MODELS/Timelines.html">
  Timelines.
</p>

<a href="GlobalSnapshotAlgorithmVideo.mp4">
<h3 class="w3-text-teal">Video</h3>
  </a>

  
  <!------------------------------------------------------------------->
  <h4 class="w3-text-red">
  <i>Central Ideas</i></h4>

  <p class="w3-text-red">
  
  <p class="w3-text-red">
  A global snapshot is the system state at an input-closed set of
  events. 

  Systems can be monitored by scheduling repeated global snapshots.

  Algorithms that detect states are based on global snapshots.

  This page gives one algorithm to determine a global snapshot, and
  other algorithms are described later.
 

  <!-----------------------------------------------------------------------------> 
  <h2 class="w3-text-teal">Global Snapshot</h2> 
  <!----------------------------------------------------------------------------->
  <p>
We discuss the design of an algorithm by which agents collaborate to determine
the global state at an input-closed set of events; this state is
called a <i>global snapshot</i>.

<p>
The algorithm is executed by a distributed operating system (OS) on behalf of a
  client.
  
  Each client agent has an OS agent that supervises it.

  OS agents use the same processors and channels as clients do.
  
  OS agents can record, but not modify, states of their clients.
  
  OS agents can send and receive OS messages that are not seen
  by clients.

  <p>
  
  
  Execution of an OS agent on a processor may delay a client's
  events on the same processor.
  
  The OS may change the order in which agents execute events.

  So,
  <i>execution of an OS algorithm may change a client's
  computation.</i> 

  <p>
We will design OS algorithms that do not change the client's event
graph.

Equivalently, we design OS algorithms that leave agent computations
unchanged. 

  
  <p>
  One way to record a global snapshot is for the OS to stop a client
  computation, then take a global snapshot, and then  restart the
client computation.

  We describe a snapshot algorithm that runs concurrently with the client
  computation without stopping the client.
 
<!----------------------------------------------------------------------------->

Each agent records its own local state, at
some point in the computation, and does so exactly once.

An agent's record of its local state is called the <i>agent's local
snapshot.</i>

An agent's events before it takes its local snapshot are called
pre-snapshot events.




<h4 style="color:red;">Example: Pre-Snapshot Events</h4>
Figure 1 shows a representation of a computation with agents X, Y, Z.
There is only one channel, in each direction, between each
pair of vertices.

The figure shows a computation with event sequence \([0, 1, 2, 3,
\ldots,]\). 

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.001.jpeg" alt="Fig1"
    style="width:80%"> 
    <figcaption>Fig.1: A Computation and its Event Graph</figcaption>
</figure> 


In figure 2, each agent takes a local snapshot which is shown as a yellow
circle on the agent's timeline.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.002.jpeg" alt="Fig2"
    style="width:80%"> 
    <figcaption>Fig.2: Example of Input-Closed Pre-Snapshot Events</figcaption>
</figure> 

<!--------------------------------------------------------->
<p style="color:red;">Example: Taking Snapshots may change Client
Computations</p>

Taking local snapshots may change the order in which events of the
client computation occur.

Whe agent \(Y\) takes its local snapshot it delays event 3.

So, event 3 occurs after after events 4, 5, and 6 in the computation
of figure 2 whereas
event 3 occurs before events 4, 5, and 6 in the computation of figure 1.

The computation in figure 2 has a state in which there is both a
message in a channel from agent X to agent Y, and a message in a
channel from Z to Y (see edges (4, 5) and (1, 3)).

That state does not occur in the computation of figure 1.

<p> Though the computations are different, the event graphs, and hence
the agent computations, are the same for figures 1 and 2 are the same.


<!--------------------------------------------------------->
<p style="color:red;">Example: Pre-Snapshot Set that is Input
Closed</p> 

<p> The pre-snapshot vertices are 0, 1, 2, 4, 6 in figure 2.

The cut is the boundary between the pre-snapshot events to the left of
the boundary and post-snapshot events to the right.

<p> In figure 2 there is only one message received in a pre-snapshot
action, namely the message represented by the edge (0, 2).

Sending this message is also a pre-snapshot event.

So, every message received in a pre-snapshot event is sent in a
pre-snapshot event.

The figure shows that the set of pre-snapshot
events is input closed -- there is no edge from a post- to a
pre-snapshot event.




<!--------------------------------------------------------->
<p style="color:red;">Example: Pre-Snapshot Set that is not Input
Closed</p> 

Figure 3 shows an event graph that has a message edge directed from a
post-snapshot event, 6, to a  pre-snapshot event, 7.

This set of pre-snapshot events is not input closed.
<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.003.jpeg" alt="Fig2"
    style="width:80%"> 
    <figcaption>Fig.3: Example of Set of Pre-Snapshot Events that is
    not Input-Closed</figcaption>
</figure>
The figures suggest the following theorem.


  <h5 class="w3-text-teal">Theorem</h5>
  The set of pre-snapshot events is input-closed if and only
  if
  each message received in a pre-snapshot event is sent in a
  pre-snapshot event.


  
<p class="w3-text-teal">Proof</p>
We prove that the pre-snapshot set is input closed if the
condition of the theorem holds. The only-if part of the proof is
straightforward. 

<p>
A set of events is input-closed exactly when for every edge \((e,
e')\) of the event graph, if \(e'\) is in the set then so is \(e\).

If the edge is at an agent \(u\), then \(e\) precedes \(e'\) in agent
\(u\)'s computation, and

so, if \(e'\) is pre-snapshot then so is \(e\).

<p>
If the edge is a message edge, and the message is received in a
pre-snapshot event \(e'\), then from the condition of the theorem, the
message is sent in a pre-snapshot event \(e\).



<h3 class="w3-text-teal">A Global Snapshot Algorithm</h3>

Next we design an algorithm based on the theorem.

<ol>
  <li>
  The algorithm begins by one or more agents taking their local
  snapshots.
  </li>
  <li>
  When an agent takes its local snapshot it sends a <i>marker</i> on each
  of its outgoing channels.
  </li>
  <li>
  When an agent receives a marker, the agent takes its local snapshot
  if it has not already done so.
  </li>
</ol>

<p>
The
<a href="../DISTRIBUTED_SYSTEM_MODELS/DistributedSystemModels.html">
agent-channel graph</a> --
the directed graph of agents (vertices) and channels
(edges) -- is strongly connected.
So the algorithm sends a marker on every channel.


<h5 class="w3-text-teal">Proof of Correctness of the Algorithm</h5>
<ol>
  <li>
  From rule 2 of the algorithm, every message sent in a pre-snapshot
  event on a channel is sent before the marker sent on that channel.
  </li>
  <li>
  From rule 3, the pre-snapshot events of an agent occur before the
  agent receives a marker. 
  </li>
  <li>
  Channels are first-in-first-out. So, if \(m\) is a message received
  on a channel \(c\) before the marker was received on channel \(c\)
  then \(m\) was sent on \(c\) before the marker was sent on \(c\).
  </li>
</ol>
From the above 3 observations it follows that every message received
in a pre-snapshot action was sent in a pre-snapshot action.



<h4 style="color:red;">Example of a Global Snapshot</h4>
Figure 4 illustrates the first step of the algorithm.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.004.jpeg" alt="Fig4"
    style="width:100%"> 
    <figcaption>Fig.4: Agent Sends Markers when it Takes its Local
    Snapshot</figcaption> 
</figure>

Agent Y takes its local snapshot shown as a yellow vertex on Y's
timeline.

When Y takes its snapshot it sends markers on its output channels.

The markers are shown as green edges in the figure 4.


<p>
When agents X and Z each receive the markers, they take their local
snapshots because they haven't taken snapshots earlier.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.005.jpeg" alt="Fig5"
    style="width:100%"> 
<figcaption>
Fig.5: Agents Take Local Snapshots when they Receive Markers
</figcaption>
</figure>

The actions by X and Z of taking their snapshots are shown as yellow
vertices on their timelines.

<p>
When X and Z take their snapshots they send markers out on their
output channels.

The markers sent by X are shown in figure 6.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.006.jpeg" alt="Fig6"
    style="width:100%"> 
    <figcaption>Fig.6: When an Agent takes its Snapshot it sends Markers.
    </figcaption>
</figure>

The markers sent by Z are not shown in the figure.

<p>
A total of 6 markers are sent in the algorithm, one marker for each
channel. 


<!--------------------------------------------------->
<h3 class="w3-text-teal">Snapshots of Channels</h3>

Next we look at an algorithm to record snapshots (states) of channels
at an input-closed event set.

The messages in a channel at the state of an input-closed event set are the
messages sent by events in the set and received by events outside the
the set.

So, the state of a channel in the global snapshot is the sequence of
messages sent on the channel before the sender takes its snapshot and
that are received after the receiver takes its snapshot.


<p>
From rule 2 of the algorithm, the messages sent by an agent along a
channel before the agent takes its snapshot are the messages that the
agent sends along the channel before sending a marker on the channel.

Because channels are first-in-first-out, the messages sent along a
channel before the sender takes its snapshot are the messages received
along the channel before the marker on the channel.

Therefore:

<hr class="new2">
<h5 style="color:blue;">
The state of a channel in a snapshot is:
<br>
the sequence of messages
received along the channel after the receiver takes its local snapshot
and before the receiver receives a marker along the channel.
</h5>
<hr class="new2">

<p>
Note: If an agent takes its local snapshot when it receives a marker
along a channel, then the snapshot of the channel is the empty
sequence of messages.

<p>
Figure 6 shows how agent Y determines the state of the channel from X
to Y in the global snapshot.

Y starts recording the messages it receives along this channel after Y
takes its snapshot and stops the recording when it receives a marker
on this channel

The only message in this interval is the message corresponding to edge
(6, 7).


<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.006.jpeg" alt="Fig6"
    style="width:100%"> 
<figcaption>
Fig.7: When an Agent takes its Snapshot it Sends
Markers
</figcaption>
</figure>

Look at figure 7 to see the snapshot of the channel from X to Y in
more detail. 

The message corresponding to edge \((0, 2)\) is from X to Y but is not
in the snapshot of 
the channel because both \(0\) and \(2\) are pre-snapshot events.

Likewise, the message corresponding to edge \((12, 13)\) is from X to
Y but is not in the snapshot of
the channel because both \(12\) and \(13\) are post-snapshot events.

The message corresponding to edge \((6, 7)\) was sent in a
pre-snapshot event and received in a post-snapshot event, and so it is
in the snapshot of the channel.


<h4 class="w3-text-teal">Collecting Local Agent and Channel
Snapshots</h4>
Each agent takes its own local snapshot and the snapshots of its
incoming channels.
In some applications, agents send snapshots of their states and the
states of their
input channels to a collector agent.
The collector composes the information to form the global snapshot

<p>
Other applications carry out distributed computations on local
snapshots.
These applications have no single collector agent.
We will look at both kinds of applications in later pages of this website.

<!--------------------------------------------------------------->
<h3 class="w3-text-teal">Starting, Snapshot, and Ending States</h3>

<h5 class="w3-text-teal">The Observer Effect</h5>
As we showed earlier, making measurements (recording states) of a
client computation may change the computation.

This is an example of
<a href="https://en.wikipedia.org/wiki/Observer_effect_(physics)">
the Observer Effect.
</a>

<p>
The global snapshot is a state of an input-closed event set of the
<i>changed computation</i> -- the client computation that may have
been changed by the execution of the snapshot algorithm.

Does the snapshot provide information about the <i>original
computation</i> -- the computation without an execution of the
snapshot algorithm?

<p>
The key idea is that the event graphs are the same in the original and
changed computations.

So, the states of input-closed event sets are the same in the original
and changed computations.

<p>
Let the global states in which the snapshot algorithm starts and ends be
\(s_{init}\) and \(s_{fini}\), respectively, and let \(s_{snap}\) be
the global state recorded by the algorithm.
Because these states are states of input-closed event sets, it
follows from the
<a href="../DISTRIBUTED_SYSTEM_MODELS/Timelines.html">
theorem on computations from sets to supersets
</a>
that in both the original and changed computations:
<hr class="new2">
<h5 style="color:blue;">
There exists a computation that starts in 
  \(s_{init}\), visits \(s_{snap}\), and then visits
  \(s_{fini}\).
</h5>
<hr class="new2">



This result is the key idea underlying many algorithms.

For example, a rollback and recovery system records global snapshots
periodically.

If a hardware (i.e., non algorithmic) fault is detected, then the
computation is restarted from the most recent checkpoint (snapshot)
instead of going all the way back to the initial state.

<p>
Global snapshots are used to detect persistent properties
such as the computation is in a terminated or deadlocked state. If the
computation has terminated when the snapshot algorithm starts then the
snapshot shows that the computation has terminated. And, if the
snapshot shows that the computation has terminated then the
computation has terminated at the point that the snapshot algorithm
<h4 class="w3-text-red">

<!--------------------------------------------------------------->
<i>Central Ideas: Review</i></h4>
<!--------------------------------------------------------------->

<p class="w3-text-red">
<i>The state at an input-closed event set</i> is a concept that is
used in many algorithms.

A global snapshot is a state at an input-closed event set.

The global snapshot algorithm uses markers to separate events in an
input-closed set from events outside it.


<p class="w3-text-red">
<i>Concepts</i>:
Timelines -> causality graphs -> consistent cuts -> global snapshot
algorithms -> detection algorithms.


<h4 class="w3-text-teal">Next</h4>
Next either look at two examples
 -- <a href="TerminationDetectionNew.html">termination</a> and
<a href="DatabaseDeadlockDetection.html">database deadlock</a>
detection --
of snapshots or
move to the next topic, 
<a href="LogicalClocksNew.html">logical clocks</a>.

  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>



</body>
</html>
