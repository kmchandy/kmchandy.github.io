<title>ChannelSnapshots/ChannelSnapshots.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">



<!--------------------------------------------------------->
<h1 class="w3-text-teal">A Global Snapshot Algorithm</h1>
<!--------------------------------------------------------->

<p class="w3-text-green">
  This page uses material from
  <a
  href="../DISTRIBUTED_SYSTEM_MODELS/Timelines.html">
  Timelines.
  </a>
</p>


  
  <!------------------------------------------------------------------->
  
  <p class="w3-text-red">
  <i>
  A global snapshot is the system state at an input-closed set of
  events. 

  Systems can be monitored by scheduling repeated global snapshots.

  Algorithms that detect properties of computations, such as "the
  computation is deadlocked," are based on global snapshots.

  Rollback and recovery algorithms for distributed systems are based
  on global snapshots.
  </i>
  </p>
 
  <!-----------------------------------------------------------------------------> 
  <h3 class="w3-text-teal">Global Snapshot</h3> 
  <!----------------------------------------------------------------------------->
  <p>
We describe an algorithm by which agents collaborate to determine
the global state at an input-closed set of events; this state is
  called a <i>global snapshot</i>.

  <p>
  Global snapshots are used in many distributed algorithms.
  
  When a transient error is detected in a computation the operating
  system rolls the computation back to the most recent global snapshot
  of the computation instead of rolling the computation back to its
  initial state.

  An operating system detects whether a client has
  terminated execution by inspecting a global snapshot of the client's
  computation.


  <!-----------------------------------------------------------------------------> 
  <h5 class="w3-text-teal">The Operating System Records Global
  Snapshots of its Clients</h5> 
<p>
The global snapshot algorithm is executed by a distributed operating
  system (OS) on behalf of a client.
  
  Each client agent has an OS agent that supervises it.

  OS agents use the same processors and channels as clients do.
  
  OS agents can record, but not modify, states of their clients.
  
  OS agents can send and receive OS messages that are not seen
by clients.

<p>
The figure is a representation of two OS agents that manage their
client agents.

Messages sent by a client are recorded by the OS and passed through
to destination clients.

The OS sends messages on the same channels as clients, but the OS
traps these messages so that the client does not see them.


<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.001.jpeg" alt="Fig1"
    style="width:80%"> 
    <figcaption>Fig.1: OS and Clients use the same Channels</figcaption>
</figure> 

  <p>
  Execution of an OS agent on a processor may delay a client's
  events on the same processor.
  
  The OS may change the order in which agents execute events.

  So,
  execution of an OS algorithm may change a client's
  computation.

We design OS algorithms so that the client's dataflow is not changed
by the OS.
  
  <p>
  One way to record a global snapshot is for the OS to stop a client
  computation, then take a global snapshot, and then  restart the
client computation.

  We describe a snapshot algorithm that runs concurrently with the client
  computation without stopping the client.
 
<!----------------------------------------------------------------------------->
<h5 class="w3-text-teal">Local Snapshots of Agents</h5>
<!----------------------------------------------------------------------------->

Each agent records its own local state, at
some point in the computation, and does so exactly once.

An agent's record of its local state is called the <i>agent's local
snapshot.</i>

An agent's events before it takes its local snapshot are called
pre-snapshot events.

<p>
Making measurements (e.g., recording states) of a
client computation may change the computation.

Next, we look at an example of this
<a href="https://en.wikipedia.org/wiki/Observer_effect_(physics)">
Observer Effect
</a>.

The snapshot algorithm may change the computation of a client but not
its dataflow.

<!--------------------------------------------------------->
<h4 style="color:red;">Example: Taking Snapshots may change Client
Computations</h4>
<!--------------------------------------------------------->

Figure 1 shows a representation of a computation with agents X, Y, Z.
There is only one channel, in each direction, between each
pair of vertices.

The figure shows a computation with event sequence \([0, 1, 2, 3,
\ldots,]\). 

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.002.jpeg" alt="Fig2"
    style="width:80%"> 
    <figcaption>Fig.2: A Computation and its Event Graph</figcaption>
</figure> 


In figure 2, each agent takes a local snapshot which is shown as a yellow
circle on the agent's timeline.

Events at an agent before the agent takes its local snapshot are
called pre-snapshot events, and events after the local snapshot are
called post-snapshot events.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.003.jpeg" alt="Fig3"
    style="width:80%"> 
    <figcaption>Fig.3: Example of Input-Closed Pre-Snapshot Events</figcaption>
</figure> 

In figure 2, the pre-snapshot events are 0, 1, 2, 4, 6.


Taking local snapshots may change the order in which events of the
client computation occur.

Whe agent \(Y\) takes its local snapshot it delays event 3.

So, event 3 occurs after after events 4, 5, and 6 in the computation
of figure 2 whereas event 3 occurs before events 4, 5, and 6 in the
computation of figure 1.

<p>
The computation in figure 2 has a state in which there is both a
message in a channel from agent X to agent Y, and a message in a
channel from Z to Y (see edges (4, 5) and (1, 3)).

That state does not occur in the computation of figure 1.

<p> Though the computations are different the event graphs are the
same in figures 1 and 2. 


<!--------------------------------------------------------->
<h4 style="color:red;">Example: Pre-Snapshot Set that is Input
Closed</h4> 

<p> The pre-snapshot vertices are 0, 1, 2, 4, 6 in figure 2.

The cut is the boundary between the pre-snapshot events to the left of
the boundary and post-snapshot events to the right.

<p>
The cut is specified by the last event before the local snapshot at
each agent.

In figure 2 the cut is specified by \(\{(X, 6), (Y, 2), (Z, 1)\}\).

<p> In figure 2 there is only one message received in a pre-snapshot
event, namely the message represented by the edge (0, 2).

This message is sent in a pre-snapshot event.

So, every message received in a pre-snapshot event is sent in a
pre-snapshot event.

<p>
The figure shows that the set of pre-snapshot events is input closed
-- there is no edge from a post- to a pre-snapshot event.




<!--------------------------------------------------------->
<h4 style="color:red;">Example: Pre-Snapshot Set that is not Input
Closed</h4> 

Figure 3 shows an event graph that has a message edge directed from a
post-snapshot event, 6, to a  pre-snapshot event, 7.

This set of pre-snapshot events is not input closed.
<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.004.jpeg" alt="Fig4"
    style="width:80%"> 
    <figcaption>Fig.4: Example of Set of Pre-Snapshot Events that is
    not Input-Closed</figcaption>
</figure>
The figures suggest the following theorem.


  <h3 class="w3-text-teal">The Global Snapshot Theorem</h3>
<p class="w3-text-teal">
The set of pre-snapshot events is input-closed if and only
  if each message received in a pre-snapshot event is sent in a
pre-snapshot event.
</p>

  
<p class="w3-text-teal">Proof</p>
We prove that the pre-snapshot set is input closed if the
condition of the theorem holds. The only-if part of the proof is
straightforward.

From the definition of local snapshots, an agent edge to a
pre-snapshot event at an agent \(u\) are from a
pre-snapshot event at \(u\).

From the condition of the theorem, a message edge to a pre-snapshot
event is from a pre-snapshot event.

<h3 class="w3-text-teal">Alternate Versions of the Global Snapshot
Theorem</h3> 
The theorem is used so often that we highlight it, and give
an alternative version of it.
<hr class="new2">

<p style="color:blue;">
The set of pre-snapshot events is input-closed if and only
if any one of the following conditions holds.
<ol>
  <li>
  <p style="color:blue;">
Each message received in a pre-snapshot event is sent in a
pre-snapshot event.
  </li>
  <li>
<p style="color:blue;">
Each message sent in a post-snapshot event is received in a
  post-snapshot event.
  </li>
  <li>
  <p style="color:blue;">
  For all channels \(C\),  \(\; C_{s} \geq C_{r}\), where \(C_{s}, C_{r}\)
  are the numbers of messages 
  sent and received (respectively) on the channel in pre-snapshot
  messages.
  </li>
  <li>
  <p style="color:blue;">
  In graphical terms, all edges
  that cross the boundary separating pre- and post-snapshot events are
  directed from pre- to post-snapshot events.
  </li>
</ol>
</p>
<hr class="new2">


<h3 class="w3-text-teal">A Global Snapshot Algorithm</h3>
A global snapshot is the state at an input-closed
set of pre-snapshot events.

The global snapshot theorem suggests the following algorithm for
taking a global snapshot.

<ol>
  <li>
  The algorithm begins by one or more agents taking their local
  snapshots.
  </li>
  <li>
  When an agent takes its local snapshot it sends a <i>marker</i> on each
  of its outgoing channels. All messages sent on a channel after
  the marker on the channel are sent in post-snapshot events.
  </li>
  <li>
  When an agent receives a marker, the agent takes its local snapshot
  if it has not already done so. All messages received on a
  channel after the marker on the channel are received in
  post-snapshot events.
  </li>
</ol>
Therefore, all messages sent in post-snapshot events are received in
post-snapshot events, and so the set of pre-snapshot events is input
  closed. 

<h5 class="w3-text-teal">Snapshots of Channels</h5>
The messages in a channel at the state of an input-closed event set are the
messages sent by events in the set and received by events outside the
the set.

So, the state of a channel in a snapshot is the sequence of
messages received along the channel after the receiver takes its local
snapshot and before the receiver receives a marker along the channel.

<p>
Note: If an agent takes its local snapshot when it receives a marker
along a channel, then the snapshot of the channel is the empty
sequence of messages.


<p>
After any agent \(v\) initiates the algorithm, all agents that are
reachable from \(v\) will receive a marker and take their local
snapshots.
All agents take their local snapshots if there are path (sequence of
channels) from the initiator to all agents.



<!---------------------------------------------------------->
<h4 style="color:red;">Example: Steps in a Global Snapshot
Algorithm: Initiation</h4>
<!---------------------------------------------------------->

Figure 4 illustrates the first step of the algorithm.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.005.jpeg" alt="Fig5"
    style="width:100%"> 
    <figcaption>Fig.5: Agent Sends Markers when it Takes its Local
    Snapshot</figcaption> 
</figure>

Agent Y takes its local snapshot shown as a yellow vertex on Y's
timeline.

When Y takes its snapshot it sends markers on its output channels.

The markers are shown as green edges in the figure 4.


<p>
When agents X and Z each receive the markers, they take their local
snapshots because they haven't taken snapshots earlier.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.006.jpeg" alt="Fig6"
    style="width:100%"> 
<figcaption>
Fig.6: Agents Take Local Snapshots when they Receive Markers
</figcaption>
</figure>

The actions by X and Z of taking their snapshots are shown as yellow
vertices on their timelines.


<!--------------------------------------------------->
<h4 style="color:red;">Example: Agents take Snapshots upon Receiving Markers</h4> 
<!--------------------------------------------------->
<p>
When X and Z take their snapshots they send markers out on their
output channels.

The markers sent by X are shown in figure 6.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.007.jpeg" alt="Fig7"
    style="width:100%"> 
    <figcaption>Fig.7: When an Agent takes its Snapshot it sends Markers.
    </figcaption>
</figure>

The markers sent by Z are not shown in the figure.

<p>
A total of 6 markers are sent in the algorithm, one marker for each
channel. 



<!--------------------------------------------------->
<h4 style="color:red;">Example: Snapshot of a Channel</h4> 
<!--------------------------------------------------->
<p>
Figure 6 shows how agent Y determines the state of the channel from X
to Y in the global snapshot.

Y starts recording the messages it receives along this channel after Y
takes its snapshot and stops the recording when it receives a marker
on this channel

The only message in this interval is the message corresponding to edge
(6, 7).


<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.008.jpeg" alt="Fig8"
    style="width:100%"> 
<figcaption>
Fig.8: When an Agent takes its Snapshot it Sends
Markers
</figcaption>
</figure>

Look at figure 7 to see the snapshot of the channel from X to Y in
more detail. 

The message corresponding to edge \((0, 2)\) is from X to Y but is not
in the snapshot of 
the channel because both \(0\) and \(2\) are pre-snapshot events.

Likewise, the message corresponding to edge \((12, 13)\) is from X to
Y but is not in the snapshot of
the channel because both \(12\) and \(13\) are post-snapshot events.

The message corresponding to edge \((6, 7)\) was sent in a
pre-snapshot event and received in a post-snapshot event, and so it is
in the snapshot of the channel.


<h4 class="w3-text-teal">Collecting Local Agent and Channel
Snapshots</h4>
Each agent takes its own local snapshot and the snapshots of its
incoming channels.
In some applications, agents send snapshots of their states and the
states of their
input channels to a collector agent.
The collector composes the information to form the global snapshot

<p>
Other applications carry out distributed computations on local
snapshots.
These applications have no single collector agent.
We will look at both kinds of applications in later pages of this website.



<!--------------------------------------------------------------->
<h4 class="w3-text-teal">Key Properties of Global Snapshot Algorithms</h4>
<!--------------------------------------------------------------->


From
<a href="../DISTRIBUTED_SYSTEM_MODELS/Timelines.html">
computations between sets of operations
</a>
for all input closed sets \(H, H'\) where \(H \subseteq
H'\), there is a computation from \(H\) to \(H'\).


<p>
Let the set of events that have been completed when the snapshot
algorithm is initiated be \(H\) and let the snapshot be the state at
\(H'\).
Then \(H \subseteq H'\).

<p>
Let \(s_{init}\) be the state in which the snapshot algorithm is
initiated, i.e., \(s_{init}\) is the state at \(H\).

Let \(s_{snap}\) be the global state recorded by the algorithm, i.e.,
\(s_{snap}\) is the state at \(H'\).

<p>
There exists a computation from \(H\) to \(H'\).
and so there exists a computation from \(s_{init}\) to \(s_{snap}\).

By the same argument, there exists a computation from \(s_{snap}\) to
\(s_{fini}\), the state when the global snapshot algorithm terminates.

<p>
These result are used so frequently that we highlight them here.

<hr class="new2">
<h5 style="color:blue;">

<ol>
  <li>
  There exists a computation from the state in which the
  global snapshot algorithm is initiated to the global snapshot. 
  </li>
  <li>
  There exists a computation from the global
  snapshot to the state at which the global snapshot
  algorithm terminates.
  </li>
</ol>
</h5>
<hr class="new2">


<!--------------------------------------------->
  <h3 class="w3-text-teal">System Monitoring with Repeated Snapshots</h3>
<!--------------------------------------------->
<p>
<i>
Monitoring systems by taking repeated snapshots is the basis of
many distributed algorithms.
</i>

<p>
We give some examples of algorithms based on system monitoring.

<p>
Rollback and Recovery: When a transient error occurs, a rollback and recover algorithms
restarts the computation at the most recent snapshot.

<p>
Detecting Stable Properties:
A stable property of a system is a property that continues to hold
once it holds.

For example, after a computation has terminated it remains
terminated.

A general way to detect whether any stable property holds in a computation
is by monitoring the system.

If the stable property holds then a snapshot will show that it holds,
and if a snapshot shows that a stable property holds then it continues
to hold.




<h4 class="w3-text-teal">Next</h4>
Next  
<a href="LogicalClocks.html">logical clocks</a>.

  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>



</body>
</html>
