<title>ChannelSnapshots/ChannelSnapshots.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">



<!--------------------------------------------------------->
<h1 class="w3-text-teal">A Global Snapshot Algorithm</h1>
<!--------------------------------------------------------->

<p class="w3-text-green">
  This page uses material from
  <a
  href="https://kmchandy.github.io/DISTRIBUTED_SYSTEM_MODELS/Timelines.html">
  Timelines.
</p>

<a href="GlobalSnapshotAlgorithmVideo.mp4">
<h3 class="w3-text-teal">Video</h3>
  </a>

  
  <!------------------------------------------------------------------->
  <h4 class="w3-text-red">
  <i>Central Ideas</i></h4>

  <p class="w3-text-red">
  A global snapshot algorithm for determining a state in a computation.

  
  <p class="w3-text-red">
  A global snapshot is the state at a consistent cut.

  Systems can be monitored by scheduling repeated global snapshots.

  All state detection algorithms are based on global snapshots.

  This page gives an algorithm to determine a global snapshot; we will
  look at other algorithms later.
 

  <!-----------------------------------------------------------------------------> 
  <h2 class="w3-text-teal">Global Snapshot: State at a
  Consistent Cut</h2> 

  <p>
We discuss the design of an algorithm by which agents collaborate to determine
the state at a consistent cut; this state is called a <i>global
  snapshot</i>.

<p>
The algorithm is executed by an operating system (OS) on behalf of a
client.
  The algorithm consists of OS actions that 
  do not change the client's causality graph.
  OS actions can record, but not modify, states.
Likewise, OS actions can send and receive OS messages without changing
  client states and messages.

  <p>
  The OS may use the same processors and channels as clients do.
  So, the OS may change when client actions are executed.
  For example, execution of the OS on a processor may delay execution of a client's
  action on the same processor.
  The OS may change a client's computation, but we require that it
  must not change a client's causality graph.

  <p>
  One way to record a global snapshot is for the OS to stop a client
  computation, then take a global snapshot, and then  restart the
  client computation.
  We describe a snapshot algorithm that runs concurrently with the client
  computation without stopping the client.
 
<p>
The algorithm is as follows. Each agent records its own local state, at
some point in the computation.
An agent's record of its local state is called the <i>agent's local snapshot.</i> 
An agent's actions before it takes its local snapshot are called
pre-snapshot actions.


  <h5 class="w3-text-teal">Lemma</h5>
  The cut consisting of pre-snapshot actions is consistent if and only
  if
  <center>
  each message received in a pre-snapshot action is sent in a
  pre-snapshot action.
  </center>

  
  <p class="w3-text-teal">Proof</p>

If \(v\) and \(v'\) are actions by the same agent and if \(v'\)
is a pre-snapshot action then so is \(v\) because  \(v\)
precedes \(v'\).
If \(v\) and \(v'\) are actions at different agents then \(v'\)
  receives the message sent in \(v\); from the condition of the 
theorem, if \(v'\) is a pre-snapshot action then so is \(v\).

<p>
  <a href="../DISTRIBUTED_SYSTEM_MODELS/Timelines.html">A cut is consistent
  </a>
  if for all edges \((v, v')\) of the causality
graph if \(v'\) is in the cut then so is \(v\).
Therefore, the cut consisting of pre-snapshot actions is consistent.

<h4 style="color:red;">Example: Pre-Snapshot Actions</h4>
Figure 1 shows a representation of a computation with agents X, Y, Z.
Assume that there is only one channel, in each direction, between each
pair of vertices.
<p>
The representation of the computation is the causality graph with a
vertex sequence in which each vertex appears after vertices on which it depends.
Labels of edges aren't shown so as not to overcrowd the figure.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.001.jpeg" alt="Fig1" style="width:50%">
    <figcaption>Fig.1: Representation of a Computation</figcaption>
</figure> 


In figure 2, each agent takes a local snapshot shown as a yellow
circle.
Taking local snapshots may change the order in which actions of the
client computation are executed.
Action 3 occurs after after actions 4, 5, and 6 in figure 2 whereas 3
is before 4, 5, and 6 in figure 1.

<p>
The computation shown in figure 2 is different from that in figure 1.
The computation in figure 2 has a state in which there is
a message in a channel from agent X to agent Y, and a message in a
channel from Z to Y (see edges (4, 5) and (1, 3)).
By contrast, in figure 1,
message (1, 3) is delivered before message (4, 5) is sent.
The action of making observations (recording states) of the client
computation changes the computation.

<p>
Though the computations are different, the causality graphs for
figures 1 and 2 are the same. 

<p>
The pre-snapshot vertices are 0, 1, 2, 4, 6.
The cut is the set of vertices to the left of the curved brown line.
Snapshots don't change the client's causality graph.
So the label of the edge from 4 to 6 (the state of agent X between the
actions) isn't modified by the action of
taking the local snapshot; the label of the edge from 4 to the
snapshot action is the same as that from the snapshot action to 6.

<p>
There is only one message received in a pre-snapshot action, namely the
message represented by the edge (0, 2).
The action of sending this message is a pre-snapshot action.
So, the local snapshots satisfy the condition of the lemma.
The lemma tells us that the cut consisting of pre-snapshot vertices is
consistent.


<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.002.jpeg" alt="Fig2" style="width:50%">
    <figcaption>Fig.2: Pre-Snapshot Actions</figcaption>
</figure> 



<h3 class="w3-text-teal">A Global Snapshot Algorithm</h3>

Next we design an algorithm based on the lemma.
We assume that the
<a href="../DISTRIBUTED_SYSTEM_MODELS/DistributedSystemModels.html">
agent-channel graph</a>
the directed graph of agents (vertices) and channels
(edges) is strongly connected, and so the algorithm sends a marker on
every channel, and every agent takes its local snapshot.

<ol>
  <li>
  The algorithm begins by one or more agents taking their local
  snapshots.
  </li>
  <li>
  When an agent takes its local snapshot it sends a <i>marker</i> on each
  of its outgoing channels.
  </li>
  <li>
  When an agent receives a marker, the agent takes its local snapshot
  if it has not already done so.
  </li>
</ol>

<p>
We assume that the
<a href="../DISTRIBUTED_SYSTEM_MODELS/DistributedSystemModels.html">
agent-channel graph</a> --
the directed graph of agents (vertices) and channels
(edges) -- is strongly connected.
So the algorithm sends exactly one marker on
every channel, and every agent takes its local snapshot.


<h5 class="w3-text-teal">Proof of Correctness of the Algorithm</h5>
<ol>
  <li>
From rule 2 of the algorithm, the pre-snapshot actions of an agent are
the actions of the agent before it sends markers on all its output
  channels.
  </li>
  <li>
From rule 3, the pre-snapshot actions of an agent are
the actions of the agent before it receives a marker on any of its input
channels.
  </li>
  <li>
Channels are first-in-first-out. So, if \(m\) is a message received on
a channel \(c\)
before the marker was received on \(c\) then \(m\) was sent on \(c\)
before the marker was sent on \(c\).
  </li>
</ol>
From the above 3 observations it follows that every message received
in a pre-snapshot action was sent in a pre-snapshot action.



<h4 style="color:red;">Example of a Global Snapshot</h4>
Figure 3 illustrates the first step of the algorithm.
Agent Y takes its local snapshot shown as a yellow vertex on Y's
timeline. 
When Y takes its snapshot it sends markers
on its output channels.
The markers are shown as green edges in the figure 3.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.003.jpeg" alt="Fig3" style="width:50%">
    <figcaption>Fig.3: Marker Messages Sent when Agent Takes its Local
    Snapshot</figcaption>
</figure>

When agents X and Z each receive the markers, they take their local snapshots
because they haven't taken snapshots earlier.
The actions by X and Z of taking their snapshots are shown as yellow
vertices on their timelines.
When X and Z take their snapshots they send markers out on their
output channels; these markers are not shown in figure 4.
A total of 6 markers are sent in the algorithm, one marker for each channel.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.004.jpeg" alt="Fig4" style="width:50%">
    <figcaption>Fig.4: Agent Takes its Local Snapshot when it Receives
    a Marker
    Snapshot</figcaption>
</figure>




<h3 class="w3-text-teal">Snapshots of Channels</h3>
Next we look at an algorithm to record snapshots (states) of channels
at a cut.
The messages in a channel at a cut are the messages sent
by actions in the cut and received by actions outside the
the cut.
So, the state of a channel in the global snapshot is the sequence of
messages sent on the channel  before the sender takes its snapshot and
that are received after the receiver takes its snapshot.

<p>
From rule 2 of the algorithm, the messages sent by an agent along a
channel before the agent takes its snapshot are the messages that the
agent sends along the channel before sending a marker on the channel.
Because channels are first-in-first-out, the messages sent along a
channel before the
sender takes its snapshot are the messages received along the channel
before the marker on the channel.
Therefore:

<hr class="new2">
<h5 style="color:blue;">
The state of a channel in a snapshot is:
<br>
the sequence of messages
received along the channel after the receiver takes its local snapshot
and before the receiver receives a marker along the channel.
</h5>
<hr class="new2">
<p>
Note: If an agent takes its local snapshot when it receives a marker
along a channel, then the snapshot of the channel is the empty
sequence of messages.

<h4 style="color:red;">Example: Channel Snapshot</h4>
Figure 5 shows the continuation of the snapshot algorithm after the
situation in figure 4.
When agent X takes its snapshot it sends markers on its output edges.
These markers are shown in green.

<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.005.jpeg" alt="Fig5" style="width:50%">
    <figcaption>Fig.5: Agent Takes its Local Snapshot when it Receives
    a Marker
    Snapshot</figcaption>
</figure>

Figure 6 shows how agent Y determines the state of the channel from X
to Y in the global snapshot.
Y starts recording the messages it receives along this channel after Y
takes its snapshot and stops the recording when it receives a marker
on this channel.
The only message in this interval is the message corresponding to edge
(6, 7).


<figure>
    <img src="ChannelSnapshots/ChannelSnapshots.006.jpeg" alt="Fig6" style="width:50%">
    <figcaption>Fig.6: State of Channel: Messages received between
    snapshot and marker
    Snapshot</figcaption>
</figure>


<h4 class="w3-text-teal">Collecting Local Agent and Channel
Snapshots</h4>
Each agent takes its own local snapshot and the snapshots of its
incoming channels.
In some applications, agents send snapshots of their states and the
states of their
input channels to a collector agent.
The collector composes the information to form the global snapshot

<p>
Other applications carry out distributed computations on local
snapshots.
These applications have no single collector agent.
We will look at both kinds of applications in later pages of this website.

<!--------------------------------------------------------------->
<h3 class="w3-text-teal">Starting, Snapshot, and Ending States</h3>
As we showed earlier, making measurements (recording states) of a
client computation may change the computation.
The global snapshot is a state of the cut of the changed computation.
Does the snapshot provide information about the original
computation -- the computation that wasn't changed by the actions of
the snapshot algorithm?

<p>
Let the states in which the snapshot algorithm starts and ends be
\(s_{init}\) and \(s_{fini}\), respectively, and let \(s_{snap}\) be
the global state recorded by the algorithm.
Because \(s_{snap}\) is the state of a consistent cut, it follows that

<hr class="new2">
<h5 style="color:blue;">
There exists a computation that starts in 
  \(s_{init}\), visits \(s_{snap}\), and then visits
  \(s_{fini}\).
</h5>
<hr class="new2">
This result is used in algorithms that detect persistent properties
such as the computation is in a terminated or deadlocked state. If the
computation has terminated when the snapshot algorithm starts then the
snapshot shows that the computation has terminated. And, if the
snapshot shows that the computation has terminated then the
computation has terminated at the point that the snapshot algorithm
finishes.  
<!--------------------------------------------------------------->
<!--------------------------------------------------------------->

<h2 class="w3-text-teal">Monitoring Systems by Scheduling Snapshots</h2>
Sequences of checkpoints taken repeatedly at scheduled times
<a href="https://en.wikipedia.org/wiki/Cron">(cron jobs)</a>
help in monitoring systems.
A checkpoint of a distributed system is a global snapshot, and
scheduling repeated snapshots helps in many applications including
monitoring. 
The global snapshot taken
at time \(T\) is assigned timestamp \(T\) to
distinguish it from snapshots taken at other times.
The algorithm to get the snapshot at time
\(T\) is identical to the marker algorithm except that markers and
snapshots are assigned timestamp \(T\).


<!--------------------------------------------------------------->
<!--------------------------------------------------------------->
<h3 class="w3-text-teal">Algorithm to get the Snapshot at time \(T\)</h3>
All snapshots and markers in the algorithm below have timestamp
\(T\). 
<ol>
  <li>
  When an agent's clock reaches \(T\) the agent takes its local snapshot and sends
  markers on all its output channels. 
  </li>
  <li>
  When an agent receives a marker with timestamp \(T\), if the agent's
  local clock is earlier than \(T\) then the agent moves its local
  clock forward to \(T\), and (rule 1) the agent takes its local
  snapshot and sends markers on all its output channels.
  </li>
</ol>
Channel snapshots are computed as in the marker algorithm.

<h5 class="w3-text-teal">System Monitoring</h5>
Algorithms that schedule snapshots at \(T\) for increasing values of
\(T\) are <i>system monitoring algorithms.</i>
Agents clocks with a standard time server, such as
NTP, to ensure that the times at which snapshots are taken are close
to the true schedules times.


<h1 class="w3-text-teal">Applications of Snapshots</h1>
Next we give a few examples of snapshot applications.

<h4 class="w3-text-teal">Rollback and Recovery</h4>
If an error is detected during the execution of a computation then a
rollback and recover algorithm rolls the computation back to the most
recent checkpoint (global snapshot) and restarts the computation from
that point. 


<h3 class="w3-text-teal">The Detection Problem</h3>
The detection problem is to design an algorithm that detects
whether a computation is in a <i>stable</i> set of
states.

<p class="w3-text-teal">Stable set of States</p>
A <i>stable</i> set of states is a set \(P\) such that every transition from a
state in \(P\) is to a state in \(P\). There is no transition from
inside \(P\) to outside \(P\), and so after a computation visits a
state in \(P\) the computation remains forever in \(P\). The set of
states in which agents are deadlocked is  an example of a stable set:
there is no transition from a deadlocked state to a non-deadlocked
state.


<h3 class="w3-text-teal">Global Snapshots and State Detection</h3>
Let's look again at the specification of a global snapshot.
Let \(S_{init}\) and \(S_{fini}\) be the states of the computation at
which the snapshot algorithm starts and ends, respectively and let
\(S_{snap}\) be snapshot obtained by the algorithm.  There exists a computation that
visits \(S_{init}\), later visits \(S_{snap}\) and then later visits
\(S_{fini}\). So, for any stable set \(P\), if \(S_{init}\) is in
\(P\) then so is \(S_{snap}\).  Likewise, if \(S_{snap}\) is in \(P\)
then so is \(S_{fini}\).

<h5 class="w3-text-teal">Property of Global Snapshots</h5>
<hr class="new2">
<h6 style="color:blue;">
For any stable set \(P\) of states:
<ol>
  <li>
  If the snapshot algorithm starts when the system is in \(P\)
  then the snapshot is in \(P\).
  </li>
  <li>
  If the snapshot is in \(P\) then system is in \(P\) when the
  snapshot algorithm ends.
  </li>
</ol>
</h6>
<hr class="new2">

<p>
What do we know about the snapshot if the snapshot algorithm is
initiated when the system is outside a stable set \(P\) and enters
\(P\) while the snapshot algorithm is still running? In this case, the
specification doesn't tell us whether the snapshot will be in \(P\) or
not.

<p>
If the snapshot is in \(P\) then the system is in \(P\) when the
snapshot algorithm <i>ends</i>.  If the snapshot is not in \(P\) then
the system is not in \(P\) when the snapshot algorithm <i>begins</i>,
but we don't know whether the system is in \(P\) when the snapshot
algorithm <i>ends</i>.

<p>
If a snapshot is not in \(P\) then more
snapshots must be taken to detect whether the system may have entered
\(P\) after the last snapshot was initiated.
A general method to detect whether a system is in a stable set of
states is to monitor the system by scheduling repeated snapshots.


<h3 class="w3-text-teal">System Monitoring Solves All Detection
Problems</h3>
System monitors take
global snapshots repeatedly -- for example at scheduled times.
If the system state at any point in a computation is in a stable set \(P\)
then a later snapshot will be in \(P\).
And if any snapshot is in 
\(P\) then the system state at that point is in \(P\).

<h5 class="w3-text-teal">Examples of Detection Problems</h5>
System monitoring can be used to solve all detection problems
including those that detect whether:
<ol>
  <li> computation has terminated, </li>
  <li> computation has deadlocked, </li>
  <li> amount of crypto coins exceeds a constant \(n\), assuming the
  coins aren't destroyed </li>
  <li> clocks of all agents exceed a constant \(t\), assuming that
  clocks don't go backward.  </li>
</ol>
There may, however, be more efficient solutions for specific problems.
We discuss some of these problems in the following pages.

<h3 class="w3-text-teal">Specification of Detection Algorithms</h3>
A detection algorithm detects whether the state of a computation is in
a stable set \(P\). The algorithm uses a Boolean variable \(B\) which
is initially False and which is set to True when
the algorithm detects that the system is in \(P\) and remains True.
Once \(B\) becomes True it remains True forever thereafter. The
specification is:
<hr class="new2">
<h6 style="color:blue;">
<ol>
  <li>
  If at any point in a computation the system state is in \(P\) then
  there is a point in the computation after which \(B\) remains True.
  </li>
  <li>
  If \(B = True\) at any point in a computation then the system state
  at that point is in \(P\).
  </li>
</ol>
</h6>
<hr class="new2">
Next, we look at different detection algorithms that detect 
different stable sets. Detection algorithms, regardless
of application, are similar.


<h4 class="w3-text-red">
<i>Central Ideas: Review</i></h4>
<p class="w3-text-red">
<i>The state at a consistent cut</i> is a concept that is used in all algorithms
that detect properties of computations.
A global snapshot is a state at a consistent cut.
The global snapshot algorithm uses markers to separate <i>past</i> from
<i>future</i> to identify a consistent cut (<i>past, future</i>).
We will look at more algorithms that determine global snapshots.


<p class="w3-text-red">
<i>Concepts</i>:
Timelines -> causality graphs -> consistent cuts -> global snapshot
algorithms -> detection algorithms.


<h4 class="w3-text-teal">Next</h4>
Next either look at two examples
 -- <a href="TerminationDetectionNew.html">termination</a> and
<a href="DatabaseDeadlockDetection.html">database deadlock</a>
detection --
of snapshots or
move to the next topic, 
<a href="LogicalClocksNew.html">logical clocks</a>.

  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>



</body>
</html>
