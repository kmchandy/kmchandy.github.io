<title>DistributedSystemModels/TimelinesExamples.html</title>

<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>


<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>
  
  <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">


<!---------------------------------------------------------------->
    <h2 class="w3-text-teal">Consistent Cuts, Computations, States: Examples</h2>
<!----------------------------------------------------------------->
This example is of a system with two agents u and v, and four
  channels.
  The channels are between the agents and from each agent to itself.
  The system has a red token and a blue token.
  A token is either at an agent or in a channel between the agents.
  An agent sends a "wakeup" message to itself when the agent has a
  token. Wakeup messages are shown as W in the figure.

  <p>
  The figure shows two states. The diagram on the left-hand side shows
  state S0 in which agent u holds the blue token and agent w holds the
  red token. In S0 there is a wakeup message from each agent to
  itself.

  <p>
  The diagram on the right-hand side shows state S1 in which the blue
  token is in the channel (u, v), and the red token is at v. There is
  a wakeup message from v to itself.

  <p>
  The transition from S0 to S1 occurs when agent u receives a wakeup
  message from itself. In the transition agent u sends the blue token
  to v.

  <figure>
    <img src="ExamplesTimelines/ExamplesTimelines.001.jpeg"
    alt="Fig1" style="width:100%"> 
    <figcaption>Fig.1: Example of a State Transition</figcaption>
  </figure>

  <p>
  The event that describes the transition is shown in the figure
  below.
  The inputs to the event are the state of u before the transition and
  the message received by u that causes the transition.
  The outputs of the event are the state of u after the transition and
  for each agent the sequence of messages sent by u to the agent in
  the transition.
  The input and output agent edges are labeled with the states of the
  agent before and after the transition, respectively.
  The message edges are labeled with the contents of the message.
  (Here the wakeup message is identified by a star.)
  <figure>
    <img src="ExamplesTimelines/ExamplesTimelines.002.jpeg"
    alt="Fig2" style="width:100%"> 
    <figcaption>Fig.2: Example of an Event</figcaption>
  </figure>


<!---------------------------------------------------------------->
    <h3 class="w3-text-teal">State Diagrams</h3>
<!----------------------------------------------------------------->
State diagrams are labeled directed graphs in which the vertices
    represent states and the labeled edges represent state
transitions.
The label of an edge is the channel on which the message is received
    that causes the state transition. This diagram shows some (but not
all) of the states and state transitions.
The label "U_s" on an edge represents a transition in which agent U
<i>s</i>ends a message.
The label "V_r" on an edge represents a transition in which agent V
<i>r</i>eceives a message.


  <figure>
    <img src="Timelines/Timelines.014.jpeg"
    alt="Fig15" style="width:100%"> 
    <figcaption>Fig.3: Example: State Diagram</figcaption>
</figure>


<!---------------------------------------------------------------->
    <h3 class="w3-text-teal">Nondeterministic Receive Functions</h3>
<!----------------------------------------------------------------->
  Throughout this course we will restrict attention to receive
    functions that are deterministic. This example illustrates that
    the model allows for nondeterministic functions. If agent u holds
    a red token and a blue token when it receives a wakeup message the
    agent can send either the red or the blue token. The upper line
    shows transitions in which agent u first sends the blue and then
    the red token. The lower line shows transitions in which u sends
the red token before the blue one.

<p>
This example merely illustrates nondeterminacy in receive functions.
We will use deterministic functions in the future.
  <figure>
    <img src="Timelines/Timelines.015.jpeg"
    alt="Fig15" style="width:100%"> 
    <figcaption>Fig.4: Example: Nondeterminism in Execution of Receive
    Function</figcaption>
</figure>


<!---------------------------------------------------------------->
    <h3 class="w3-text-teal">Computations</h3>
<!----------------------------------------------------------------->
The figure below shows a computation consisting of the sequence of
states [S0, S1, S2, ..., S8].
A computation is a path through the state diagram.
You can see the path in the figure below in the graph shown in figure 3.

  <figure>
    <img src="Timelines/Timelines.016.jpeg"
    alt="Fig15" style="width:100%"> 
    <figcaption>Fig.5: Example: Computation</figcaption>
  </figure>


<!---------------------------------------------------------------->
    <h3 class="w3-text-teal">The State of the System at a Consistent Cut</h3>
<!----------------------------------------------------------------->
The state of the system at a consistent cut (past, future) is the
    state after all the steps in past and before any of the steps in
future.
The state at a consistent cut is illustrated by the labels of edges
that cross the boundary separating past from future.
The figure below shows the dataflow graph for computation [S1, ..,
S6].
The initial and final events are labeled 0 and N respectively (rather
than init and fini as we normally do).

<p>
The steps of the computation are ordered from left to right in the
figure.
So, the consistent cut (past, future) where past consists of steps [1,
.., i] is shown in the diagram by a vertical line between steps i and
i+1, where past is the set of steps to the left of the vertical line.

<p>
Let's look at the state at the consistent cut (past={0,0, 1, 2, 3},
future={4, 5, 6, N, N}). The state of agent u at the cut is the label
of the agent edge for u that crosses the vertical line separating past
from future. The label of this edge is E for "empty."
The state of the agent edge for v is the blue token.

<p>
The state of a channel at a consistent cut is the sequence of message
edges of messages sent on the channel that cross the boundary
separating past from future. For example, the state of the channel (u,
u) is the empty sequence because there is no message edge from u to
itself that crosses the boundary.
The state of the channel from v to u is the red token.



  <figure>
    <img src="ExamplesTimelines/ExamplesTimelines.003.jpeg"
    alt="Fig3" style="width:100%"> 
    <figcaption>Fig.6: Example: System States at Consistent Cuts</figcaption>
  </figure>

The dataflow graph of the figure above and the figure below are
identical.
The steps of the dataflow graph in the figure above are ordered from
left to right in accordance with the computation [0, 0, 1, 2, 3, 4, 5,
6, N, N] while the ordering of the steps from left to right in the
figure below is [0, 0, 2, 1, 3, 5, 4, 6, N, N].
This ordering helps us to pictorially represent consistent cuts in the
lower figure that are different from those in the upper figure.

<p>
For example, the state S'_1 at the consistent cut (past = {0, 0, 2}, future
= {..}) is different from the state S_1 at the consistent cut (past = {0, 0, 1}, future
= {..}).
The states S_2 at the consistent cut (past = {0, 0, 1, 2}, future =
..) is the same in both computations.

<p>
Suppose each agent logs its own computation, then can we tell whether
S_1 or S'1 occurred?
No we cannot, and it doesn't matter.


  <figure>
    <img src="ExamplesTimelines/ExamplesTimelines.004.jpeg"
    alt="Fig4" style="width:100%"> 
    <figcaption>Fig.7: Example: System States at Consistent Cuts in a
    Different Computation</figcaption>
  </figure>

The figure below shows the dataflow graph of the previous two figures
with steps ordered from left to right in the sequence 0, 0, 1, 2,..,
6, N, N. And the figure shows the boundary of the consistent cut (past = {0, 0, 2},
future = {..}) as a curved line. The state at this consistent cut is
also given by the labels of edges that cross the boundary.


  <figure>
    <img src="ExamplesTimelines/ExamplesTimelines.005.jpeg"
    alt="Fig5" style="width:100%"> 
    <figcaption>Fig.9: Example: Consistent Cuts of the Dataflow Graph:
    Past/Future</figcaption>
</figure>





<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
