<title>ChannelSnapshots/ChannelSnapshotsAssignment/ChannelSnapshotsAssignmentSolution.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>
<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>

<nav
class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5
w3-animate-left" 
id="mySidebar">

<a href="javascript:void(0)"
onclick="w3_close()"
class="w3-right w3-xlarge w3-padding-large w3-hover-black
w3-hide-large"
title="Close Menu">
<i class="fa fa-remove"></i>
</a>

<!--END Heading  ---------------------------->
 
<!-- Start Sidebar----------> 
 
<a class="w3-bar-item w3-button w3-hover-black "
href="../../ChannelSnapshots/ChannelSnapshots.html" > 
Global Snapshots
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="../../ChannelSnapshots/LogicalClocks.html" > 
Logical Clocks
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="../../ChannelSnapshots/GlobalSnapshotAlgorithmVideo.mp4" > 
Snapshots: Video
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="../../ChannelSnapshots/ChannelSnapshotsSelfTest.html" > 
Snapshots: Self Test
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="../../ChannelSnapshots/ChannelSnapshotsAssignment/ChannelSnapshotsAssignment.html" > 
Snapshots: Assignment
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="../../ChannelSnapshots/ChannelSnapshotsAssignment/ChannelSnapshotsAssignmentSolution.html" > 
Snapshots: Solution
</a>

</nav>
<!-- End Sidebar---------->
 
<!-- Start overlay ---------------------------------->

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large"
  onclick="w3_close()"
  style="cursor:pointer"
  title="close side menu"
  id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

<!-- End overlay ---------------------------------->
<!--------------------------------------------------------->
    <h2 class="w3-text-teal">Global Snapshotos: Assignment Solution</h2>
<!--------------------------------------------------------->



The graph of agents has the following structure. (Recall that vertices
represent agents, and directed edges represent channels.) All cycles
in the graph pass through agent 0. There is a path from agent 0 to
every agent, and there is path from every agent to agent 0.

    <p>
The system has a set of indivisible indestructible tokens; however,
agents can create tokens. So, the number of tokens in the system may
increase but does not decrease.

    <p class="w3-text-teal">Part 1<p>

Design an algorithm by which agent 0 gets a count \(N_{snap}\) of the
number of tokens in the system which satisfies the following
condition:
    <p>
    \(
    N_{init} \leq N_{snap} \leq N_{init}
    \)
<p>
where \(N_{init}, N_{fini}\) are the numbers of tokens in the system
when the algorithm starts and finishes (respectively).

    <p class="w3-text-teal">Part 2<p>

Give a short proof of the correctness of your algorithm.



    <h1 class="w3-text-teal">Solution</h1>
    There are many solutions; here is one of them.

    
    <hr class="new2">
    <h4 style="color:blue;">
    A general way to solve detection problems is to use two steps:
    <ol>
      <li>
      Take a global snapshot
      </li>
      <li>
      Get information about the snapshot to the agents that need it.
      </li>
    </ol>
    </h4>
    <hr class="new2">
    <p>
    Our challenge is to get information about a snapshot to agent
    \(0\).
    <p>
    In a snapshot algorithm, each agent records its own state and the
    states of incoming channels. This collection of records has to be
    sent to agent \(0\). When there exists a path from every agent to  agent \(0\), an algorithm for
    sending information to agent \(0\) is straightforward. Each agent
    sends its information to <i>exactly one</i> other agent. Since
    there exists a 
    propagation path to agent \(0\), it will receive all the agent and
    channel snapshot information. We have to ensure, however, that
    <ol>
      <li>
      This information doesn't loop around in a cycle forever.
      </li>
      <li>
      The information flows along a path to agent \(0\).
      </li>
    </ol>
    Both these concerns are handled by the nature of this graph: all
    cycles pass through agent \(0\), and there is a
    path from every agent to agent \(0\).
    

    <p>
    The figures below show examples of graphs of agents and channels.
    
    <figure>
    <img src="ChannelSnapshotsAssignment/Slide1.jpg"
    alt="Fig1" style="width:80%">
    <figcaption>Fig.1: Examples of agents and channels</figcaption>
    </figure>

    <p>
    An algorithm for getting information to an agent can be
    simplified when the information is a sum of numbers. Instead of
    sending states of agents and channels, the algorithm sends sums of
    counts. 

    <p>
    We want an agent to send counts to only one other agent; this
    is to prevent double counting. One way to do this is to use agent
    ids. 
    We give an algorithm in which agents have positive integer
    ids, and if there is an edge from agent \(j\) to agent \(k\) then
    \(k > j\) or \(k = 0\). An agent sends its count to its successor
    agent with the highest id, and sends a count of 0 to all other
    successors. 
    <p>
    An agent sends the sum of the counts of its predecessors, its
    own count, and the counts of incoming channels after receiving
    this information.

    <h2 style="color:red;">Illustration of the Snapshot Algorithm
    </h2>
    <p>
    The next sequence of diagrams show an execution of the global
    snapshot algorithm. When an agent records its state the agent is
    shown in red. The markers that an agent sends are shown as red
    circles. Each figure has two diagrams with the diagram on the left
    showing an earlier scenario than the diagram on the right.
    <p>
    For example, the diagram on the left of the next figure (Fig.2)
    shows that 
    agent 0 has recorded its local state (i.e., counted the number of
    tokens in its possession) and sent a marker on each of its outgoing
    channels.
    
    <figure>
    <img src="ChannelSnapshotsAssignment/Slide2.jpg"
    alt="Fig2" style="width:80%">
    <figcaption>Fig.2: Agent 0 records then agents 1, 2 record
    </figcaption>
    </figure>

    In the diagram on the right of Fig. 2, agents 1 and 2 have
    received markers; so they have recorded their states and sent
    markers on their outgoing channels. So, agents 1 and 2 have
    recorded the number of tokens they hold. Also, the numbers of
    tokens on channels from agent 0 to agent 1, and from agent 0 to
    agent 2, are recorded as 0. This is because no messages arrive on
    the channel (0, 1) after agent 1 records its state and before
    receiving a marker on that channel, since agent 1 records its
    state when it receives the marker.
    <p>
    The channels that have been recorded are colored red, and those
    that have not are colored blue.

<p>
    In the next figure, Fig. 3, in the diagram on the left, agent 3
    receives 
    the marker from agent 2, and 
    so agent 3 records its state and sends markers on its outgoing
    channels. The marker from agent 1 to agent 3 is still in the
channel.
<p>
Agent 3 records the number of tokens that it holds, and records the
    number of tokens in the channel (2, 3) as 0.
    
    <figure>
    <img src="ChannelSnapshotsAssignment/Slide3.jpg"
    alt="Fig3" style="width:80%">
    <figcaption>Fig.3: Agent 3 records then agent 0 records channel
    (3, 0)
    </figcaption>
    </figure>
<p>
In the diagram on the right of Fig.3, the marker from agent 3 has
    reached agent 
0.
Agent 0 records the number of tokens it receives along channel
    (3, 0), after agent 0 records its state and before receiving this
marker.
<p>
The marker along the channel from agent 1 to agent 3 is still in the
    channel. The edge (1, 3) continues to be colored blue.


<p>
    In the next figure, Fig. 4, in the diagram on the left, agent 3
    receives 
the marker from agent 1. Agent 3 records the state of channel (1, 3)
    as  the number of tokens agent 3
    received after agent 3 recorded  its state and before getting the
    marker 
    on channel (1, 3).
    
    <figure>
    <img src="ChannelSnapshotsAssignment/Slide4.jpg"
    alt="Fig4" style="width:80%">
    <figcaption>Fig.4: Agent 3 records then agent 0 records channel
    (3, 0)
    </figcaption>
    </figure>
<p>
In the diagram on the right of Fig.4, the marker from agent 3 has been
    received 
    by agent 4, which has recorded its state and sent a marker on its
    outgoing channel.
    
    <figure>
    <img src="ChannelSnapshotsAssignment/Slide5.jpg"
    alt="Fig5" style="width:80%">
    <figcaption>Fig.5: Agent 0 records channel
    (4, 0)
    </figcaption>
</figure>

In the next figure, Fig. 5, the marker from agent 4 has been received by
agent 0 which records the state of channel (4, 0) as the number of
tokens that agent 0 receives along the channel after agent 0 records
its state and before receiving this marker.
<p>
At this point snapshot algorithm has terminated: all agents and
channels have been recorded.
    

<h2 style="color:red;">How Agent 0 Collates Numbers of Tokens</h2>
There are many ways in which agent 0 gets the total number of
tokens. Here is one way.
<p>
A blue message, distinct from tokens and markers, is sent on each
channel. A blue message has a field which is a nonnegative integer;
this field is a count of tokens.
<p>
Agent 0 sends a blue message on each of its outgoing channels after
sending markers on the channels. These blue messages carry a count of
0.
<p>
The figure below, Fig. 6, shows blue messages on channels from agent 0.

    
    <figure>
    <img src="ChannelSnapshotsAssignment/Slide6.jpg"
    alt="Fig6" style="width:80%">
    <figcaption>Fig.6: Agent 0 sends blue messages
    </figcaption>
</figure>
<p>
When an agent receives a blue message on all its incoming channels, it
takes the sum of: (1) the counts of these blue messages,
(2) the counts that it recorded of its incoming
channels in the snapshot algorithm and
(3) the number that it holds as recorded in the snapshot algorithm;
it then sends a blue message containing the
sum to its highest-numbered successor.
<p>
It also sends a blue message containing a count of 0 to all its
successors other than its highest numbered successor.

<p>
The next sequence of diagrams shows how the blue messages are
propagated.


    
    <figure>
    <img src="ChannelSnapshotsAssignment/Slide7.jpg"
    alt="Fig7" style="width:80%">
    <figcaption>Fig.7: Propagation of blue messages
    </figcaption>
</figure>

In the next figure, Fig. 8, for the diagram on the left,
agent 3 has received blue messages from
both its incoming channels. So, it sends the sum of its snapshot
counts and the sum in these blue messages to agent 4, and sends a blue
message to agent 0 with a count of 0.
<figure>
    <img src="ChannelSnapshotsAssignment/Slide8.jpg"
    alt="Fig8" style="width:80%">
    <figcaption>Fig.8: Propagation of blue messages
</figcaption>
For the diagram on the right, agent 4 has received a blue message on
all its incoming channels, and so it sends its sum to the
highest-numbered successor, which is agent 0.
</figure>
<figure>
    <img src="ChannelSnapshotsAssignment/Slide9.jpg"
    alt="Fig9" style="width:80%">
    <figcaption>Fig.9: Propagation of blue messages
    </figcaption>
</figure>
When agent 0 receives blue messages for all its incoming channels, and
has finished its part of the snapshot algorithm it sums all the counts
to get \(N_{snap}\).
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
