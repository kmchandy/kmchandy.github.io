<title>Knowledge/Knowledge.html</title>
<!------------- Start Heading -------------------------------->
<!DOCTYPE html>

<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet"
href="https://www.w3schools.com/w3css/4/w3.css">

<link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Roboto">

<link rel="stylesheet"
href="https://www.w3schools.com/lib/w3-theme-blue.css">

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* blue border */
hr.new1 {
  border: 2px solid blue;
}
</style>


<body>
<div class="w3-top">
<div class="w3-bar w3-theme w3-top w3-left-align w3-large">
  
  <a class="w3-bar-item w3-button w3-right w3-hide-large
  w3-hover-white w3-large w3-theme-l1"
  href="javascript:void(0)"
  onclick="w3_open()">
  <i class="fa fa-bars"></i></a>

  <a href="../index.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Distributed Algorithms
  </a>

  <a href="../table_of_contents.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Contents
  </a>

  <a href="../cross_reference.html"
  class="w3-bar-item w3-button w3-hide-small w3-hover-white">
  Index
  </a>
    
  </div>
  </div>

<nav
class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5
w3-animate-left" 
id="mySidebar">

<a href="javascript:void(0)"
onclick="w3_close()"
class="w3-right w3-xlarge w3-padding-large w3-hover-black
w3-hide-large"
title="Close Menu">
<i class="fa fa-remove"></i>
</a>

<!--END Heading  ---------------------------->
 
<!-- Start Sidebar----------> 
 
<a class="w3-bar-item w3-button w3-hover-black "
href="../Knowledge/Knowledge.html" > 
What Agents Know & How they Learn
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="../Knowledge/KnowledgeExample.html" > 
Agent Knowledge: Example
</a>
<a class="w3-bar-item w3-button w3-hover-black "
href="../Knowledge/KnowledgeSelfTest.html" > 
Agent Knowledge: Self Test
</a>

</nav>
<!-- End Sidebar---------->
 
<!-- Start overlay ---------------------------------->

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large"
  onclick="w3_close()"
  style="cursor:pointer"
  title="close side menu"
  id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
<div class="w3-row w3-padding-64">
<div class="w3-twothird w3-container">

<!-- End overlay ---------------------------------->
    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">What Agents Know</h1>

<h4 class="w3-text-teal">
This module gives a formal definition for the frequently used informal
phrase: "An agent <i>knows</i> something about other agents and and
channels." 
</h4>


    <h1 class="w3-text-teal">Key Ideas</h1>
    We sometimes use anthropmorphic arguments in reasoning about
    systems --- we invest digital
    agents with human characteristics. For example, a programmer may
    say "an agent <i>knows</i> that another agent is idle." Endowing software with
    human capabilities can be dangerous when terms are ambiguous.
    <p>
    In this module we define a predicate "agent \(x\)
    knows \(P\)" where \(P\) is a predicate on states of a system.
    In later modules, we will use this definition to discuss
    algorithms.

    <p>
    This module presents theorems about what agents know. The proofs
    of these theorems follow from the definition of
    <a href="../ChannelSnapshots/ChannelSnapshots.html">consistent
    cuts </a>.

    <h2 class="w3-text-teal">What an Agent Knows</h2>
    Let \(x\) be an agent, \(P\) a predicate on system states, and
    \(Q\) a predicate on states of \(x\).
    <p>
    \(P\) can be a <i>global predicate</i>, i.e., a predicate on
    states of all agents and channels. \(Q\) is a <i>local
    predicate</i> of \(x\) because it is a predicate only on the states of
    agent \(x\) and is independent of other agents and only channels.

<p>
Let \(init\) be the predicate that defines the initial condition of
the system. 

    <p>
    We
    define the predicate "\(x\) <i>knows</i> \(P\)" as follows.
    <hr class="new2">
    <h5 style="color:blue;">
    <p>
    \(x\) knows \(P\) is the weakest local predicate \(Q\) of
    \(x\) such that:
    <p>
    \(
    [init \; \Rightarrow \; always([Q \;
    \Rightarrow \; P])]
    \)
    <p>
    </h5>
    <hr class="new2">
    <p>
    \(x\) knows \(P\) holds in a local state \(s_{x}\) of agent \(x\)
exactly when \(P\) holds in all states of all trajectories
    (that start from an initial state) when the
local state of agent \(x\) is \(s_{x}\).

<h4 class="w3-text-teal">Explanation</h4>
For any predicate \(R\):
<p>
\(
[init  \; \Rightarrow \; always(R)]
\)
<p>
means that \(R\) holds in every state of every trajectory that starts
in an initial state. So, 
<p>
\(
[init  \; \Rightarrow \; always([Q \Rightarrow P])]
\)
<p>
means that in \([Q \Rightarrow P]\) holds in every state of every
trajectory that starts in an initial state.
So, if local predicate \(Q\) of agent \(x\) holds in any
state of any trajectory that starts from an initial state then global predicate \(P\)
also holds in that state.


<p>

    <h3  style="color:red;">Example</h3>
    A system consisting of agents \(0, \ldots,  N\) has two indivisible
    tokens which are not created or destroyed. 

<p>
"Agent \(0\) knows no other agent holds a token" is a predicate on the states of agent
\(0\); this predicate holds for a local state \(s_{0}\) of agent \(0\)
if and only if no other agent holds a token when agent \(0\) is in
state \(s_{0}\).
<p>
So, "agent \(0\) knows P" holds exactly when agent \(0\)
holds both tokens. 

<p  style="color:red;">Example</p>
This example deals with a system consisting of two agents \(x\) and
\(y\) and channels in both directions between the agents. The system
has a single indivisible token that is not created or destroyed.
Let
\(P\) be the predicate: "\(y\) does <i>not</i> hold the token."
Agent \(x\) knows \(P\) when \(x\) holds the token. 
<p>
\(\neg\) (\(x\) knows \(P\)) is a predicate too, and sometimes
programmers refer to this predicate as "\(x\) does not know \(P\)."

<p  style="color:red;">Example</p>
In the previous example, let \(Q\) be the predicate: "\(y\) holds the token."
In what local states of agent \(x\) does \(x\) know that "\(y\) holds the token?"
<p>
There are no local states of agent \(x\) in which \(x\) knows that
"\(y\) holds the token." Even when \(x\) does not hold the token,
\(x\) does not know that \(y\) holds the token because
the token could be in a channel.
<p>
When \(x\) does not hold the token, \(x\) does not know that \(y\) holds
the token and \(x\) does not know that \(y\) does not hold the token.
<p>
"NOT(x knows Q)" AND "NOT(x knows NOT Q)"
<br>
is a predicate which holds in the
state which \(x\) does not hold the token.

<h5 class="w3-text-teal">Notation</h5>
    "\(x\) knows \(P\) at a point \(T\)" in a timeline means that at
    point \(T\) agent \(x\) is in a state where the predicate "\(x\)
knows \(P\)" holds.


<h3 class="w3-text-teal">Theorem: Knowledge and Consistent Cuts</h3>
Let \(P\) be a predicate on the states of a system.
<p>
<i style="color:blue;">
If  \(x\) knows \(P\) at a point \(T\) in \(x\)'s timeline
then \(P\) holds in every consistent cut through that point.</i>

<p class="w3-text-teal">Proof</p>
The states corresponding to all consistent cuts that pass through the same
point on \(x\)'s timeline have the same common value for \(x\)'s local
state.

    <h3  style="color:red;">Example</h3>
    
<figure>
    <img src="KnowledgeDiagrams/Slide02.jpg" alt="Fig2" style="width:60%">>
    <figcaption>Fig. 2. Agent A knows P in all consistent cuts that cross
    point T</figcaption>
</figure>

<p>
The top figure in both diagrams above show a time T at which agent A knows
that P holds. This implies that P holds in all consistent cuts through
point T. The lower figures in the diagrams show consistent cuts which
passes point T on A's timeline; the theorem says that P holds for the
state at these cuts too. 

<h3 class="w3-text-teal">Theorem: A Silent Agent retains
Knowledge</h3>
<hr class="new2">
<h5 style="color:blue;">
An agent that sends no information between a point \(T\) and a later
point \(T'\) retains all the knowledge it has at \(T\) at \(T'\).
</h5>
<hr class="new2">

Let \(x\) be an agent in a system, and let \(P\) be a
predicate on a subsystem that does not include \(x\).
Let \(T\) and \(T'\) be points on \(x\)'s timeline with \(T < T'\). If
\(x\) knows \(P\) at point \(T\) and \(x\) sends no messages in the
interval \([T, T']\) then \(x\) knows \(P\) at \(T'\).

<p class="w3-text-teal">Proof</p>
Let \(c'\) be any consistent cut through point \(T'\) on \(x\)'s
timeline. We will prove that \(P\) holds for the state at cut \(c'\).

<p>
Let \(c\) be the
cut that is identical to \(c'\) except that it passes through point \(T\) on
\(x\)'s timeline. \(c\) is consistent because there are no
outgoing edges from \(x\)'s timeline between cuts \(c\) and
\(c'\).

<p>
Because \(x\) knows \(P\) at \(T\), \(P\) holds at \(c\). Since \(c\) and \(c'\)
are identical except for the intersection with \(x\)'s timeline,
it follows that \(P\) holds \(c'\).

<h5  style="color:red;">Example</h5>
<figure>
    <img src="KnowledgeDiagrams/Slide04.jpg" alt="Fig3" style="width:60%">>
<figcaption>Fig. 3. Illustration of Proof of Silent Agents
</figcaption>
</figure>

<h5 class="w3-text-teal">Consequence of the Theorem</h5>
An agent doesn't lose knowledge by getting information from other
agents.
<p>
An agent can only lose knowledge by sending information to
other agents. This seems counterintuitive; we'll look at the reasoning
underlying this in a later theorem.

<h3 class="w3-text-teal">Theorem: Agents who don't listen remain
Ignorant</h3> 
<hr class="new2">
<h5 style="color:blue;">
An agent that receives no information between a point \(T\) and a later
point \(T'\) learns no new knowledge between \(T\) and \(T'\).
</h5>
<hr class="new2">
Let \(x\) be an agent in a system, and let \(P\) be a
predicate on a subsystem that does not include \(x\).
Let \(T\) and \(T'\) be points on \(x\)'s timeline with \(T < T'\). If
\(x\) knows \(P\) at point \(T'\) and \(x\) received no messages in the
interval \([T, T']\) then \(x\) knows \(P\) at \(T\).

<p>The proof has exactly the same structure as the proof of the
previous theorem.

<h5 class="w3-text-teal">Consequence of the Theorem</h5>

\(x\) didn't learn anything in the interval  \([T, T']\); everything
\(x\) knows at the later point \(T'\) is knowledge it already had at
the earlier point \(T\).

<p>The only way for an agent to gain knowledge is
to receive messages. An agent cannot learn about other agents by only
sending messages or making internal state transitions.


<h3 class="w3-text-teal">Theorem: Knowledge implies Control</h3>
Let \(x\) and \(y\) be agents in a system, and let \(P\) be a
predicate on the states of \(y\).
Let \(T\) and \(T'\) be instants in a trajectory with \(T < T'\). If
\(x\) knows \(P\) at  \(T\), and \(\neg P\) holds at \(T'\), then there
is a path in the timeline diagram from point \(T\) on \(x\)'s timeline
to point \(T'\) on \(y\)'s timeline.

<p>Proof: If there is no path from point \(T\) on \(x\)'s timeline
to point \(T'\) on \(y\)'s timeline then there exists a consistent cut
which crosses \(x\)'s timeline at \(T\) and
crosses \(y\)'s timeline at \(T'\).

<h5  style="color:red;">Example</h5>
In the figure below, agent \(A\) at point \(T\) knows that agent \(C\)
holds no tokens. At a later point \(T'\) agent \(C\) holds a
token. What must happen between points \(T\) and \(T'\)?
<figure>
    <img src="KnowledgeDiagrams/Slide08.jpg" alt="Fig4" style="width:60%">>
<figcaption>Fig. 4. What must happen between T and T'?
</figcaption>
</figure>

There must be a path in the timeline diagram from point \(T\) on agent
\(A\)'s timeline to point \(T'\) on agent \(C\)'s timeline. This path
is represented by edges that show time elapsing on a timeline and
message edges between timelines.
<figure>
    <img src="KnowledgeDiagrams/Slide09.jpg" alt="Fig5" style="width:60%">>
<figcaption>Fig. 5. There must be a path from A at T to C at T'?
</figcaption>
</figure>

<h5 class="w3-text-teal">Consequence of the Theorem</h5>
Suppose you and your friend communicate only by means of messages
that are delayed by arbitrary (finite) amounts. Consider a situation
where your friend knows
that you are in the library at 9 pm. Then, from our definition of
knowledge, because agents only know truth, you must be in the library
at 9 pm. Moreover, you can't leave the library until
you receive a message from your friend; this message may go through
intermediate agents.

<p>
In one of the exercises we'll look at knowledge when agents have
clocks that may drift from each other but are not more than a some
constant \(M\) units apart. If your friend knows that you will be in
the library till her watch reads 9:00 pm, and your watches may drift apart
by a minute, then you can leave the library at 9:01 pm. Clocks are
useful even if they aren't perfect. More about clocks later.


<h3 class="w3-text-teal">Theorem: Communication to learn about
Change</h3>
This theorem is similar to the "knowledge is control" theorem.

<p>
Let \(x\) and \(y\) be agents in a system, and let \(P\) be a
predicate on the states of \(y\).
Let \(T\) and \(T'\) be instants in a trajectory with \(T < T'\). If
\(\neg P\) holds at \(T\) and \(x\) knows \(P\) at \(T'\) then there
is a path in the timeline diagram from point \(T\) on \(y\)'s timeline
to point \(T'\) on \(x\)'s timeline.

<h5  style="color:red;">Example</h5>
In the figure below, agent \(C\) holds a token at point \(T\).
At a later point \(T'\) agent \(A\) knows that agent \(C\) holds no
tokens. What must happen between points \(T\) and \(T'\)?
<figure>
    <img src="KnowledgeDiagrams/Slide10.jpg" alt="Fig6" style="width:60%">>
<figcaption>Fig. 6. What must happen between T and T'?
</figcaption>
</figure>

There must be a path in the timeline diagram from point \(T\) on agent
\(C\)'s timeline to point \(T'\) on agent \(A\)'s timeline. This path
is represented by edges that show time elapsing on a timeline and
message edges between timelines.
<figure>
    <img src="KnowledgeDiagrams/Slide11.jpg" alt="Fig7" style="width:60%">>
<figcaption>Fig. 7. There must be a path from C at T to A at T'?
</figcaption>
</figure>

<h3 class="w3-text-teal">What Agents Know about Channel States</h3>
Next, let's look at systems in which messages are acknowledged.
For a pair of agents \(x, y\), let \(ms\) and \(mr\)
be the number of messages that \(x\) has sent to \(y\), and  the number 
of messages that \(y\) has received from \(x\), respectively.
Let \(as\) and \(ar\) be
the number of acknowledgements that \(y\) has sent to \(x\), and
the number of acknowledgements that \(x\) has received from \(y\),
respectively.

The following is an invariant:
<p>
\(ms \geq mr \geq as \geq ar \)

<p>
The number of messages in the channel from \(x\) to \(y\) is \(ms -
mr\).
Because \(ms\) and \(ar\) are variables of agent \(x\),
agent \(x\) <i>knows</i> an upper bound,\(\; ms - ar\), on the number of
messages in channel \((x, y)\).
So, \(x\) knows that the channel is empty when \(\; ms = ar\).

<h3 class="w3-text-teal">What an agent cannot know</h3>
An agent cannot know that there are
exactly \(n\) messages in a channel, for \(n > 0\).
You can prove this result using the concept of consistent
cuts. Intuitively, the agent cannot know whether a message is in the
channel or has been received.

<h3 class="w3-text-teal">Chains of Knowledge</h3>
Let \(x, y, z\) be agents of a system and \(P\) be a predicate on
states of the system. Then the following are all predicates:
<ol>
  <ul>
    \(z\) knows \(P\)
  </ul>
  <ul>
    \(y\) knows that \(z\) knows \(P\)
  </ul>
  <ul>
    \(x\) knows that \(y\) knows that \(z\) knows \(P\)
  </ul>
</ol>
The theorems given earlier apply to any predicate. For example, if
\(x\) knows that \(y\) knows that \(z\) knows \(P\) at a point \(t\) in a
trajectory, and \(\neg P\) holds at a later point \(t'\)
then there must be path in the timeline diagram from point \(t\) on
\(x\)'s timeline to point \(t'\) on \(z\)'s timeline.

<h5 class="w3-text-teal">Concurrent Systems with Shared Variables</h5>
The theorems
and proofs given in this module apply to systems with shared
variables, and indeed any system with trajectories that are
representable by timeline diagrams and with consistent cuts.

<h3 class="w3-text-teal">Summary</h3>
Many people working on distributed systems use the phrase "an agent
knows." This module gives a definition of the concept that is
consistent with intuitive definitions of knowledge.
The central idea in this module is the
relationship between what agents know and consistent cuts of
timelines. We presented several theorems about agent knowledge which
are intuitive when applied to human agents. The proofs are
straightforward and are all based on consistent cuts of timelines.

<h4 style="color:blue;">Review</h4>
<ol>
  <li>
  Is the following true? Why?
  <p>
  (\(z\) knows \(P\)) and (\(z\) knows \(Q\)) \(\equiv\) \(z\) knows
  \(\(P \wedge Q\))
  </li>
  <li>
  Is the following true? Why?
  <p>
  (\(z\) knows \(P\)) or (\(z\) knows \(Q\)) \(\equiv\) \(z\) knows
  \(\( P \vee Q\))
  </li>
  <li>
  Suppose you and your friend communicate only using messages sent in
  channels, just as agents do in our model of distributed
  systems. When you <i>know</i> that your friend is wearing a cap does
  that mean that (a) your friend is wearing a cap, and (b) your friend
  can't take the cap off until the friend hears from you?
  </li>
</ol>
  
<!--Start Footer--------------------------------------->

    <hr class="new1">
      <p>K. Mani Chandy,
      Emeritus Simon Ramo Professor,
      California Institute of Technology</p>
    
</footer>
    


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>
