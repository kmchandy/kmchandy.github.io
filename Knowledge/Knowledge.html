<!DOCTYPE html>
<html lang="en">
<title>Knowledge</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* Thick blue border */
hr.new1 {
  border: 1px solid blue;
}
</style>
<body>


<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()"><i class="fa fa-bars"></i></a>
    <a href="../index.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">About the Course</a>
    <a href="../table_of_contents.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">Table of Contents</a>
    <a href="../cross_reference.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Index</a>
  </div>
  </div>
 

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left" id="mySidebar">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="Close Menu">
    <i class="fa fa-remove"></i>
  </a>

  <!-------------------------->
  <h3 class="w3-bar-item"><b>An Introduction to Distributed
  Algorithms</h3>
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="Knowledge.html">Knowledge</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="KnowledgeExample.html">Examples</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="KnowledgeSelfTest.html">Self Test</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="KnowledgeExercises.html">Exercises</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="Knowledge.html">Explorations</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="../DiffusingComputations/DiffusingComputations.html">
  Next: Diffusing Computations</a> 
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="../DeadlockDetection_And/DeadlockDetection_And.html">Previous:
  Detecting Deadlocks I
  </a>
  
</nav>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
  <div class="w3-row w3-padding-64">
  <div class="w3-twothird w3-container">

    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">What Agents Know</h1>
    We sometimes invest software
    agents with human characteristics. For example, a programmer may
    say "an agent <i>knows</i> that another agent is idle." Endowing software with
    human capabilities can be dangerous when terms are ambiguous.
    In this module we give a definition to the phrase "an agent
    knows \(P\)." We will use this definition to prove theorems that
    we will use to design algorithms. The definitions and proofs are based on
    <a href="../ChannelSnapshots/ChannelSnapshots.html">consistent
    cuts.</a>

    <h3 class="w3-text-teal">What an agent knows</h3>
    For an agent \(x\), a state \(r\) of \(x\), and a predicate \(P\),
    we use the phrase "<i style="color:blue;">agent \(x\) in state
    \(r\) knows \(P\)</i>" 
    to mean \([(s_{x} = r) \; \Rightarrow \; P]\) is an invariant of
    the system.
    Therefore, at every point of every trajectory of the
    system, if the local state of agent \(x\) is \(r\) then the global
    state satisfies \(P\).
    We define a boolean function \(knows\) with arguments \(x, r,
    P\) where
    \(knows(x, r, P)\) means: "agent \(x\) in state
    \(r\) knows \(P\)":
    
    <p>
    <hr class="new2">
    <p>
    \(
    knows(x, r, P) \quad = \quad
    invariant \; [(s_{x} = r) \; \Rightarrow \; P]
    \)
    <hr class="new2">
    

    <p>
    If <i>\(x\) in state \(r\) knows \(P\)</i> where
    \(P\) is a predicate on the state of an agent \(y\) other
    than \(x\), then the state of one agent gives us information about
    the state of another agent. The phrase "\(x\)
    knows" captures the idea that the our knowledge of the state of
    \(y\) is based solely on the state of \(x\).

    <p>
    The next theorem tells us that if at some point in a trajectory,
    \(x\) is in a  state \(r\) such that \(knows(x, r, P)\), where
    \(P\) is a predicate on the state of another  agent \(y\), then
    \(y\) cannot transit to a state in which \(\neg P\) without
    receiving communication from \(x\). This communication from \(x\)
    could be via intermediate agents. Speaking informally, it's as though
    \(y\) needs permission from \(x\) to get out of states in which
    \(P\) holds. 


<!------------------------------------------------------------>
<h4 class="w3-text-teal">Theorem: Knowledge and Communication</h4>
Let \(x\) and  \(y\) be different agents in a system, and let \(P\) be a
predicate on the states of \(y\).

<p>
\(P\) holds at every point in a trajectory if:
<ol>
  <li>
  The initial state of of \(x\) is \(r\) such
  that \(knows(x, r, P)\), and
  </li>
  <li>
  the timeline diagram of the trajectory has no path from an event in
  the timeline of \(x\) to an event in the timeline of \(y\).
  </li>
</ol>

<p class="w3-text-teal">Proof</p>
Let \(t\) be the initial point of the trajectory, i.e., the point
before any agent executes any event.
Let \(t'\) be any arbitrary point on the trajectory.

<p>
We will show that there is a consistent cut that intersects the
timeline of \(x\) at point \(t\) and intersects the timeline of \(y\)
at point \(t'\).

<p>
Define the <i>future</i> as the set of events that are reachable from
events in the timeline for \(x\). Define the <i>past</i> as the
remaining events. All edges directed from the future are to the
future. Therefore the cut is consistent. And so the state, \(s\),
corresponding to the cut is a reachable global state. 

<p>
The local state of \(x\) is \(r\) when the global state is
\(s\). Because \(x\) in state \(r\) knows \(P\), it follows
that \(P\) holds in state \(s\).



<h4 class="w3-text-teal">Corollary: Permission to Falsify</h4>
If
at some point \(t\) in the trajectory, \(x\) is in a state \(r\)
such that \(knows(x, r, P)\), where  \(P\) is a predicate on the
  states of a different agent \(y\), and
  at a later point \(t'\) in the trajectory, \(\neg P\) holds,

then there is a chain of messages, starting from \(x\) after \(t\) and
ending with \(y\) before \(t'\). This message chain may go through
intermediate vertices.

<p class="w3-text-teal">Discussion</p>
 This message chain is the communication
from \(x\) that permits \(y\) to change its state from one in which
 \(P\) holds to one in which \(\neg P\) holds.

<h4 class="w3-text-teal">Corollary: Persistence of knowledge in silent
agents</h4>
If at some point \(t\) in the trajectory, \(x\) is in a state \(r\)
such that \(knows(x, r, P)\), where  \(P\) is a predicate on the
states of a different agent, and \(x\) sends no messages from point
\(t\) to a later point \(t'\), then \(P\) holds at every point between 
\(t\) and \(t'\).

<p class="w3-text-teal">Discussion</p>
From the <i>permission to falsify</i> corollary, \(y\) cannot falsify
\(P\) because \(y\) needs permission from \(x\) to do so, and \(x\)
remains silent.


<!------------------------------------------------------------>
<h4 class="w3-text-teal">Theorem: Learning from Communication</h4>
Let \(x\) and  \(y\) be different agents in a system, and let \(P\) be a
predicate on the states of \(y\). Let \(s_{x}\) be the local state of
agent \(x\) when the global state is \(s\).


<p>
In a trajectory, if
<ol>
  <li>
  \(\neg P\) holds in the initial state, and
  </li>
  <li>
  there is no path from an event in
  the timeline of \(y\) to an event in the timeline of \(x\).
  </li>
</ol>
then \( \neg knows(x, s_{x}, P)\) holds at every state.

<p class="w3-text-teal">Proof</p>

Let \(t\) be the initial point of the trajectory, i.e., the point
before any agent executes any event.
Let \(t'\) be any arbitrary point on the trajectory.

<p>
We will show that there is a consistent cut that intersects the
timeline of \(y\) at point \(t\) and intersects the timeline of \(x\)
at point \(t'\).

<p>
Define the <i>future</i> as the set of events that are reachable from
events in the timeline for \(y\). Define the <i>past</i> as the
remaining events. All edges directed from the future are to the
future. Therefore the cut is consistent. And so the state, \(s\),
corresponding to the cut is a reachable global state. 

<p>
In state \(s\), \(\neg P\) holds and the local state of agent \(x\) is
\(s_{x}\). So, \([s_{x} \Rightarrow P]\) is not an
invariant. Therefore, \( \neg knows(x, s_{x}, P)\).


<p class="w3-text-teal">Discussion</p>
If \(\neg P\) holds initially, and agent \(x\) receives no
communication from agent \(y\), then \(x\) does not know whether \(P\)
holds.



<h4 class="w3-text-teal">Corollary: Learn by Listening</h4>
Let \(x\) and \(y\) be different agents in a system, and let \(P\) be
a predicate on the states of \(y\).  If at some point \(t\) in the
trajectory, \(\neg P\) holds, and at a later point \(t'\) in the
trajectory, \(knows(x, r, P)\) holds, then there is a chain of
messages that starts from \(y\) after \(t\) and \(P\) holds, and
that ends with \(y\) before \(t'\).

<p class="w3-text-teal">Discussion</p>
 This message chain is the communication
from \(y\) that informs \(x\) that \(P\) holds.

<h4 class="w3-text-teal">Corollary: Persistence of ignorance among
agents that don't listen</h4>
If at some point \(t\) in the trajectory, \(\neg P \) holds, where  \(P\) is a predicate on the
state of an agent \(y\), and a different agent \(x\) receives no messages from point
\(t\) to a later point \(t'\), then \( \neg knows(x, s_{x}, P)\) holds at
at every point between \(t\) and \(t'\).

<p class="w3-text-teal">Discussion</p>
If agent \(x\) receives no messages from any agent then it cannot
learn that a different agent has changed state.


<h2 class="w3-text-teal">Extensions</h2>

<h4 class="w3-text-teal">Chains of Knowledge</h4>
Let \(s_{x}\) be the local state of an agent \(x\) when the global
state is \(s\).
We define a function \(K\) from agents-predicates to
predicates as follows.
For an agent \(x\) and a predicate \(P\):
\(K(x, P)\) is a predicate which holds for a global state
\(s\) exactly when \(knows(x, s_{x}, P)\).

<p>
We can define predicates with arbitrarily long applications of \(K\),
for example \(K(x, K(y, K(z, P)))\). The theorems and corollaries
given above can be applied to such chains. The following result is one
example.

<p class="w3-text-teal">Chains of Permission</p>
If \(K(x, K(y, K(z, P)))\) holds at a point \(t\) in a
trajectory, and \(\neg P\) holds at a later point \(t'\)
then there must be a
chain of communications that starts after \(t\) and ends before \(t'\),
where the chain is first from \(x\) to \(y\), and then from
\(y\) to \(z\). 


<h4 class="w3-text-teal">Knowledge about Subsystems</h4>
A subsystem of a system consists of a subset of the agents and the
channels between them. The theorems about knowledge of the state of an
agent apply to knowledge of subsystems.

<p>
For example, let \(P\) be a predicate on the states of a subsystem,
and \(x\) be an agent that is not in the subsystem.  If\(x\) knows
\(P\) at a point \(t\) in a trajectory, and \(\neg P\) holds at a
later point \(t'\) then there is a chain of messages from \(x\) to
some agent in the subsystem.

<h4 class="w3-text-teal">Shared Variables other than Channels</h4>
Systems with shared variables other than channels are described in <a
href="../Agents/Agents.html">the module on agents</a>. The theorems
and proofs given in this module apply to such systems because the
concept of consistent cuts is identical for systems with shared
variables and systems with message-passing channels.




  <footer id="myFooter">

    <div class="w3-container w3-theme-l1">
      <h4>An Introduction to Distributed Algorithms by K. Mani Chandy,
      <br>
      Simon Ramo Professor, Emeritus, California Institute of Technology</h4>
    </div>
  </footer>


      


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>

