<!DOCTYPE html>
<html lang="en">
<title>Knowledge</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
/* Thick blue border */
hr.new2 {
  border: 2px solid blue;
}
/* Thick blue border */
hr.new1 {
  border: 1px solid blue;
}
</style>
<body>


<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()"><i class="fa fa-bars"></i></a>
    <a href="../index.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">About the Course</a>
    <a href="../table_of_contents.html" class="w3-bar-item w3-button w3-hide-small
    w3-hover-white">Table of Contents</a>
    <a href="../cross_reference.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Index</a>
  </div>
  </div>
 

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left" id="mySidebar">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="Close Menu">
    <i class="fa fa-remove"></i>
  </a>

  <!-------------------------->
  <h3 class="w3-bar-item"><b>An Introduction to Distributed
  Algorithms</h3>
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="Knowledge.html">Knowledge</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="KnowledgeExample.html">Examples</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="KnowledgeSelfTest.html">Self Test</a>

  <a class="w3-bar-item w3-button w3-hover-black"
  href="../DiffusingComputations/DiffusingComputations.html">
  Next: Diffusing Computations</a> 
  
  <a class="w3-bar-item w3-button w3-hover-black"
  href="../DeadlockDetection_And/DeadlockDetection_And.html">Previous:
  Detecting Deadlocks I
  </a>
  
</nav>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div class="w3-main" style="margin-left:250px">
  
<script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
  <div class="w3-row w3-padding-64">
  <div class="w3-twothird w3-container">

    <!--------------------------------------------------------->
    <h1 class="w3-text-teal">What Agents Know</h1>

    <h1 class="w3-text-teal">Key Ideas</h1>
    We sometimes invest software
    agents with human characteristics. For example, a programmer may
    say "an agent <i>knows</i> that another agent is idle." Endowing software with
    human capabilities can be dangerous when terms are ambiguous.
    In this module we define a predicate "an agent
    knows \(P\)" where \(P\) is a predicate on states of a system.
    We use this definition to develop algorithms. The definitions and
    proofs are based on the concepts of timelines and 
    <a href="../ChannelSnapshots/ChannelSnapshots.html">consistent
    cuts.</a>

    <p>
    This module has several theorems which are obvious from the
    definitions of consistent cuts and what agents know.

    <h3 class="w3-text-teal">What an Agent Knows</h3>
    For an agent \(x\), a state \(r\) of \(x\), and a predicate \(P\),
    <hr class="new2">
    <h5 style="color:blue;">
    "<i style="color:blue;">agent \(x\) in state \(r\) knows \(P\)</i>" 
    is a Boolean which holds if and only if:
    <p>
    \(P\) holds when agent \(x\) is in state \(r\) in
    all trajectories that start in initial states, i.e.,
    <p style="text-align:center">
    \(
    [init \; \Rightarrow \; always([(x \; \textrm{in} \; r) \;
    \Rightarrow \; P])]
    \)
    </p>
    </h5>
    <hr class="new2">

    <p class="w3-text-teal">Notation</p>
    We restrict attention to system trajectories that start in initial states.
    For an agent \(x\), predicate \(P\), and a point \(T\) in a
    trajectory, the phrase
    "<i style="color:blue;">\(x\) knows \(P\) at \(T\)</i>"
    means that at point \(T\), \(x\) is in a state in which \(x\)
    knows \(P\).
    <p>
    We use the abbreviation "<i style="color:blue;">\(P\) holds at a consistent cut</i>" for
    "\(P\) holds at the global state corresponding to a consistent cut"

    <h3  style="color:red;">Example</h3>
    A system has two agents \(x\) and \(y\) with channels between
    them. Initially, the system has a single indivisible, indestructible
    tokens that cannot be created. So, the system has a single tokens in
every state in every trajectory.
<p>
When \(x\) is in a state in which it holds the token then \(x\)
knows that \(y\) holds no tokens.
<p>
When \(x\) is in a state in which it holds no tokens then \(x\) knows
that the token is in a channel or at \(y\).
The following statement is False. "When \(x\) is in a state in which
it holds no tokens, \(x\) knows that \(y\) holds the token."
The statement is False because the token could be in a channel.


<h3 class="w3-text-teal">Theorem: Knowledge and Consistent Cuts</h3>
Let \(P\) be a predicate on the states of a system.
<p>
<i style="color:blue;">
If  \(x\) knows \(P\) at a point \(T\) in \(x\)'s timeline
then \(P\) holds in every consistent cut through point
\(T\).</i>

<p>
The proof of this statement follows from our earlier proof that there
exists trajectories from initial states to all consistent cuts. And
since \(P\) holds for the entire system given the state of agent \(x\) at point \(T\) on
\(x\)'s timeline, it follows that \(P\) holds for the state at every consistent cut.

    <h3  style="color:red;">Example</h3>
    
<figure>
    <img src="KnowledgeDiagrams/Slide2.jpg" alt="Fig2" style="width:60%">>
    <figcaption>Fig. 2. Agent A knows P in all consistent cuts that cross
    point T</figcaption>
</figure>

<p>
The top figurea in both diagrams above show a time T at which agent A knows
that P holds. This implies that P holds in all consistent cuts through
point T. The lower figures in the diagrams show consistent cuts which
passes point T on A's timeline; the theorem says that P holds for the
state at these cuts too. 

<h3 class="w3-text-teal">Theorem: A Silent Agent retains Knowledge</h3>
Let \(x\) be an agent in a system, and let \(P\) be a
predicate on a subsystem that does not include \(x\).
Let \(T\) and \(T'\) be points on \(x\)'s timeline with \(T < T'\). If
\(x\) knows \(P\) at point \(T\) and \(x\) sends no messages in the
interval \([T, T']\) then \(x\) knows \(P\) at \(T'\).

<p class="w3-text-teal">Proof</p>
Let \(c'\) be any consistent cut through point \(T'\) on \(x\)'s
timeline. We will prove that \(P\) holds for the state at cut \(c'\).

<p>
Let \(c\) be the
cut that is identical to \(c'\) except that it passes through point \(T\) on
\(x\)'s timeline. \(c\) is consistent because there are no
outgoing edges from \(x\)'s timeline between cuts \(c\) and
\(c'\). Because \(x\) knows \(P\) at \(T\), \(P\) holds at \(c\). Since \(c\) and \(c'\)
are identical except for the intersection with \(x\)'s timeline,
it follows that \(P\) holds \(c'\).

<h3 class="w3-text-teal">Theorem: Agents who don't listen remain Ignorant</h3>
Let \(x\) be an agent in a system, and let \(P\) be a
predicate on a subsystem that does not include \(x\).
Let \(T\) and \(T'\) be points on \(x\)'s timeline with \(T < T'\). If
\(x\) knows \(P\) at point \(T'\) and \(x\) received no messages in the
interval \([T, T']\) then \(x\) knows \(P\) at \(T\).

<p>The proof has exactly the same structure as the proof of the
previous theorem.

<h5 class="w3-text-teal">Consequence of the Theorem</h5>

\(x\) didn't learn anything in the interval  \([T, T']\); everything
\(x\) knows at the later point \(T'\) is knowledge it already had at
the earlier point \(T\). The only way for an agent to gain knowledge is
to receive messages. An agent cannot learn about other agents by only
sending messages or making internal state transitions.


<h3 class="w3-text-teal">Theorem: Knowledge implies Control</h3>
Let \(x\) and \(y\) be agents in a system, and let \(P\) be a
predicate on the states of \(y\).
Let \(T\) and \(T'\) be instants in a trajectory with \(T < T'\). If
\(x\) knows \(P\) at  \(T\), and \(\neg P\) holds at \(T'\), then there
is a path in the timeline diagram from point \(T\) on \(x\)'s timeline
to point \(T'\) on \(y\)'s timeline.

<p>Proof: If there is no path from point \(T\) on \(x\)'s timeline
to point \(T'\) on \(y\)'s timeline then there exists a consistent cut
which crosses \(x\)'s timeline at \(T\) and
crosses \(y\)'s timeline at \(T'\).

Such a cut is generated by the global-snapshot marker algorithm where
\(x\) is the initiator at point \(T\).

<h5 class="w3-text-teal">Consequence of the Theorem</h5>
Suppose you and your friend communicate only by means of messages
that are delayed by arbitrary (finite) amounts. Consider a situation
where your friend knows
that you are in the library at 9 pm. Then, from our definition of
knowledge, because agents only know truth, you must be in the library
at 9 pm. Moreover, you can't leave the library until
you receive a message from your friend; this message may go through
intermediate agents.

<p>
In one of the exercises we'll look at knowledge when agents have
clocks that may drift from each other but are not more than a some
constant \(M\) units apart. If your friend knows that you will be in
the library till her watch reads 9:00 pm, and your watches may drift apart
by a minute, then you can leave the library at 9:01 pm. Clocks are
useful even if they aren't perfect. More about clocks later.


<h3 class="w3-text-teal">Theorem: Communication to learn about
Change</h3>
This theorem is similar to the "knowledge is control" theorem.

<p>
Let \(x\) and \(y\) be agents in a system, and let \(P\) be a
predicate on the states of \(y\).
Let \(T\) and \(T'\) be instants in a trajectory with \(T < T'\). If
\(\neg P\) holds at \(T\) and \(x\) knows \(P\) at \(T'\) then there
is a path in the timeline diagram from point \(T\) on \(y\)'s timeline
to point \(T'\) on \(x\)'s timeline.



<h3 class="w3-text-teal">What Agents Know about Channel States</h3>
Next, let's look at systems in which messages are acknowledged.
For a pair of agents \(x, y\), let \(ms\) and \(mr\)
be the number of messages that \(x\) has sent to \(y\), and  the number 
of messages that \(y\) has received from \(x\), respectively.
Let \(as\) and \(ar\) be
the number of acknowledgements that \(y\) has sent to \(x\), and
the number of acknowledgements that \(x\) has received from \(y\),
respectively.

The following is an invariant:
<p>
\(ms \geq mr \geq as \geq ar \)

<p>
The number of messages in the channel from \(x\) to \(y\) is \(ms -
mr\).
Because \(ms\) and \(ar\) are variables of agent \(x\),
agent \(x\) <i>knows</i> an upper bound,\(\; ms - ar\), on the number of
messages in channel \((x, y)\).
So, \(x\) knows that the channel is empty when \(\; ms = ar\).

<p class="w3-text-teal">What an agent cannot know</p>
An agent cannot know that there are
exactly \(n\) messages in a channel, for \(n > 0\).
You can prove this result using the concept of consistent
cuts. Intuitively, the agent cannot know whether a message is in the
channel or has been received.

<h3  class="w3-text-teal">The Predicate \(x\) knows \(P\)</h3>
We define a predicate "\(x\) knows \(P\)" as the weakest predicate \(Q\)
that satisfies:
<p>
    \(
    [init \; \Rightarrow \; always([Q \;
    \Rightarrow \; P])]
\)
<p>
As defined earlier, the predicate \(x\) knows \(P\) holds for a state
\(r\) exactly when \(x\) in state \(r\) knows \(P\).
<p>
For example, in a system that passes tokens between agents, the
predicate, "\(x\) knows that \(y\) holds no tokens," holds for those
global states where we can deduce that \(y\) holds no tokens based solely on
\(x\)'s state. 

<h4 class="w3-text-teal">Chains of Knowledge</h4>
Let \(x, y, z\) be agents of a system and \(P\) be a predicate on
states of the system. Then the following are all predicates:
<ol>
  <ul>
    \(z\) knows \(P\)
  </ul>
  <ul>
    \(y\) knows that \(z\) knows \(P\)
  </ul>
  <ul>
    \(x\) knows that \(y\) knows that \(z\) knows \(P\)
  </ul>
</ol>
The theorems given earlier apply to any predicate. For example, if
\(x\) knows that \(y\) knows that \(z\) knows \(P\) at a point \(t\) in a
trajectory, and \(\neg P\) holds at a later point \(t'\)
then there must be path in the timeline diagram from point \(t\) on
\(x\)'s timeline to point \(t'\) on \(z\)'s timeline.

<h5 class="w3-text-teal">Concurrent Systems with Shared Variables</h5>
The theorems
and proofs given in this module apply to systems with shared
variables, and indeed any system with trajectories that are
representable by timeline diagrams and with consistent cuts.

<h3 class="w3-text-teal">Summary</h3>
Many people working on distributed systems use the phrase "an agent
knows." This module gives a definition of the concept that is
consistent with intuitive definitions of knowledge.
The central idea in this module is the
relationship between what agents know and consistent cuts of
timelines. We presented several theorems about agent knowledge which
are intuitive when applied to human agents. The proofs are
straightforward and are all based on consistent cuts of timelines.

  <footer id="myFooter">

    <div class="w3-container w3-theme-l1">
      <h4>An Introduction to Distributed Algorithms by K. Mani Chandy,
      <br>
      Simon Ramo Professor, Emeritus, California Institute of Technology</h4>
    </div>
  </footer>


      


<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
  if (mySidebar.style.display === 'block') {
    mySidebar.style.display = 'none';
    overlayBg.style.display = "none";
  } else {
    mySidebar.style.display = 'block';
    overlayBg.style.display = "block";
  }
}

// Close the sidebar with the close button
function w3_close() {
  mySidebar.style.display = "none";
  overlayBg.style.display = "none";
}
</script>

</body>
</html>

